# QUIC: A UDP-Based Multiplexed and Secure Transport
https://tools.ietf.org/html/draft-hamilton-quic-transport-protocol-00

- [Abstract](#abstract)
- [1.  Introduction](#1--introduction)
- [2.  Conventions and Definitions](#2--conventions-and-definitions)
- [3.  A QUIC Overview](#3--a-quic-overview)
  - [3.1.  Low-Latency Version Negotiation](#31--low-latency-version-negotiation)
  - [3.2.  Low-Latency Connection Establishment](#32--low-latency-connection-establishment)
  - [3.3.  Stream Multiplexing](#33--stream-multiplexing)
  - [3.4.  Rich Signaling for Congestion Control and Loss Recovery](#34--rich-signaling-for-congestion-control-and-loss-recovery)
  - [3.5.  Stream and Connection Flow Control](#35--stream-and-connection-flow-control)
  - [3.6.  Authenticated and Encrypted Header and Payload](#36--authenticated-and-encrypted-header-and-payload)
  - [3.7.  Resilience to NAT Rebinding](#37--resilience-to-nat-rebinding)
- [4.  Connection Establishment](#4--connection-establishment)
  - [4.1.  Version Negotiation](#41--version-negotiation)
  - [4.2.  Combined Crypto and Transport Handshake](#42--combined-crypto-and-transport-handshake)
    - [4.2.1.  Transport Parameters and Options](#421--transport-parameters-and-options)
      - [4.2.1.1.  Encoding](#4211--encoding)
      - [4.2.1.2.  Required Transport Parameters](#4212--required-transport-parameters)
      - [4.2.1.3.  Optional Transport Parameters](#4213--optional-transport-parameters)
    - [4.2.2.  Proof of Source Address Ownership](#422--proof-of-source-address-ownership)
    - [4.2.3.  Crypto Handshake Protocol Features](#423--crypto-handshake-protocol-features)
- [5.  Streams: QUIC's Data Structuring Abstraction](#5--streams-quics-data-structuring-abstraction)
  - [5.1.  Life of a Stream](#51--life-of-a-stream)
    - [5.1.1 idle](#511-idle)
    - [5.1.2.  reserved](#512--reserved)
    - [5.1.3.  open](#513--open)
    - [5.1.4.  half-closed (local)](#514--half-closed-local)
    - [5.1.5.  half-closed (remote)](#515--half-closed-remote)
    - [5.1.6.  closed](#516--closed)
  - [5.2.  Stream Identifiers](#52--stream-identifiers)
  - [5.3.  Stream Concurrency](#53--stream-concurrency)
  - [5.4.  Sending and Receiving Data](#54--sending-and-receiving-data)
- [6.  Packetization and Reliability](#6--packetization-and-reliability)
- [7.  Flow Control](#7--flow-control)
  - [7.1.  Important considerations](#71--important-considerations)
    - [7.1.1.  Mid-stream RST_STREAM](#711--mid-stream-rst_stream)
    - [7.1.2.  Response to a RST_STREAM](#712--response-to-a-rst_stream)
    - [7.1.3.  Offset Increment](#713--offset-increment)
    - [7.1.4.  BLOCKED frames](#714--blocked-frames)
- [8.  Connection Termination](#8--connection-termination)
- [9.  Packet Types and Formats](#9--packet-types-and-formats)
  - [9.1.  Public Packet Header](#91--public-packet-header)
  - [9.2.  Special Packets](#92--special-packets)
    - [9.2.1.  Version Negotiation Packet](#921--version-negotiation-packet)
    - [9.2.2.  Public Reset Packet](#922--public-reset-packet)
  - [9.3.  Regular Packets](#93--regular-packets)
- [10.  Frame Types and Formats](#10--frame-types-and-formats)
  - [10.1.  Frames](#101--frames)
  - [10.2.  Frame Types](#102--frame-types)
  - [10.3.  STREAM Frame](#103--stream-frame)
  - [10.4.  ACK Frame](#104--ack-frame)
  - [10.5.  STOP_WAITING Frame](#105--stop_waiting-frame)
  - [10.7.  BLOCKED Frame](#107--blocked-frame)
  - [10.8.  PADDING Frame](#108--padding-frame)
  - [10.9.  RST_STREAM Frame](#109--rst_stream-frame)
  - [10.10.  PING frame](#1010--ping-frame)
  - [10.11.  CONNECTION_CLOSE frame](#1011--connection_close-frame)
  - [10.12.  GOAWAY Frame](#1012--goaway-frame)
- [11.  Error Codes](#11--error-codes)
- [12.  Security and Privacy Considerations](#12--security-and-privacy-considerations)
- [13.  Contributors](#13--contributors)
- [14.  Acknowledgments](#14--acknowledgments)
- [15.  References](#15--references)
  - [15.1.  Normative References](#151--normative-references)
  - [15.2.  Informative References](#152--informative-references)
  - [15.3.  URIs](#153--uris)

# Abstract

QUIC(Quick UDP-based Internet Connection)は、UDP上で動作する多重化されたセキュアなとランポートプロトコルです。QUICは過去の経験に基づいて作られており、モダンな汎用的なトランポートとして有用になるような仕組みを実装しています。レガシーなクライアントや中間装置との互換性の問題を解決する目的としてQUICの基礎としてUDPを使用します。第三者による変更を防ぐために、QUICは全てのヘッダを認証します。QUICはほとんどのヘッダを暗号化しているので、プロトコルの変更をQUICエンドポイントのみに限定しています。そのため中間装置の大部分はデプロイされる新しいプロトコルバージョンに更新する必要はありません。この文書では、デザインコンセプト、ワイヤフォーマット、QUICコネクションのコネクション確立方法、ストリームの多重化、ストリームとコネクションレベルのフロー制御、データの信頼性を含むcore QUICプロトコルについて記述します。付随する文書がQUICのロスリカバリと輻輳制御、鍵ネゴシエーションのためのTLS1.3の使用について記述します。

# 1.  Introduction
QUIC(Quick UDP-based Internet Connection)は、UDP上で動作する多重化されたセキュアなとランポートプロトコルです。QUICは過去の経験に基づいて作られており、モダンな汎用的なトランポートとして有用になるような仕組みを実装しています。レガシーなクライアントや中間装置との互換性の問題を解決する目的としてQUICの基礎としてUDPを使用します。第三者による変更を防ぐために、QUICは全てのヘッダを認証します。QUICはほとんどのヘッダを暗号化しているので、プロトコルの変更をQUICエンドポイントのみに限定しています。そのため中間装置の大部分はデプロイされる新しいプロトコルバージョンに更新する必要はありません。この文書では、デザインコンセプト、ワイヤフォーマット、QUICコネクションのコネクション確立方法、ストリームの多重化、ストリームとコネクションレベルのフロー制御、データの信頼性を含むcore QUICプロトコルについて記述します。

付随する文書がQUICのロスリカバリと輻輳制御[draft-iyengar-quic-loss-recovery]、鍵ネゴシエーションのためのTLS1.3の使用について記述します[draft-thomson-quic-tls]。

# 2.  Conventions and Definitions
この文書で使用する用語の定義：
- "クライアント": QUICコネクションを開始するエンドポイント
- "サーバ": QUICコネクションを受け付けるエンドポイント
- "エンドポイント": コネクションの終端となるクライアントもしくはサーバ
- "ストリーム": QUICコネクションが持つ論理的双方向の順番どおりに並び替えられたバイトチャンネル
- "コネクション": ストリームを多重化する1つの暗号コンテキストを持つ2つのQUICエンドポイント間での通信
- "コネクションID": QUICコネクションの識別子
- "QUICパケット": QUICの受信者によってパースすることが出来る正しいUDPペイロード。この文書におけるQUICパケットサイズはUDPペイロードサイズを指します。

# 3.  A QUIC Overview
簡潔にQUICの主要な仕組みと利点について記述します。QUICの主要な強みは：

- 低レイテンシのバージョンネゴシエーション
- 低レイテンシのコネクション確立
- head-of-lineブロッキングのない多重化
- 認証と暗号化されたヘッダとペイロード
- より高機能な輻輳制御とロスリカバリのシグナル
- ストリームとコネクションのフロー制御
- NATのリバンディングからの回復

## 3.1.  Low-Latency Version Negotiation
(TODO: ココに文章を追加)

## 3.2.  Low-Latency Connection Establishment
QUICはセキュアなトランポートコネクションを構築するのに暗号とトランポートのハンドシェイクに依存します。QUICコネクションは通常は0-RTTハンドシェイクを使用することが望まれます。ほとんどのQUICコネクションではデータはサーバからの返信を待たずにクライアントのハンドシェイクパケットにつづいてすぐに送信可能ということを意味します。QUICは暗号ハンドシェイク及びQUICのオプションをネゴシエーションするのに使用する専用のストリーム(ストリームID 1)を提供します。ネゴシエーション中に使用されるQUICのオプションとパラメータの形式はこの文書で記述されますが、ストリームID1で行われるハンドシェイクプロトコルは付随する暗号ハンドシェイクのドラフト [[draft-thomson-quic-tls]](https://tools.ietf.org/html/draft-thomson-quic-tls-00)によって記述されます。

## 3.3.  Stream Multiplexing
TCP上でアプリケーションのメッセージが転送されるとき、アプリケーションのメッセージはhead-of-lineブロッキングされるかもしれません。アプリケーションが抽象化されたTCPの1つのバイトストリーム上で多くのストリームを多重化するとき、アプリケーションのストリームが後続のセグメントにカプセル化されているかにかかわらず、TCPセグメントのロスは再送が到着するまで後続のセグメントを全てブロックします。

QUICは多重化された操作のために1から設計されているため、QUICは個別のデータを転送するパケットのロスは一般的にそのストリームにしか影響しないことを保証します。各ストリームフレームは到着次第そのストリームにディスパッチされます。ロスのないストリームは再構成することが出来、アプリケーションは処理をすすめることが出来ます。

## 3.4.  Rich Signaling for Congestion Control and Loss Recovery
QUICのパケットのフレーミングと確認応答は、根本な方法で輻輳制御とロスリカバリの役に立つ多くの情報を転送します。
元のQUICパケットと再送されたQUICパケット両方とも、各QUICパケットは新しいパケット番号を持ちます。これによりQUIC送信者は元々転送したものへのACKと再送したものへのACKを区別できまるようになり、こうしてTCPの再送に関する曖昧さの問題を回避できます。QUICの確認応答は受信してから確認応答を送信するまでの遅延を明示的にエンコードします。そして単調増加のパケット番号と合わせてラウンドトリップタイム(RTT)を計算出来ます。QUICのACKフレームは256までのackブロックをサポートしており、QUICはSACKをサポートするTCPより並べ変えに対して柔軟性を持ちます。同様に並べ替えや損失がある場合でも、ワイヤ上でより多くのバイトを維持できるようになります。QUICエンドポイントはピアが受信したパケットの正確な状態を得られます。

## 3.5.  Stream and Connection Flow Control
QUICはストリームレベルとコネクションレベルのフロー制御を実装し、厳密にHTTP/2のフロー制御の仕組みに従います。高レベルでは、QUICのストリームレベルのフロー制御は、以下のように動作します。QUICの受信者は各ストリームで受信しようとするデータのデータオフセットの絶対値を広告します。データが送信され、受信され、特定のストリームに引き渡されると、受信者はそのストリーム上でピアにより多くのデータを送信できるように、そのストリームのオフセット上限を増加させるWINDOW_UPDATEフレームを送信します。 

ストリーム毎のフロー制御に加えて、QUICは受信者がコネクション上で全てのストリームに割り当てようとするバッファを制限するのにコネクションレベルのフロー制御を実装します。コネクションのフロー制御はストリームのフロー制御と同じように動作しますが、届けられたバイト列と受信した最も高いオフセットは全てのストリームにわたってまとめられます。

## 3.6.  Authenticated and Encrypted Header and Payload
TCPヘッダはワイヤ上で平文で見えますし、認証されません。これによってTCPでは受信ウィンドウの操作やシーケンスナンバーの上書きといった、多くのインジェクションやヘッダが操作される問題が生じています。これらのいくつかは能動的攻撃ですが、その他は中間装置によってTCPのパフォーマンスを改善するのに使用されます。しかしながら、MPTCPの設計とその後のデプロイ性の問題で見られたように、 "パフォーマンスの改善"を行う中間装置はトランスポートプロトコルの発展性を制限します。

QUICパケットは常に認証され、一般的にペイロードは完全に暗号化されます。暗号化されないパケットのヘッダ部分は受信者によって認証され、第三者によるパケットの挿入や操作を阻止します。

警告: 接続をリセットするPUBLIC_RESETパケットは現在は認証されません

## 3.7.  Resilience to NAT Rebinding
 QUICコネクションは、クライアントによってランダムに生成される64bitのコネクションIDによって識別されます。QUICの一貫性のあるコネクションIDは、NATのリバンディングのようなことが起こってクライアントのIPやポートが変わったとしてもコネクションを存続させることが出来ます。クライアントは同じセッション鍵を暗号化と復号に使用し続けるので、QUICはリバインドされたクライアントの自動的な暗号的検証を提供します。

# 4.  Connection Establishment
QUICのコネクション確立はコネクション確立のレイテンシをおさえるために、バージョンネゴシエーションに暗号とトランスポートのハンドシェイクを組み合わせます。その後の暗号とトランスポートのハンドシェイクはバージョンネゴシエーションの成功に依存するため、まずバージョンネゴシエーションについて記述します。

## 4.1.  Version Negotiation
クライアントからサーバに送信される最初のパケットはversionフラグがセットされ、使用するプロトコルバージョンを指定しなければなりません。サーバからversionフラグがオフのパケットを受信するまで、クライアントから送信する全てのパケットはversion フラグがオンである必要があります。サーバがクライアントからversionフラグがオフのパケットを受信した後、サーバはversionフラグがオンのいかなる(遅延しているかもしれない)パケットも無視しなければいけません(MUST)。

サーバが新しいコネクションのコネクションIDをもつパケットを受信したとき、サーバはクライアントのバージョンと自身がサポートするバージョンを比較しなければなりません(MUST)。

- もしサーバがクライアントのバージョンが受け入れることが出来れば、サーバはコネクションのライフタイムまでこのプロトコルバージョンを使用しなければなりません(MUST)。サーバから送られる後続の全てのパケットはversionフラグがオフになっていなければなりません(MUST)。

- もしサーバがクライアントのバージョンが受け入れることが出来なければ、サーバはVersion Negotiation Packetをクライアントに送信しなければなりません(MUST)。このパケットはversionフラグがセットされており、サーバのサポートするバージョンが含まれます。この場合、サーバがクライアントのデータを処理する前に、1-RTTの遅延をこうむります。

クライアントがサーバからVersion Negotiation Packetを受信したとき、クライアントは受け入れ可能なプロトコルバージョンを選択し、選択したバージョンで全てのパケットを送信し直します。これらのパケットはversionフラグがセットされており、新しくネゴシエーションしたプロトコルバージョンを含みます。最終的には、クライアントは、サーバからバージョンネゴシエーションの終了をしめすversionフラグがオフになっている最初のパケットを受信し、クライアントは後続のパケットをversionフラグをオフで送信します。

ダウングレード攻撃を避けるために、クライアントとサーバはサポートするバージョンを対応する暗号ハンドシェイクデータにも含めます。クライアントはVersion Negotiation Packetの中のバージョンリストとハンドシェイクのサーバのバージョンリストが一致することを検証する必要があります。サーバはハンドシェイクから得られたクライアントのバージョンが実際にはサポートしていないプロトコルバージョンを表すことを検証する必要があります。

コネクションが確立している間は、ハンドシェイクは様々なトランスポートパラメータをネゴシエーションする必要があります。現在定義されているトランスポートパラメータはこの文書の後で記述されます。

## 4.2.  Combined Crypto and Transport Handshake
QUICは、コネクションの確立の遅延を最小にするための暗号とトランスポートを合わせたハンドシェイクに依存します。QUICはコネクションとセキュリティを合わせたハンドシェイクを行うのに使用する専用のストリーム(ストリームID 1)を提供します。暗号ハンドシェイクプロトコルは暗号ストリーム上でトランスポートハンドシェイクをカプセル化しピアに転送します。最初のクライアントからサーバへのQUICパケットは暗号ストリーム上で、Streamフレームとしてハンドシェイク情報を転送しなければなりません(MUST)。

### 4.2.1.  Transport Parameters and Options
ハンドシェイクのトランスポートコンポーネントは、QUICコネクションのための以下のパラメータのネゴシエーション及び交換を担当します。全てのパラメータはネゴシエーションされません、幾つかのパラメータは片方向のみに送信されます。これらのパラメータとオプションはエンコードされ暗号ハンドシェイクプロトコルに渡されピアに送信されます。

#### 4.2.1.1.  Encoding
(TODO:例を持ってフォーマットを記述する)
QUICはトランスポートパラメータとオプションをタグと値のペアを7bitのASCII文字としてエンコードします。QUICパラメータタグのリストは以下のとおりです。


#### 4.2.1.2.  Required Transport Parameters
- SFCW: ストリームのフロー制御ウィンドウ。このパラメータの送信者によって広告されるストリームレベルのフロー制御のバイトオフセット。
- CFCW: コネクションのフロー制御ウィンドウ。このパラメータの送信者によって広告されるコネクションレベルのフロー制御のバイトオフセット。
- MSPC: コネクションごとにの内方向のストリームの最大数。

#### 4.2.1.3.  Optional Transport Parameters
TCID: コネクションIDの切り捨て。コネクションIDの切り捨てをサポートしていることを示します。もしピアによって送信されたら、ピアに送信されたコネクションIDは0byteに切り捨てられるます。一般的に一つのQIOCコネクションを一時的なUDPポートで使用する場合に有用です。

COPT: Connection Optionsはタグフィールドの繰り返しです。このフィールドにはクライアントまたはサーバによって要求される任意の接続オプションが含まれます。これらは基本的に実験のために使用され、時間とともに変わっていきます。ユースケースの例として、輻輳制御アルゴリズムの変更や初期ウィンドウのようなパラメータです。
(TODO:コネクションオプションのリスト)


### 4.2.2.  Proof of Source Address Ownership
一般にトランスポートプロトコルは、送信元アドレスを偽装した悪意あるクライントから保護するために、クライアントのアドレス所有の検証に1ラウンドトリップを使います。QUICは主にラウンドトリップによる遅延をなくすために、Source Address Token (STK)と呼ばれるCookieを使用します。この技術はTCP Fast OpenでTCPコネクション確立のラウンドトリップ遅延を回避するために使用するCookieに似ています。

新しいコネクションにおいて、QUICサーバはSTKを送信します。これは、ランダムな値でクライアントによって保存されます。続くコネクションでは、ハンドシェイク中にクライアントはIPの所有権を証明するのにそれを送り返します。

QUICサーバも、サーバが指定したStateless RejectsのためのコネクションIDを保存するのにSTKを使用し、やってきたコネクションが正しいコネクションIDを持つことを検証します。

QUICサーバはさらにSTKに、同じクライアントとの今後のコネクション開始に役立つ測定した帯域幅、測定した最小のRTTといったその他のデータを保存できます(MAY)。サーバは、クライアントのSTKに保存されているサーバの状態を更新するためにコネクション中に更新されたSTKメッセージを送信できます。
(TODO: サーバとクライアントのSTKに関わる行動、エンコーディング、STKにどんな情報を配置するかの推奨事項を記述する。SCUPメッセージに付いて記述する。)

### 4.2.3.  Crypto Handshake Protocol Features
QUICは自身が使用する具体的なハンドシェイクプロトコルを制限しません、そのため具体的なハンドシェイクプロトコルの詳細ははこの文書のスコープ外です。もしアプリケーションのマッピングにおいて明示的に指定されていなければ、[[draft-mthomson-quic-tls]](https://tools.ietf.org/html/draft-thomson-quic-tls-00)で記述されているTLSがデフォルトの暗号ハンドシェイクプロトコルとして想定されます。QUICにマッピングするアプリケーションは、使用する代替の暗号ハンドシェイクプロトコルを指定できます(MAY)。

以下の要件と推奨事項のリストは、任意のハンドシェイクプロトコルによって提供されなければならないハンドシェイクの特性について記述しています。

- トランスポートネゴシエーション: 暗号ハンドシェイクは、トランスポートコンポーネントのためにトランスポートパラメータとSource Address Tokensの交換の仕組みを提供しなければなりません(MUST)。

- 0-RTTのコネクション確立: 低レイテンシのコネクション確立がQUICの重要な機能であるため、QUICのハンドシェイクプロトコルは、同じエンドポイント間で再度コネクションするときために0-RTTのコネクション確立を達成しようとすべきです(SHOULD)。

- 送信元アドレスの偽造防御: QUICは送信元アドレスの検証を行うため、暗号プロトコルは別の送信元アドレスの検証方式を課すべきではありません(SHOULD NOT)。

- サーバの設定更新: QUICサーバは、クライアントのSTKに格納された情報を更新し、0-RTT接続によるコネクション確立ができる期間を延長するために、通信中にsource-address token (STK) を新しく出来ます。

- 証明書の圧縮: 初期のQUICの経験則によって、ハンドシェイク中は証明書を圧縮して交換することがレイテンシの軽減に価値が有ることが実証されています。くわえて、サーバが大きな証明書を送信する場合は、増幅攻撃を軽減するのに役に立ちます。これは、TLSでは一般的ではありません。暗号プロトコルは証明書の圧縮すべきですし、ハンドシェイク中に送信されるパケットの数は最小にすべきです(SHOULD)。

# 5.  Streams: QUIC's Data Structuring Abstraction
QUICで提供されるストリームは軽量で、順番通りに並び替えられ、双方向の抽象化されたバイトストリームです。ストリームはクライアントもしくはサーバによって生成され、他のストリームにインタリーブして同時にデータを送信することが出来き、キャンセルすることも出来ます。QUICのストリームのライフタイムはHTTP/2(RFC7540)にならって厳密にモデル化されています。ストリームはお互いに独立して、順番通りに配送されます。ストリーム間の転送順番は実装に任されています。(TODO:QUICの優先制御のためのHTTP/2のようなPRIORITYフレームを含む優先度方式の定義の文章)。QUICのストリームはストリームの作成と削除が計算コストと帯域が最小限になるように要求し、軽量性を考えられています。1つのSTREAMフレームが、ストリームを作成し、ストリームのデータを転送し、ストリームを削除するか、もしくはコネクション中でストリームは最後まで残るかもしれません。そのため実装はストリームの作成と削除が出来るだけ軽量に行えるように意識して実装するようにアドバイスします。

## 5.1.  Life of a Stream
QUICストリームのセマンティクスはHTTP/2のセマンティクスを元にしています。そしてQUICストリームのライフサイクルは、QUICの順番通りでないの配送の可能性に対応するために幾つかの違いはあるものの、HTTP/2[RFC7540]のストリームに準じます。QUICストリームのライフサイクルは、以下の図で説明します。

```
                        app     +--------+
                 reserve_stream |        |
                 ,--------------|  idle  |
                /               |        |
               /                +--------+
              V                      |
        +----------+ send data/      |
        |          | recv data       | send data/
    ,---| reserved |------------.    | recv data
    |   |          |             \   |
    |   +----------+              v  v
    |               recv FIN/   +--------+ send FIN/
    |            app read_close |        | app write_close
    |                 ,---------|  open  |-----------.
    |                /          |        |            \
    |               v           +--------+             v
    |        +----------+            |             +----------+
    |        |   half   |            |             |   half   |
    |        |  closed  |            | send RST/   |  closed  |
    |        | (remote) |            | recv RST    | (local)  |
    |        +----------+            |             +----------+
    |            |                   |                    |
    |            | recv FIN/         |          send FIN/ |
    |            | app write_close/  |    app read_close/ |
    |            | send RST/         v          send RST/ |
    |            | recv RST     +--------+      recv RST  |
    | send RST/  `------------->|        |<---------------'
    | recv RST                  | closed |
    `-------------------------->|        |
                                +--------+
```

send:エンドポイントがそのフレームを送信する  
recv:エンドポイントがそのフレームを受信する  
data: STREAMフレーム内のアプリケーションデータ  
FIN: FINフラグのセットされたSTREAMフレーム  
RST: RST_STREAMフーレム  

app: QUICへのシグナルを出すアプリケーションAPI   
reserve_stream: ストリームIDを後の使用に予約する  
read_close: FINの受信なしにストリームをhalf-closedにする  
write_close: FINの送信なしにストリームをhalf-closedにする  

このダイアグラムはストリームの状態遷移を示し、これらの遷移に影響するストリームとフラグのみ示めしていることに注意して下さい。状態遷移の目的のために、FINフラグはそれを運ぶフレームとは異なるイベントとして処理されます。つまり、FINフラグがセットされたSTREAMフレームは2つの状態遷移を引き起こします。Finビットが空のSTREAMフレームで送信された時、そのSTREAMフレームのオフセットはそのストリーム上で送られた最後のデータバイトよりも1大きいものを持たなければなりません(MUST)。

両方のエンドポイントは主観的に、フレームが転送中の時は異なるストリームの状態の見え方をします。エンドポイントはストリームの作成を調整しません。そのため、ストリームはエンドポイントによって一方的に作成されます。状態の不整合によるネガティブな影響は、RST_STREAMを送信した後の"closed"状態に限定されます。その状態ではフレームはクローズした後の時間にフレームが受信されるかもしれません。

ストリームは以下の状態を持ちます。

### 5.1.1 idle
全てのストリームは"idle"から開始します。

このステートから以下の遷移が有効です:

STREAMフレームの送信または受信によっては、ストリームを"open"になります。ストリーム識別子はセクションXXで説明される通りに選択されます。同じSTREAMフレームによってすぐに"half-closed"へと遷移させることもできます。

アプリケーションはidleストリームを後の使用に予約することも出来ます。予約されたストリームの状態は"reserved"に遷移します。この状態のストリームでSTREAMかRST_STREAM以外のフレームを受信した場合はタイプYYYYのコネクションエラー(セクションXX)として扱わなければなりません(MUST)。

### 5.1.2.  reserved
この状態のストリームはアプリケーションによって後の使用のために予約されています。この状態では以下の遷移のみが可能です:

- STREAMフレームを送信するか受信によってストリームは"open"になります。
- RST_STREAMフレームを送信するか受信によってストリームは"closed"になります。

### 5.1.3.  open
"open"状態のストリームは両方のピアによってどんなタイプのフレームの送信にも使用されます。この状態では、送信するピアはそ受信するピアによって広告されるフロー制御の制限を順守しなければなりません(セクションXX)。

この状態からは、どちらかのエンドポイントがFINフラグのセットされたフレームを送信することが出来ます。これによりストリームは"half-closed"の状態のいずれかに遷移します。エンドポイントがFINフラグを送信するとストリームの状態は"half-closed (local)"になります。エンドポイントがFINフラグを受信するとストリームの状態は"half-closed (remote)"になります。そのため、受信したエンドポイントはストリーム上で先行する全てのデータが受信されるまで、FINフラグを処理してはいけません（MUST NOT）。

この状態ではどちらかのエンドポイントがRST_STREAMフレームを送信できます。それにより直ちに"closed"へ遷移します。

### 5.1.4.  half-closed (local)
"half-closed (local)"状態のストリームはSTREAMのフレームの送信に使用してはいけません(MUST NOT)。WINDOW_UPDATEとRST_STREAMはこの状態でも送信できます。

FINフラグを持つフレームが受信されるか、どちらかのピアがRST_STREAMを送信した場合、ストリームはこの状態から"closed"へ遷移します。

エンドポイントはこの状態では如何なるタイプのフレームも受信できます。WINDOW_UPDATEフレームを使用してフロー制御のクレジットを提供することは、フロー制御されるフレームを受信し続けるのに必要です。この状態では、受信者はこのストリームへのWINDOW_UPDATEフレームを無視しなければなりません。WINDOW_UPDATEフレームはFINフラグを運ぶフレームが送信された後の短かい間だけ届くかもしれません。

### 5.1.5.  half-closed (remote)
”half-closed (remote)”のストリームはもはやピアによって如何なるデータを送信するのに使用されません。この状態では、送信者は、受信者のストリームレベルのフロー制御を維持する義務はありません。

もしこの状態のエンドポイントがこのストリームへのSTREAMフレームを受信した場合、QUIC_STREAM_DATA_AFTER_TERMINATIONエラー(セクションXX)でコネクションをクローズしなければなりません(MUST)。

この状態のストリームはエンドポイントによって如何なるタイプのフレームを送信するのに使用されます。この状態では、エンドポイントは、アドバタイズされたストリームレベルとコネクションレベルのフロー制の制限（セクションXX）を順守し続けます。

FINフラグを持つフレームを送信するか、どちらかのエンドポイントがRST_STREAMフレームを送信するとき、ストリームはこの状態から"closed"に遷移します。

### 5.1.6.  closed
"closed"状態は最後の状態です。

最終オフセットはFINフラグを運ぶフレームとRST_STREAMの両方に現れます。ストリームでこれらのフレームのいずれかを送信する際に、エンドポイントは最終オフセットを超えてデータを運ぶSTREAMフレームを送信してはいけません(MUST NOT)

どちらかがFINフラグや想定される全てのデータが受信されるかRST_STREAMフレームを受信した後に、このストリームで如何なるフレームを受信するエンドポイントは、一つの例を除き粛々とそのフレームを破棄しなければなりません(MUST)。もし受信された最終オフセットを超えてSTREAMフレームが受信された場合、エンドポイントはQUIC_STREAM_DATA_AFTER_TERMINATIONエラーでコネクションをクローズしなければなりません(MUST)(セクションXX)。

RST_STREAMフレームを受信した(そしてFINフラグやRST_STREAMを送っていない)エンドポイントは
すぐにRST_STREAMフレームで返信しなければなりません(MSUT)、そしてこのストリーム上でこれ以上のどんなデータも送信してはいけません(MUST NOT)。このエンドポイントは、RST_STREAMフレームを受信したストリーム上で、フレームを受信し続ける可能性もあります。

もしRST＿STREAMを送った結果としてこの状態に到達した場合、RST_STRAEMを受信したピアは引き止められず、すでそのストリームでフレームを送信しているかもしれません、または送信キューに入れられているかもしれません。エンドポイントはRST_STREAMを送信した後にclosedなストリーム上でフレームを受信した場合無視しなければなりません(MUST)。エンドポイントはフレームを無視する期間を制限することを選択できます(MAY)、そしてこの期間を過ぎて届いたフレームをエラーとして扱えます。

RST_STREAMを送信した後に受信したSTREAMフレームは、コネクションとストリームのフロー制御ウィンドウにカウントされます。これらのフレームが無視されたとしても、それらは送信者がRST_STREAMを受信する前に送信されたため、送信者はそれをフロー制御ウィンドウに対してカウントします。

この文書ではより具体的な指針はありませんので、実装はこの状態の説明で明示的に許可されてないフレームの受信をコネクションエラーとして扱うべきす(SHOULD)。未知のフレームタイプは無視されます。

(TODO: QUIC_STREAM_NO_ERROR は特別なケースです。書きあげる)

## 5.2.  Stream Identifiers
ストリームIDと呼ばれる非負の32bit整数によってストリームは識別されます。ストリームIDの衝突を避けるために、クライアントは奇数のストリームIDでストリームを開始しなければなりません(MUST。サーバによって開始されるストリームは偶数のストリームIDで開始されなければなりません(MUST)。

0のストリームIDは予約されており、コネクションレベルのフロー制御のフレームで使用されます。0のストリームIDは新しいストリームの作成に使用できません。

ストリームID1(0x1)は暗号ハンドシェイクのために予約されています。ストリームID 1はアプリケーションデータに使用してはいけません(MUST NOT)。そしてクライアントが最初に開始するストリームでなければなりません(MUST)。

ストリームは任意の順番で作成できます(MAY)。QUICのエンドポイントはコネクション上でストリームIDを再利用してはいけません。

## 5.3.  Stream Concurrency
エンドポイントはトランスポートパラメータの中でMSPCを設定することで、内向きのアクティブなストリーム数を制限することが出来ます。最大ストリーム並列数の設定は、各エンドポイントに指定されるものであり、設定を受信したピアのみに適応されます。つまり、クライアントはサーバが開始できるストリーム最大並列数を指定し、そしてサーバはクライアントが開始できるストリーム最大並列数を指定しします。

"open"の状態のストリームかどちらかの"half-closed"状態のストリームが、エンドポイントが開始できるストリームの最大数にカウントされます。これら3つのどの状態のストリームでもMSPCにセットされ広告される制限にカウントされます。

エンドポイントはピアによって設定された制限を超えてはいけません(MUST NOT)。広告された並列ストリーム数を超えるSTREAMフレームを受信したエンドポイントは、それをQUIC_TOO_MANY_OPEN_STREAMSタイプ(Section XX)のエラーとしてストリームを扱わなければなりません(MUST)。

## 5.4.  Sending and Receiving Data
一度ストリームが作成されると、エンドポイントはストリームをデータの送受信に使用できます。各エンドポイントはその方向においてストリームが終了するまで、データをカプセル化した一連のSTREAMフレームを送信できます。ストリームは抽象的な順番通りに並び替えられたバイトストリームであり、それらの中には他の構造を持ちません。受信者がアプリケーションに渡している間や、送信者からの再送では、STREAMフレーム境界は維持されることを想定していません。

ストリーム上で新しいデータが送られる時、送信者はカプセル化するSTREAMフレームのオフセットのフィールドにストリームの新しいデータの最初のバイトのオフセットを設定しなければなりません（MUST）。受信者は受信されたストリームデータが順番通りに並び替えられたバイトストリームとしてアプリケーションに渡す必要があります(MUST)。受信者のフロー制御制限に違反しないかぎり、受信された順番通りでないデータは後の配送のためにバッファされ、

セクションXXで記述されているコネクションレベルのフロー制御の1つの例外を除いて、エンドポイントはフローウィンドウと輻輳制御装置を考慮せず、如何なるストリームデータも送信してはいけません(MUST NOT)。輻輳制御装置は関連するドキュメント[[draft-loss-recovery]](https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00)で記述されます。

# 6.  Packetization and Reliability
QUICのパケットの最大サイズは、ペイロードが暗号化された結果のUDPペイロードの最大サイズです。デフォルトのパケット最大長である1350バイトが推奨されます。エンドポイントは経路のMTUを判別し適切にパケットの最大値を設定するためにPLPMTUD [RFC4821]を使用すべきです(SHOULD)。

送信者は通常のQUICパケットに1つ以上のフレームをバンドルします。送信者はパケットに幾つかのフレームをバンドルすることが出来ます(MAY)。全てのQUICパケットはPacket Sequence Number(PSN)を含む必要があり(MUST)、1つ以上のフレームを含むことが出来ます(MAY)。PSNはコネクションの中で一意である必要があり(MSUT)、同じコネクションの中で再利用してはいけません（MUST NOT）。PSNは厳密に単調増加でパケットに割り当てられなければなりません(MUST)。

送信者は１つのQUICパケットに出来るだけ多くのフレームをバンドルして、パケットごとの帯域と計算コストを最小化するべき(SHOULD)。送信者は小さなパケットを大量に送信するのを避けるために、最大限つめ込まれてないパケットを送信する前に、複数のフレームをバンドルために少しの間待つことが出来ます（MAY）。

通常のQUICパケットはフレームのコンテナです。パケット全体は決して再送されませんが、必要があればロスしたフレームは後続のパケットに再びバンドルされ送信されます。

パケットはフレームとアプリケーションデータを含むことが出来ます、それらの幾つかだけが信頼性を必要とするかもしれません。パケットがロスが検出された時、送信者は再送する必要があるフレームとアプリケーションデータのみを再びバンドルすべきです(MUST)。

- １つの例外はありますが、STREAMフレームで送信される全てのアプリケーションデータは再送される必要があります(MUST)。エンドポイントがRST_STREAMフレームを送信したとき、受信者はそのストリーム上の後続のデータが送信されることを期待していないので、そのストリーム上の未処理データが再送されるべきではありません(SHOULD NOT。

- ACKとSTOP_WAITINGとPADDINGフレームは再送されてはいけません(MUST NOT)。しかし、新しくこれらのタイプのフレームが送信されるパケットにバンドルされるかもしれません。

- それ以外の全てのフレームは再送される必要があります(MUST)。

ロスが検出された時、送信者は適切な輻輳制御の行動をとらなければなりません(MUST)。ロス検出と輻輳制御の詳細は [[draft-loss-recovery]](https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00)で記述されます。

受信者は受信したパケットのPSNを含む1つ以上のACKフレームを送信することで、受信したパケットへの確認応答とします。エンドポイント間で永久的なACKを防ぐために、受信者はACKフレームのみを含むパケットには確認応答を生成してはいけません(MUST NOT)。戦略と確認応答を生成する頻度は[[draft-loss-recovery]](https://tools.ietf.org/html/draft-iyengar-quic-loss-recovery-00)でより詳しく記述されます。

#  7.  Flow Control
QUICはHTTP/2のフロー制御に似たクレジットに基づくフロー制御方式を採用しています。

受信者はコネクション全体と指定されたストリーム上で受信しようとするオクテットの数を広告します。これはQUICに2つのレベルのフロー制御をもたらします。(i)コネクションフロー制御は、受信者のコネクションのバッファ容量を超えることから送信者を防ぎます。(ii)ストリームフロー制御は、1つのストリームでコネクションのための受信バッファ全体を消費するのを防ぎます。

受信者は、コネクションとストリームのフロー制御両方のために、送信者に追加のクレジットを広告するためのWINDOW_UPDATEを送信します。 受信者はストリームやコネクションで受信しようと思う最大バイトオフセットの絶対値を広告します。

ストリームとコネクションフロー制御の、初期フロー制御クレジットは65536バイトです。

受信者はコネクション中の任意の時点でWINDOW_UPDATEを送信することで大きなオフセットを広告できます(MAY)。受信者は広告した事を破ってはいけません（MUST NOT）。つまり、一度受信者がWINDOW_UPDATEフレームでオフセットを広告すると、 続けて小さなオフセットを広告してはいけません(MUST)。送信者はWINDOW_UPDATEフレームを正しくない順番で受信するかもしれません。 そのため送信者はいかなるフロー制御クレジットの減少も無視しなければなりません（MUST ）。

送信者はデータを書き込もうとしたがストリームかコネクションのフロー制御クレジットが無いためブロックされていることを示すために、BLOCKEDフレームを送信しなければなりません（MUST）。BLOCKEDフレームは通常はまれに送信されることが想定されていますが、デバッグやモニタリングの目的にも有用です(MAY)。

受信者は適切なストリームIDを持つWINDOW_UPDATEフレームを送信することで、ストリームのためにクレジットを広告します。受信者は広告するフロー制御クレジットを決めるために、単純に現在受信したオフセットを使用できます。

コネクションフロー制御はSTREAMフレームで送信される全てのストリームデータのバイト合計値を制限します。受信者は適切なストリームIDが0のWINDOW_UPDATEフレームを送信することで、コネクションのためにクレジットを広告します。受信者は、WINDOW_UPDATEフレームで広告されるコネクションフロー制御のオフセット値を決定するために、全てのストリーム上で受信したバイト数の合計値を累積的に管理します。
送信者はコネクションフロー制御に制限を課すために、送信されるストリームデータのバイト数の累積合計を管理します。

## 7.1.  Important considerations
ストリームとコネクションレベルのフロー制御を扱う時に、考慮しなければならにエッジケースがあります。十分な時間が与えられれば、両方のエンドポイントはフロー制御の状態を合意できます。しかし、片方がもう片方が受信したいと思ってる以上に送れると考えている場合、多くのデータが届きコネクションは壊れてしまうでしょう。逆に、もし送信者がブロックされていると考えている場合は、届くことのないWINDOW_UPDATEを待ち続けることによって、コネクションはデッドロックになりえます。

### 7.1.1.  Mid-stream RST_STREAM
RST_STREAMフレームを受信すると、ストリームを削除し、エンドポイントは一致するストリーム上で届くデータを無視します。
RST_STREAMフレームは正しくない順番で到着するかもしれないし、転送中のバイト列もあるかもしれないので、結果としてエンドポイントは同期状態からずれてしまいます。データ送信者はコネクションレベルのフロー制御のバジェットに対してデータをカウントしますが、それらのバイト列を受信していない受信者はそれらが含まれていることも知らないでしょう。受信者はコネクションフロー制御装置が同じように調整されるようにするため、ストリーム上で送信されたバイト数を知る必要があります。

同期ずれしないように、RST_STREAMの送信者は、そのストリーム上で送信するス最終バイトオフセットをRST_STREAMに含めなかればなりません(MUST)。RST_STREAMを受信するとき、受信者はいくつのバイトがRST_STREAMの前に受信されるかを間違いなく分かります。そして、受信者は、そのコネクションレベルのフロー制御装置でにストリーム上で送信されたすべてのバイトを考慮して最終オフセットを使用しなければなりません。

### 7.1.2.  Response to a RST_STREAM
ストリームは双方向であるため、RST_STREAMの送信者はそのストリーム上でピアがどれくらいのバイト数を送信したか知る必要があります。もしエンドポイントがRST_STREAMフレームを受信し、FINやRST_STREAMのどちらも送信して無ければ、そのエンドポイントは、レスポンスでこのストリームで送信した最後のバイトオフセットを最終オフセットとして運ぶRST_STREAMを送信しなければなりません（MUST）。

### 7.1.3.  Offset Increment
この文書では、実装にいつどれくらいのバイトをWINDOW_UPDATEで広告すればいいかを記述しませんが、いくつかの考察を提供しています。WINDOW_UPDATEフレームはオーバーヘッドとなります、それゆえ、小さいオフセットのWINDOW_UPDATEを送信することは望ましくありません。同時に、大きなオフセットの増加させるWINDOW_UPDATEは大きなバッファ量のコミットを送信者に要求します。実装はWINDOW_UPDATEでどれくらい大きなオフセットの増加を送信すればいいかという点で、
適切なトレードオフを見つけなければなりません。

受信者は、TCPの実装と似たラウンドトリップタイムの見積もりとアプリケーションが消費するデータを受信する頻度に基づいた、広告されるオフセットサイズの増加量を調整するのに自動チューニングを使用できます(MAY)。

### 7.1.4.  BLOCKED frames
フロー制御クレジットを使いきってしまった時、もし送信者がWINDOW_UPDATEフレームを受信しなければ、送信者はブロックされておりBLOCKEDフレームを送信できます(MAY)。

受信者はWINDOW_UPDATEで応答する前に、BLOCKEDフレームを待つべきではありません。それをすると少なくとも1ラウンドトリップの停止を引き起こすためです。さらに、もしブロックされると送信者は静止状態になり、その結果として輻輳制御のパフォーマンス低下させる可能性があります。スムーズな輻輳制御の操作のために、一般的に回避できるのなら送信者を静止させないようにするのが最良です。

送信者をブロックさせないように、合理的なロスの可能性を計上し、送信者がブロックされる前に受信者はすくなくとも2ラウンドトリップタイムに一回WINDOW_UPDATEフレームを送信すべきです。

# 8.  Connection Termination
コネクションは事前にネゴシエーションした時間の間アイドルするまで維持されるべきです。一度確立されたQUICコネクションは以下の2つの方法で終了されます。

1. 明示的なシャットダウン: エンドポイントはピアにコネクションの終了を開始するためにCONNECTION_CLOSEを送信します。
エンドポイントはピアにCONNECTION_CLOSEフレームを 送信する前に、直ちにコネクションを終了することを示すGOAWAYフレームを送信しても良いです(MAY)。GOAWAYフレームは、幾つかのアクティブなストリームを処理し続けようとするピアへの合図となりますが、GOAWAYの送信者は如何なるストリームの開始しませんし、新しいストリームの受理もしません。

アクティブなストリームの終了する際に、CONNECTION_CLOSEが送信されるでしょう。終了されてないストリームがアクティブな時(FINビットがないか、1つ以上のストリームでRST_STREAMフレームが送受信されていない)にもしエンドポイントがCONNECTION_CLOSEフレームを送った場合、そのときはピアはストリームは完了しておらず異常終了したと考えなければなりません。
 
2. 暗黙的シャットダウン: QUICコネクションのデフォルトのアイドルタイムアウトは30秒で、コネクションネゴシエーションでそのパラメータ(ICSL)は要求されます。最大は10分です。もしアイドルタイムアウトの間ネットワークアクティビティがなければ、コネクションはクローズされます。デフォルトでCONNECTION_CLOSEフレームが送信されます。無線の起動を必要とするモバイルネットワークといった、明示的なクローズの送信が高価な場合、静かなクローズオプションは使用できます。

接続中の任意の時にエンドポイントはアクティブなコネクションを不意に終了されるPUBLIC_RESETパケットを送ることも出来ます。 

# 9.  Packet Types and Formats
QUICは2つのタイプのパケットを持ちます。フレームを含むRegular PacketとSpecial Packetです。Special Packetsには2つのタイプが有ります。Version Negotiation Packets と Public Reset Packetsです。全てのQUICパケットはIPフラグメンテーションを防ぐために経路のMTUにあうようなサイズにするべきです。経路のMTUの検出はwork in progressです。そして、現在のQUIC実装はIPｖ6では最大1350バイト、IPv4では1370バイトを使用します。これらのサイズはIPとUDPのオーバーヘッドを除いたものです。

## 9.1.  Public Packet Header
ワイヤ上の全てのQUICパケットは2から19バイトのパブリックヘッダを持ちます。パブリックヘッダのワイヤフォーマットは以下のとおりです。

```
     0        1        2        3        4       5            8
+--------+--------+--------+--------+--------+--------+---    ---+
|Flags(8)|  Connection ID (64) (optional)   ...     | ->
+--------+--------+--------+--------+--------+--------+--    ---+

     9       10       11        12
+--------+--------+--------+--------+
|      QUIC Version (32)            | ->
|         (optional)                |
+--------+--------+--------+--------+


    13       14       15        16      17       18       19       20
+--------+--------+--------+--------+--------+--------+--------+--------+
|                        Diversification Nonce                          | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    21       22       23        24      25       26       27       28
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    29       30       31        32      33       34       35       36
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+

    37       38       39        40      41       42       43       44
+--------+--------+--------+--------+--------+--------+--------+--------+
|                   Diversification Nonce Continued                     | ->
|                              (optional)                               |
+--------+--------+--------+--------+--------+--------+--------+--------+


    45      46       47        48       49       50
+--------+--------+--------+--------+--------+--------+
|           Packet Number (8, 16, 32, or 48)          |
|                  (variable length)                  |
+--------+--------+--------+--------+--------+--------+
```

ペイロードは下記に記述されるようにタイプに依存した様々なヘッダを持ちます。
public headerのフラグは以下のとおりです:

- Flag:  
  - 0x01 = FLAG_VERSION。 このフラグの意味はサーバから送られたかクライアントから送られたかに依存します。クライアントはヘッダにQUICバージョンを含むことを示すためにこのフラグをセットします(以下を参照)。クライアントは、提案したバージョンへの合意がサーバから到着したことを確認するまで、このビットをセットしなければなりません(MUST)。サーバはこのビットが設定されていなパケットを送ることで、バージョンへの合意を示します。サーバがこのビットをセットしている時、パケットはVersion Negotiation Packetです。バージョンネゴシエーションの詳細は後で詳細に記述されます。
  - 0x02 = FLAG_PUBLIC_RESET。パケットがPublic Reset packetであることを示すためにセットされます。
  - 0x04 = ヘッダ内に32 byteのnonceがあることを示します。
  -  0x08 = パケットにコネクションIDがあらわれることを示します。一定方向で異なる値がネゴシエーションされるまで、全てのパケットでセットされる必要があります。(例: クライアントはコネクションを完全に識別する5タプルを指します。そのようなコネクションはオプショナルです)
  - 0x30の2bitは各パケットで、パケット番号の下位何バイトがあらわれるかを示します。このビットはフレームパケットでのみ使用されます。パケット番号を持たないPublic Reset and Versionと Negotiation Packetsでは、これらのビットは使用されず、0がセットされなければなりません。2ビットのマスクは
    - 0x30 は6バイトのパケット番号があることを示します
    - 0x20 は4バイトのパケット番号があることを示します
    - 0x10 は2バイトのパケット番号があることを示します
    - 0x00 は1バイトのパケット番号があることを示します
  - 0x40はマルチパスの利用に予約されています。
  - 0x80は現在使用されていません。0がセットされる必要があります。

- コネクションID: これはクライアントによって識別される統計的にランダムな非負の64bitのコネクション識別子です。QUICのコネクションはクライアントがローミングしてもコネクションを維持するようにデザインされているため、4タプル（送信元IP、送信元ポート、宛先IP、宛先ポート）は接続を識別するのに不十分な可能性があります。各転送方向で、4タプルでコネクションを識別するのに十分な時は、コネクションIDは省略できます。

- QUIC Version:QUICプロトコルのバージョンを表す32bitのタグです。FLAG_VERSIONがフラグに含まれる場合の存在します。クライアントはこのフラグをセットできます、そしてちょうど1つの提案するバージョンを含み、(そのバージョンに準拠している)任意のデータも含めることが出来ます。クライアントによって提案されたバージョンをサポートしてない時に、サーバはこのフラグを使用し、0個以上の受け付けられるバージョンのリストを提供しますが、バージョンのあとにデータを含めてはいけません(MUST not)。現在の実験バージョンでのバージョン値の例は"Q025"で、9バイトの"Q"と10バイトの "0"に符号します。[この文書の最後にあるバージョンの変更リストを参照]

- Packet Number: フラグにセットされるBYTE_SEQUENCE_NUMBERに基づいて、 パケット番号の低い方の8bit か16bitか32bit か48bitです。(特別なpublic reset と version negotiation パケットとは対照的な)Each Regular Packetは送信者によってパケット番号が割り当てられます。エンドポイントによって送られる最初のパケットは1のパケット番号を持つでしょう。後続のパケットは先に送ったパケット番号より1大きいパケット番号を持ちます。64bitより小さいパケット番号は暗号のnonceの一部として使用されます。そのため、QUICエンドポイントは64bitで表現できないパケット番号を持つパケットを送信してはいけません(MUST NOT)。もしQUICのエンドポイントが(2^64-1)のパケット番号を送信した場合、パケットはQUIC_SEQUENCE_NUMBER_LIMIT_REACHEDエラーコードを持つCONNECTION_CLOSEフレームを含んでなければなりません(MUST)。そしてエンドポイントはさらなるパケットを送信してはいけません。受信者が曖昧でないパケット番号の再構築を出来るようにするため、QUICのエンドポイントは、受信者によって送信されたと知ることが出来る最大のパケット番号よりもパケット番号が(2^(bitlength-2))だけ大きいパケットを送信してはいけません(MUST NOT)。そのため、送信中のパケットに(2^46)よりおおきなパケットは存在してはいけません。ピアによって受信された切り詰められたパケット番号は、ピアから受信し確認されたパケット番号の最大値よりも1大きい事が推測されます。送信されたパケット番号の一部は推測された値と最下位ビットが一致します。

フラグの処理フローチャートを以下に示す
```
Check the flags in public header
                 |
                 |
                 V
           +--------------+
           | Public Reset |    YES
           | flag set?    |---------------> Public Reset Packet
           +--------------+
                 |
                 | NO
                 V
           +------------+          +-------------+
           | Version    |   YES    | Packet sent |  YES
           | flag set?  |--------->| by server?  |--------> Version Negotiation
           +------------+          +-------------+               Packet
                 |                        |
                 | NO                     | NO
                 V                        V
           Regular Packet         Regular Packet with
                              QUIC Version present in header
```
## 9.2.  Special Packets

### 9.2.1.  Version Negotiation Packet

Version Negotiationパケットはサーバによってのみ送信されます。Version Negotiationパケットは8bitフラグと64bitのコネクションIDではじまります。フラグはFLAG_VERSIONセットされ、コネクションIDが64bitであることを示す必要があります。Version Negotiationパケットの残りは、サーバがサポートする4バイトのバージョンのリストです。
```
     0        1        2        3        4        5        6        7       8
+--------+--------+--------+--------+--------+--------+--------+--------+--------+
|Flags(8)|    Connection ID (64)                                                 | ->
+--------+--------+--------+--------+--------+--------+--------+--------+--------+

     9       10       11        12       13      14       15       16       17
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
|      1st QUIC version supported   |     2nd QUIC version supported    |   ...
|      by server (32)               |     by server (32)                |
+--------+--------+--------+--------+--------+--------+--------+--------+---...--+
```

### 9.2.2.  Public Reset Packet
Public Resetパケットは8bitのフラグと64bitのコネクションIDで始まります。PUBLIC_FLAG_RESETフラグがセットされなければなりません(MUST)。そして、ヘッダは64bit全てのコネクションIDを指し示す必要があります。Public Resetパケットは、それがPRSTタグの暗号ハンドシェイクメッセージであるかのようにエンコードされます。
```
        0        1        2        3        4         8
   +--------+--------+--------+--------+--------+--   --+
   | Public |    Connection ID (64)                ...  | ->
   |Flags(8)|                                           |
   +--------+--------+--------+--------+--------+--   --+

        9       10       11        12       13      14
   +--------+--------+--------+--------+--------+--------+---
   |      Quic Tag (32)                |  Tag value map      ... ->
   |         (PRST)                    |  (variable length)
   +--------+--------+--------+--------+--------+--------+---
```

Tag value map:value mapは以下のタグと値を含みます。
- RNON(public reset nonce proof) 非負の64bit整数。必須。
- RSEQ(rejected packet number) 非負の64bit整数。必須。
- CADR (client address) 観測されたクライアントのIPアドレスとポート番号。現在これはデバッグの目的のみであり、オプショナルです。

## 9.3.  Regular Packets

それぞれのRegular PacketsはPublic Headerとそれに続く一連のフレームデータを含みます。Public Headerは認証されますが暗号化されません。そしてパケットのそれ以降から始まるフレームは認証され暗号化されます。
Public Headerにすぐ続いて、Regular PacketsはAEADデータ(認証される暗号化された関連するデータ)を含みます。続くセクションで記述されるように、復号後、平文はフレームのシーケンス番号を構成します。

(TODO: 暗号と復号への入力と、復号の試行について記述)


# 10.  Frame Types and Formats
一つのRegular Packetは複数のフレームタイプのフレームを含むことが出来ます(MAY)。フレームは、単一のQUICパケット内に収まらなければなりません(MUST)、そして、QUICパケット境界をまたがってはいけません(MUST NOT)。各フレームは、そのタイプを示すフレームタイプで始まり、タイプに依存するヘッダフィールドと可変長のデータが続きます。

## 10.1.  Frames

フレームパケットは、タイプから始まる一連のフレームであるペイロードを持ちます。フレームタイプのフォーマットはこの文書であとで記述されますが、一般的なFrame Packetのフォーマットは以下のとおりです。
```
   +--------+---...---+--------+---...---+
   | Type   | Payload | Type   | Payload |
   +--------+---...---+--------+---...---+
```

## 10.2.  Frame Types

2つのタイプのフレームが有ります。Special Frame TypesとRegular Frame Typesです。Special Frame Typesはフレームタイプと対応するフラグをそのフレームタイプのバイト内に含みますが、Regular Frame Typeはフレームタイプのバイトを単純に使用します。

現在定義されているSpecial Frame Typesは
```
      +------------------+-----------------------------+
      | Type-field value |     Control Frame-type      |
      +------------------+-----------------------------+
      |     1fdooossB    |  STREAM                     |
      |     01ntllmmB    |  ACK                        |
      +------------------+-----------------------------+
```
現在定義されている Regular Frame Typesは:
```
      +------------------+-----------------------------+
      | Type-field value |     Control Frame-type      |
      +------------------+-----------------------------+
      | 00000000B (0x00) |  PADDING                    |
      | 00000001B (0x01) |  RST_STREAM                 |
      | 00000010B (0x02) |  CONNECTION_CLOSE           |
      | 00000011B (0x03) |  GOAWAY                     |
      | 00000100B (0x04) |  WINDOW_UPDATE              |
      | 00000101B (0x05) |  BLOCKED                    |
      | 00000110B (0x06) |  STOP_WAITING               |
      | 00000111B (0x07) |  PING                       |
      +------------------+-----------------------------+
```

## 10.3.  STREAM Frame
STREAMフレームは暗黙的にストリームを作成し、ストリームデータを伝送します。STREAMフレームは以下を参照。

```
     0        1       ...               SLEN
+--------+--------+--------+--------+--------+
|Type (8)| Stream ID (8, 16, 24, or 32 bits) |
|        |    (Variable length SLEN bytes)   |
+--------+--------+--------+--------+--------+

  SLEN+1  SLEN+2     ...                                         SLEN+OLEN
+--------+--------+--------+--------+--------+--------+--------+--------+
|   Offset (0, 16, 24, 32, 40, 48, 56, or 64 bits) (variable length)    |
|                    (Variable length: OLEN  bytes)                     |
+--------+--------+--------+--------+--------+--------+--------+--------+

  SLEN+OLEN+1   SLEN+OLEN+2
+-------------+-------------+
| Data length (0 or 16 bits)|
|  Optional(maybe 0 bytes)  |
+------------+--------------+
```

STREAMフレームのヘッダフィールドは以下のとおりです:
- Frame Type: 様々なフラグ(1fdooossB)を持つ8bit値のフレームタイプ:
  - 一番左のビットはSTREAMフレームを示すために1にセットされなければなりません。
  - "f"ビットはFin ビットです。1がセットされた時、このストリームで送り終えたことと"half-close"を望むことを示します(詳細は後に記述されます)。
  - これはこの文書の後に詳細に記述されます
  - "d"ビットはSTREAMヘッダにデータ長が現れるかを示します。0がセットされた時は、このフィールドはSTRAMフレームがパケットの最後までであることを示します。
  - 次の 3つの"ooo"はヘッダフィールドのオフセット長が、0, 16, 24, 32, 40, 48, 56, 64 bit長としてエンコードされます。
  - 次の 2つの"ss" bitはストリームID長を ,8,16,24,32ビットとしてエンコードされます。
- ストリームID:このストリームの一意の可変で非負のID
- オフセット: ストリームで、データブロックのオフセットバイトを指定する可変長の非負の値。ストリームの最初のバイトはオフセット0になります。
- データ長: このストリームのデータの長さを指定するオプショナルな16bitの非負の値。パディングによってダメにするリスクを避けるために、パケットがフルサイズパケットの時のみ長さを省略を使用すべきです。

STREAMフレームはゼロでないデータ長を持つか、FINビットがセットされる必要があります。

ストリームの多重化は、複数のストリームのSTREAMフレームが一つ以上のQUICパケットに押し込まれることで実現されます。一つのQUICパケットが複数のストリームのSTREAMフレームをバンドルすることができます(MAY)。

Implementation note: QUICの一つの利点はストリームにまたがるhead-of-line blockingの回避です。パケットロスが起こると、そのパケットのデータを持つストリームだけが、再送され受信するまでブロックされ、その他のストリームは処理を続けます。複数のストリームのデータが一つのQUICパケットにバンドルされていると、パケットのロスはそれら全てのストリームの処理をブロックすることに注意してください。そのため実装は、埋まりきっていないパケットの伝送効率を落とすこと無いように、発信パケットのなかに必要なストリームをバンドルするようにアドバイスします。

## 10.4.  ACK Frame
受信者は送信者にパケットを受信したことを通知するためにACKフレームを送信しますし、同様にどのパケットが不足していると考えられるかも伝えます。ACKフレームは1から256のACKブロックを含みます。ACKブロックはTCPのSACKブロックに似た、範囲を持つ確認応答パケットです。パケットは新しいシーケンスナンバーのナンバーで再送されるため、QUICはTCPとと同じ累積ACK点をもちません。

ACKブロックを送信者によってまだ受信していないものに限定するために、送信者は定期的に
、受信者に指定したシーケンスナンバー以下のパケットへのackを止めるようにシグナルするSTOP_WAITINGフレームを送信し、受信者側で"一番小さいackされててない"パケット番号を引き上げます。そのためACKフレームの送信者は、最小のackをしてないものと、報告されたパケット番号の間のACKブロックのみをレポートします。送信者に、STOP_WAITINGフレームの最小の値としてACKで受信される最近受信した最大のackされたパケットを送信することを推奨します。

TCPのSACKとは違ってQUICのACKブロックは取り消せません。一度パケットがackされると、もしそれが未来のACKフレームで現れなかったとして、ackされたと仮定されます。

送信者は日和見的ACK攻撃を避けるために、接続にエントロピを導入し意図的にパケット番号をスキップする事ができます。送信者はもし送ってないパケットのackがあれば、コネクションを閉じる必要があります(MUST)。ACKフレームのフォーマットは欠落しているブロックを表現するのに効率的です。1から255のスキップされたパケットシーケンスナンバーは必要に応じて効果的なエントロピーの8bitを提供します。これは、日和見的ack攻撃を防ぐのに十分でしょう。

セクションオフセット
0: ACKフレームの開始  
T: タイムスタンプセクションの開始バイトオフセット  
A: ackブロックセクションの開始バイトオフセット  
N: 最大のAckされたバイト長  
```
     0                            1  => N                     N+1 => A(aka N + 3)
+---------+-------------------------------------------------+--------+--------+
|   Type  |                   Largest Acked                 |  Largest Acked  |
|   (8)   |    (8, 16, 32, or 48 bits, determined by ll)    | Delta Time (16) |
|01nullmm |                                                 |                 |
+---------+-------------------------------------------------+--------+--------+


     A             A + 1  ==>  A + N
+--------+----------------------------------------+
| Number |             First Ack                  |
|Blocks-1|           Block Length                 |
| (opt)  |(8, 16, 32 or 48 bits, determined by mm)|
+--------+----------------------------------------+

  A + N + 1                A + N + 2  ==>  T(aka A + 2N + 1)
+------------+-------------------------------------------------+
| Gap to next|              Ack Block Length                   |
| Block (8)  |   (8, 16, 32, or 48 bits, determined by mm)     |
| (Repeats)  |       (repeats Number Ranges times)             |
+------------+-------------------------------------------------+
     T        T+1             T+2                 (Repeated Num Timestamps)
+----------+--------+---------------------+ ...  --------+------------------+
|   Num    | Delta  |     Time Since      |     | Delta  |       Time       |
|Timestamps|Largest |    Largest Acked    |     |Largest |  Since Previous  |
|   (8)    | Acked  |      (32 bits)      |     | Acked  |Timestamp(16 bits)|
+----------+--------+---------------------+     +--------+------------------+
```
ACKフレームのフィールドは以下のとおりです:
- Frame Type: フレームタイプのバイトは様々なフラグ(01nullmmB)をもつ8bit値です。
  - 最初の２つのbitはACKフレームを示す01にセットされる必要があります。
  - 'n' ビットはフレームが1つ以上のackレンジを持つか示します。
  - 'u' ビットは使用されません。
  - ふたつの'll'ビットは、観測された最大の長さを1, 2, 4, 6 バイト長としてエンコードしたフィールドです。
  - ふたつの'mm'ビットは欠落したパケットシーケンスナンバーの差分を1, 2, 4, 6 バイト長としてエンコードしたフィールドです。

- Largest Acked: 可変長の非負の値であり、ピアが観測した最大のパケット番号を示す値
- Largest Acked Delta Time: 11bitの明示的な仮数部と5bitの明示的な指数部をもつ16bitの非負のfloatであり、最大のackされたものが受信されてからこのAckフレームが送信されるまでにかかった時間をマイクロ秒で示す。ビットフォーマットはゆるく IEEE 754でモデル化されています。例えば、1マイクロ秒は0x1で表現されます。これは、高位の5bitに現れる0の指数部と、下位11bitに現れる仮数部11bitです。明示的指数部が0より大きい場合、暗黙的に高位から12番めの1であるビットは指数部として仮定されます。例えば、0x800のfload値は暗黙的に指数部1 、仮数部0を持ち、そのたかわり4096という仮数部をもちます(12bit目は1として想定される)。加えて、実際の指数部は明示的な指数より1少なく、値は4096マイクロ秒を示します。表現可能な範囲よりも大きい値は0xFFFF内に制限されます。

-  Ack Block Section:
  - Num Blocks:オプショナルな非負の8bit 値であり、ackブロックの数より1少ない値を指定します。nフラグが1の場合のみ存在します。
  - Ack block length: 可変長のパケット番号の差分。最初の欠損したパケット範囲では、ackブロックは最大のackされた値で開始します。最初ののackブロックでは、ackブロック長は1足した値です。続くackブロックでは、ackブロックの長さです。最初ではないブロックでは、0の値は並んだ256パケット以上失ったことを示します。
  - gap to next blok: 非負の8bit 値であり、ackブロックの間の値を示します。
- Timestamp Section:
  - Num Timestamp: 非負の8bit値であり、このACKフレームでのタイムスタンプ値を示します。このタイムスタンプに続き、多くの<パケット番号, タイムスタンプ>のペアがあるでしょう。
  - Delta Largest Observed: 非負の8bit値であり、最初のタイムスタンプから観測された最大値のパケット番号の差分を示します
  - First Timestamp: 非負の32bitの値であり、そのコネクションでLargest Observed マイナス Delta Largest Observedによって指定されたパケットが受信し始めた時間から、マイクロ秒で時間の差分を示します。
  - Delta Largest Observed(繰り返し): (上記と同じ)
  -Time Since Previous Timestamp(繰り返し): 非負の16bit値であり、以前のタイムスタンプからの差分を示す。Ack Delay Timeと同じフォーマットでエンコードされます。

## 10.5.  STOP_WAITING Frame
STOP_WAITING フレームは、指定された値より小さいパケット番号を持つパケットを待ち続けるべきでないとピアに通知するフレームです。パケット番号は1か2か4か6バイトでエンコードされ、同封するパケットのヘッダ(QUICフレームパケットのフラグで指定される)のパケット番号に指定されているのと同じ符号化長を使用します。 フレームは以下のとおりです。
```
        0        1        2        3         4       5       6
   +--------+--------+--------+--------+--------+-------+-------+
   |Type (8)|   Least unacked delta (8, 16, 32, or 48 bits)     |
   |        |                       (variable length)           |
   +--------+--------+--------+--------+--------+--------+------+
```
STOP_WAITINGフレームのフィールドは以下のとおりです:
- Frame Type: Frame Typeバイトは8bit値であり、、STOP_WAITINGフレームを示す0x06がセットされます。
- Least Unacked Delta: パケットヘッダのパケット番号と同じ長さである可変長のパケット番号の差分長。最小のackされてないものを決定するためにヘッダのパケット番号から引かれます。最小のackされてないものが、送信者がまだackを待っている如何なるパケットのパケット番号の中で最も小さいものになります。もし、受信者がこの値より小さいパケットを欠落した場合、受信者はこれらのパケットは回復不可能な損失と考えるべきです。

10.6.  WINDOW_UPDATE Frame
WINDOW_UPDATEフレームはピアにエンドポイントのフロー制御ウィンドウの増加を通知します。ストリームIDはゼロも可能で、それはこのWINDOW_UPDATE をコネクションレベルのフロー制御ウィンドウに適応することを示します。もしくは0以外では、指定されたストリームのフロー制御ウィンドウを増加することを示します。フレームは以下のとおりです。
```
       0         1                 4        5                 12
   +--------+--------+-- ... --+-------+--------+-- ... --+-------+
   |Type(8) |    Stream ID (32 bits)   |  Byte offset (64 bits)   |
   +--------+--------+-- ... --+-------+--------+-- ... --+-------+
```
WINDOW_UPDATEフレームのフィールドは以下のとおりです。
- Frame Type: Frame Typeのバイトは8bit値で、WINDOW_UPDATEフレームを示す0x04がセットされます。
- Stream ID: フロー制御のウィンドウを更新するストリームのID、もしくはコネクションレベルのフロー制御を指定する0です。
- Byte offest: 非負の64bit整数値であり、与えられたストリームで送信できるバイトオフセットの絶対値。コネクションレベルフロー制御の場合、現在のオープンなストリーム全てで送信できるバイトの累積値です。

バイトオフセットの絶対値が指定され、WINDOW_UPDATEフレームの受信者は指定されたストリームでそのバイト値まで送信できます。それ以上のバイトの送信によるフロー制御違反は、受信者によってコネクションがクローズされます。

指定されたストリームIDへの複数のWINDOW_UPDATEフレームの受信は、最大オフセットバイトをトラックし続けるのにのみ必要です。

ストリームとセッションの両方のウィンドウはデフォルトである16KBで始まりますが、ハンドシェイク中に増加されます。それをするため、エンドポイントはハンドシェイク中にSFCW (Stream Flow Control Window) と CFCW (Connection/Session Flow Control Window)パラメータをネゴシエーションするべきです。各タグに関連付けられた値を初期ストリームウィンドウと初期コネクションウィンドウにすべきです。

## 10.7.  BLOCKED Frame
送信者はデータを送信する用意は出来た（そして、送信すべきデータを持ってる）が、現在はフロー制御によってブロックされている時にBLOCKEDフレームを送信します。BLOCKED フレームは純粋に情報を伝えるフレームですが、デバッグ目的で極めて有用です。BLOCKED フレームの受信者は単純にこれを捨てます(有用なログメッセージを表示した後)。フレームは以下のとおりです:
```
        0        1        2        3         4
   +--------+--------+--------+--------+--------+
   |Type(8) |          Stream ID (32 bits)      |
   +--------+--------+--------+--------+--------+
```
BLOCKEDフレームのフィールドは以下のとおりです:
- Frame Type: Frame Typeバイトは8bit値であり、BLOCKED フレームを示す0x05がセットされます。
- Stream ID:32bitの非負の値であり、フロー制御でブロックされているストリームを示します。0でないストリームIDはフロー制御でブロックされているストリームを示します。もし0の時、ストリームIDのフィールドはコネクションレベルのフロー制御でブロックされていることを示します。

## 10.8.  PADDING Frame
PADDINGフレームは0x00バイトでパケットをパディングします。このフレームが出現した時、パケットの残りはパディングのバイトと仮定されます。このフレームは0x00バイトの含み、QUICパケット終わりまで続きます。PADDINGフレームはFrame Typeフィールドのみを持ち、Frame Typeフィールドは0x00がセットされます。

## 10.9.  RST_STREAM Frame
エンドポイントは突然ストリームを終了するのにRST_STREAMを使用できます。フレームは以下のとおりです:
```
     0        1            4      5              12     8             16
+-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+
|Type(8)| StreamID (32 bits) | Byte offset (64 bits)| Error code (32 bits)|
+-------+--------+-- ... ----+--------+-- ... ------+-------+-- ... ------+
```
フィールドは:

- Frame type: Frame Typeは8bit 値で、RST_STREAMフレームを示す0x01がセットされます。
- Stream ID: 削除されるストリームの32bitのストリームID
- Byte offset: 64bitの非負の整数値であり、このRST_STREAM送信者によってこのストリームで書かれるデータの終わりのバイトオフセットの絶対値
- Error code: なぜストリームがクローズされたかを示す32bitのエラーコード


## 10.10.  PING frame
エンドポイントは、彼らのピアが生きてることやピアへの到達性があることを確認するのにPINGフレームを 使用できます。PINGフレームはペイロードを含みません。PINGフレームの受信者は単純にこのフレームを含むパケットにACKする必要があります。PINGフレームはストリームがオープンした時にコネクションが生存し続けるように使用されるべきです(SHOULD)。デフォルトでは15秒の静止後にPINGフレームを送信します。PINGフレームはFrame Typeフィールドのみを持ち、8bit値のFrame Typeフィールドは0x07がセットされます。

## 10.11.  CONNECTION_CLOSE frame
エンドポイントはコネクションをクローズされることをピアに通知するのにCONNECTION_CLOSEフレームを送信します。もし明示的にクローズされていないオープンなストリームがあった場合、コネクションがクローズされた時に暗黙的にクローズされます。(理想的に、全てのストリームが終了する十分な時間の後にGOAWAYフレームが送信されます。)フレームは以下のとおりです。
```
        0        1             4        5        6       7
   +--------+--------+-- ... -----+--------+--------+--------+----- ...
   |Type(8) | Error code (32 bits)| Reason phrase   |  Reason phrase
   |        |                     | length (16 bits)|(variable length)
   +--------+--------+-- ... -----+--------+--------+--------+----- ...
```
CONNECTION_CLOSEフレームのフィールドは以下のとおりです:
- Frame Type:Frame Typeは8bit 値で、CONNECTION_CLOSEフレームを示す0x02がセットされます。
- Error Code: なぜコネクションがクローズされたかを示す32bitのエラーコード
- Reason Phrase Length: 非負の16bit値であり、Reason Phraseの長さを示します。送信者がQuicErrorCodeよりさらに詳細を与えない場合、0でも良いです。
- Reason Phrase: オプショナルな、なぜコネクションがクローズされたかの人間が読める説明。

## 10.12.  GOAWAY Frame
エンドポイントはコネクションを使用すべきでないこと、そして、将来打ち切られることをピアに通知するのにGOAWAYフレームを使用できます。エンドピントはいかなるアクティブなストリームを使用し続けますが、GOAWAYフレームの送信者はさらなるストリームを開始しませんし、新しいストリームを受理しません。フレームは以下のとおりです。
```
        0        1             4      5       6       7      8
   +--------+--------+-- ... -----+-------+-------+-------+------+
   |Type(8) | Error code (32 bits)| Last Good Stream ID (32 bits)| ->
   +--------+--------+-- ... -----+-------+-------+-------+------+

         9        10       11
   +--------+--------+--------+----- ...
   | Reason phrase   |  Reason phrase
   | length (16 bits)|(variable length)
   +--------+--------+--------+----- ...
```

- Frame Type:Frame Typeは8bit 値で、GOAWAYフレームを示す0x06がセットされます。
- Error Code: なぜコネクションがクローズされたかを示す32bitのエラーコード
- Last Good Stream ID: GOAWAYメッセージの送信者によって受理された最後のストリームID。もし全くのストリームが応答さられて無ければ、0がセットされるべきです。
- Reason Phrase Length: 非負の16bit値であり、Reason Phraseの長さを示します。送信者がQuicErrorCodeよりさらに詳細を与えない場合、0でも良いです。
- Reason Phrase: オプショナルな、なぜコネクションがクローズされたかの人間が読める説明。

# 11.  Error Codes
QuicErrorCodesへの番号へのマッピングは現在Chromium source codesrc/net/quic/quic_protocol.h.で定義されています。(TODO: ハードコードナンバーと、それらをココに追加)

- QUIC_NO_ERROR: エラーはありません。  RST_STREAM frames と CONNECTION_CLOSE framesでは有効ではありません。
- QUIC_STREAM_DATA_AFTER_TERMINATION: finかresetの後にデータフレームがあった
- QUIC_SERVER_ERROR_PROCESSING_STREAM: ストリームの処理の停止させるサーバエラーがあった
- QUIC_MULTIPLE_TERMINATION_OFFSETS: 送信者が1つのストリームに対する一致しない2つのfinやresetを受信した。
- QUIC_BAD_APPLICATION_PAYLOAD:送信者が正しくないアプリケーションデータを受信した
- QUIC_INVALID_PACKET_HEADER: 送信者が不正な形式のパケットヘッダを受信した
- QUIC_INVALID_FRAME_DATA: 送信者がフレームデータを受信した。もし可能であれば、以下に続くより詳細なエラーコードが好まれます。
- QUIC_INVALID_RST_STREAM_DATA: Stream rstデータが不正です
- QUIC_INVALID_CONNECTION_CLOSE_DATA: Connection close データが不正です
- QUIC_INVALID_ACK_DATA: Ack データが不正です
- QUIC_DECRYPTION_FAILURE: 復号エラーがありました
- QUIC_ENCRYPTION_FAILURE: 暗号化エラーがありました
- QUIC_PACKET_TOO_LARGE: パケットが最大パケットサイズを超えました
- QUIC_PACKET_FOR_NONEXISTENT_STREAM: 存在しないストリームにデータが送信されました
- QUIC_CLIENT_GOING_AWAY: クライアントがいなくなりました(ブラウザが終了するか、その他)
- QUIC_SERVER_GOING_AWAY: サーバがいなくなりました(リスタート、その他)
- QUIC_INVALID_STREAM_ID: ストリームIDが無効です
- QUIC_TOO_MANY_OPEN_STREAMS: すでに多すぎるストリームがオープンです
- QUIC_CONNECTION_TIMED_OUT: ネゴシエーションした(もしくはデフォルトの)タイムアウトがたちました
- QUIC_CRYPTO_TAGS_OUT_OF_ORDER: ハンドシェイクメッセージが順番通りでないタグを含みます
- QUIC_CRYPTO_TOO_MANY_ENTRIES: ハンドシェイクメッセージが多すぎるエントリを含みます
- QUIC_CRYPTO_INVALID_VALUE_LENGTH: ハンドシェイクメッセージが正しくない値の長さを持ちます
- QUIC_CRYPTO_MESSAGE_AFTER_HANDSHAKE_COMPLETE:暗号メッセージをハンドシェイクが完了した後に受信しました.
- QUIC_INVALID_CRYPTO_MESSAGE_TYPE: 不法のメッセージタグをもつ暗号メッセージを受信しました
- QUIC_SEQUENCE_NUMBER_LIMIT_REACHED: さらなるパケットの転送は、パケット番号の再利用を引き起こします。

# 12.  Security and Privacy Considerations
   (TODO: List considerations)

# 13.  Contributors
このプロトコルは、この文書の著者だけでなく、多くのエンジニアの作業の成果です。QUICの背景にある設計と理論的根拠は大幅にJim Roskindの作業によって描かれています[1]。このプロジェクトの貢献者はアルファベット順に、Britt Cyr, Jeremy Dorfman, Ryan Hamilton, Jana Iyengar, Fedor Kouranov, Charles Krasic, Jo Kulik, Adam Langley, Jim Roskind, Robbie Shade, Satyam Shekhar, Cherie Shi, Ian Swett, Raman Tenneti, Victor Vasiliev, Antonio Vicente, Patrik
Westin, Alyssa Wilk, Dale Worley, Fan Yang, Dan Zhang, Daniel Zieglerです。

# 14.  Acknowledgments
QUICの形成とそのデプロイメントを支援して下さった以下の方々に特別な感謝します。Chris Bentzel, Misha Efimov, Roberto Peon, Alistair Riddoch, Siddharth Vijayakrishnan, Assar Westerlund。またQUICはプライベートでの会話やproto-quic@chromium.orgメーリングリストので人々との議論や公共のものから非常に恩恵を受けました。

# 15.  References

## 15.1.  Normative References

   [RFC2119]  Bradner, S., "Key Words for use in RFCs to Indicate
              Requirement Levels", March 1997.

   [draft-thomson-quic-tls]
              Thomson, M. and R. Hamilton, "Porting QUIC to TLS", March
              2016.

   [draft-iyengar-quic-loss-recovery]
              Iyengar, J. and I. Swett, "QUIC Loss Recovery and
              Congestion Control", July 2016.

## 15.2.  Informative References

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, "Hypertext Transfer
              Protocol Version 2 (HTTP/2)", May 2015.

## 15.3.  URIs

   [1] https://goo.gl/dMVtFi

Authors' Addresses

   Ryan Hamilton
   Google

   Email: rch@google.com


   Janardhan Iyengar
   Google

   Email: jri@google.com


   Ian Swett
   Google

   Email: ianswett@google.com


   Alyssa Wilk
   Google

   Email: alyssar@google.com
