#Header Compression for HTTP/QUIC
https://tools.ietf.org/html/draft-bishop-quic-http-and-qpack-00.html

- [Abstract](#abstract)
- [1.  Introduction](#1--introduction)
- [2.  QPACK](#2--qpack)
  - [2.1.  Changes to Static and Dynamic Tables](#21--changes-to-static-and-dynamic-tables)
    - [2.1.1.  Dynamic Table State Synchronization](#211--dynamic-table-state-synchronization)
    - [2.1.2.  Changes to Maximum Table Size](#212--changes-to-maximum-table-size)
  - [2.2.  Changes to Binary Format](#22--changes-to-binary-format)
    - [2.2.1.  Literal Header Field Representation](#221--literal-header-field-representation)
    - [2.2.2.  Deletion](#222--deletion)
- [2.2.3.  The QPACK-ACK frame](#223--the-qpack-ack-frame)
- [3.  Use in HTTP/QUIC](#3--use-in-httpquic)
- [4.  Performance Considerations](#4--performance-considerations)
- [5.  Security Considerations](#5--security-considerations)

# Abstract
HTTP/2 [RFC7540]は、ヘッダ圧縮にHPACK [RFC7541]を使用します。しかしながら、HPACKが機能するためには順序のあるHTTP/2フレーミングレイヤのメッセージベースのセマンティクスに依存します。メッセージはエンコーダによって生成された順番の通りにデコーダで処理された場合に正しくデコードされます。このドラフトはHPACKを洗練しQUICで使用するために順序の要件を緩和します。

# 1.  Introduction
HPACKはHTTP/2のパフォーマンス上の利点を提供するための機能を幾つか有しています。しかし、QUICで提供されるような順番通りでない環境ではうまく機能しません。

もっとも大きな課題は、要素が流動的なインデックスによって参照されるという事実です。項目がヘッダテーブルに追加された時にインデックスが暗黙的であるだけでなく、他の項目がヘッダテーブルに追加されるため、インデックスは通知なく変更されます。静的なエントリが最初の61個を占め、その後に動的なエントリ続きます。新しく追加された動的なエントリによって古い動的なエントリはevictionされます。そして、保持される項目の番号が62から始まる番号に変更されます。つまり、先行する全てのヘッダセットを処理することなく、動的テーブルのインデックスを解釈することはできず、与えられたエントリのインデックスを予測できません。

上記の解決策は、ほぼ確実にデコンプレッサが化したメモリの制約と干渉します。エントリの自動的な削除はコンプレッサが宣言した動的テーブルサイズにもとづいて行われます。これはデコンプレッサで許可された最大値より小さくなければなりません(MUST)（そして、HTTP/2 SETTINGS値を使用して転送されます）。

以下のセクションでは、この文書では新しいHPACKバージョンを提案し、最小限のヘッドオブラインブロッキングで、異なるトレードオフを持ち、順番通りでない処理を可能にし、限られたメモリ消費を持ちます。

提案されたHPACK(強く型付けされたフィールド、common headerシンタックスのバイナリ圧縮)の改良は現在含まれておりませんが確かに可能です。

# 2.  QPACK
## 2.1.  Changes to Static and Dynamic Tables
QPACKはヘッダフィールドとインデックスの関連付けに2つのテーブルを使用します。静的テーブルは[RFC7541]から変わりません。

動的テーブルはインデックスからヘッダフィールドへのマップです。インデックスは静的テーブルの最後のインデックスより大きい任意の数値です。各挿入命令は変更されるインデックスを指定します。新しいエントリには任意のインデックスを選択できます(MAY)が、数値が小さいほど圧縮性能が向上します。

順番の入れ替わりに対する耐久性を向上するために、エンコーダは同じインデックスに対して同じ値の挿入命令を複数回送信できます(MAY)。しかし、すでに存在するインデックスに対して異なる値の挿入は致命的なエラーになります。

動的テーブルはデコーダによって指定されるサイズによって制限されます。動的テーブルに最大サイズを超えてヘッダを追加しようとすると、デコーダによってエラーとして扱われなければなりません(MUST)。エンコーダが領域を再利用できるように、エンコーダは動的テーブル内のエントリを削除できますが、削除が成功したことを確認した後でのみインデックスやその領域を再利用できます。

まだ定義されていないインデックスを参照するQPACKフレームが届く可能性があるため、それらのフレームはインデックスを定義するその他のフレームが届くまで待たなければなりません(MUST)。

### 2.1.1.  Dynamic Table State Synchronization
エントリはダイナミックテーブルからevictionされません。サイズ管理は純粋にエンコーダの責任であり、デコーダが宣言したメモリサイズを超えてはいけません(MUST NOT)。

エンコーダとデコーダの両方は、インデックスされたエントリへの参照数を維持します。この数は以下を含みます。

- フィールドへの挿入。初期もしくは冗長なインデックス化されたリテラルの両方の送信
- ヘッダ名を提供するためにインデックス化されたエントリを使用するリテラル値
- 明示的なインデックスされた値の送信

エンドポイントはインデックス化されたエントリが割り当てられた最初の時に、メモリがコミットされたものとして考えなければなりません(MUST)。エンコーダはそのフレームが到着し反映されるまで待つのではなく、他のフレームで挿入命令を繰り返すことができます(MAY)。

エンコーダが挿入された値を削除したい場合、以下の状態を遷移します：

1. *Delete requested.* エンコーダが削除する値の参照カウンタ値を含む削除命令を送信する。エンコーダは、ステートマシンが完了するまで後続のフレームでそのエントリを参照しては行けませんし、消費されたメモリの計算にそのエントリを含める必要があります。

2. *Delete pending.* デコーダが削除命令を受信し、エンコーダと自身のカウンタを比較する。もしデコーダのカウンタがエンコーダのものより小さい場合、エンコーダのカウンタを保存して他のQPACKフレームが届くまで待ちます。

3. *Delete acknowledged.* デコーダが削除される値を参照する全てのQPACKフレームを受信しおえ、指定されたエントリを削除できるようになる。デコーダは速やかにQPACK-ACKを送信すべきです(SHOULD)が、一時的にその他の保留中の削除を待つこともできます(MAY)。

4. *Delete completed.* エンコーダが削除の確認となるQPACK-ACKフレームを受信すると、もはや削除されたエントリはテーブルサイズに計上されず、そのフィールドに対して新しい値の挿入命令を送信することができます(MAY)。

デコーダは空のテーブルエントリに対する削除命令を受信できます。デコーダはこれをエラーみなしてはいけません(MUST NOT)が、定義を受信するまで待っている間でさえも通常のように削除を処理する必要があります(MUST)。

### 2.1.2.  Changes to Maximum Table Size
デコーダは異なるSETTINGS_HEADER_TABLE_SIZE値を含むSETTINGSフレームを送信することで、いつでも自身の最大テーブルサイズを変更できます(MAY)。このSETTINGSフレームは値が減少していれば確認応答を要求します(MUST)。

値の増加はSETTINGSフレームを送信すると即座に適用されます。値の減少の場合のみ、SETTINGS_ACKを受信した後に各ストリームで適応されます。どちらの方向でも新しい値は、SETTINGS_ACKフレームを送信するとすぐにエンコーダに適用されます。

最大値の減少が適用されると、動的テーブルは新しい最大値より大きくなります。これをエラーとして扱ってはいけません(MUST NOT)、しかし、現在適応可能な上限を超えて新しい値を動的テーブルに挿入は、致命的なエラーとみなさなければなりません(MUST)。それ以上に動的テーブルへ挿入を行う前に、エンコーダはテーブル上限に違反することなく挿入を実行するのに十分なエントリの削除をする必要があります(MUST)。

エンコーダはデコーダが指定した値よりも小さい最大テーブルサイズを使用する場合、HPACKのようにデコーダに通知する必要はありません。デコーダが宣言した最大値よりも小さい限り、デコーダへの通知なく、エンコーダの最大テーブルサイズはいつでも変更できます

## 2.2.  Changes to Binary Format
### 2.2.1.  Literal Header Field Representation
(このセクションは [RFC7541], Section 6.2.1 を置き換えます)

インデックス化を伴うリテラルヘッダフィールドは、デコードされたヘッダリスト変おヘッダフィールドの挿入し、それを新しいエントリとして動的テーブルに挿入することになります。


```
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 1 |    New Index (6+)     |
      +---+---+-----------------------+
      |          Name Index (8+)      |
      +---+---------------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+
```
インデックス化を伴うリテラルヘッダフィールド - インデックスされた名前


```
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 1 |    New Index (6+)     |
      +---+---+-----------------------+
      |               0               |
      +---+---+-----------------------+
      | H |     Name Length (7+)      |
      +---+---------------------------+
      |  Name String (Length octets)  |
      +---+---------------------------+
      | H |     Value Length (7+)     |
      +---+---------------------------+
      | Value String (Length octets)  |
      +-------------------------------+
```
インデックス化を伴うリテラルヘッダフィールド - 新しい名前

インクリメンタルインデックス化を伴うリテラルヘッダフィールドは'01'の2bitパターンで始まり、続いて新しい6bitプレフィックスの整数値で新しいインデックスが続きます。この値は静的テーブルのエントリー数よりも常に大きいです。

もしヘッダフィールド名が動的テーブルや静的テーブルに保存されているエントリのヘッダフィールド名と一致した場合、ヘッダフィール名はそのエントリのインデックスとして表現できます。この場合、エントリーのインデックスは8bitプレフィックス の整数値として表現されます ([RFC7231]のSection 5.1 参照)。この値は常に非ゼロです。

一方で、ヘッダフィール名は文字列リテラルとして表現されます([RFC7231]のSection 5.2 参照)。8bitインデックスの代わりに値0が使用され、その後にヘッダフィールド名が続きます。

各ヘッダフィールド名表現のあとには、文字列リテラルのヘッダフィールド値表現が続きます(Section 5.2)。

エンコーダは空でないとわかっているインデックスに値を入れようとしてはいけません(MUST NOT)。エンコーダは異なるフレームで同一の空きスロットに複数回同じ値を挿入し、順番通りでないフレーム処理によるブロックのリスクを低減できます(MAY)。しかしながら、デコーダは空いていない異なるヘッダフィールドへの挿入を致命的なエラーとして扱う必要があります(MUST)。

### 2.2.2.  Deletion
(このセクションは[RFC7541], Section 6.3を置き換えます)

```
        0   1   2   3   4   5   6   7
      +---+---+---+---+---+---+---+---+
      | 0 | 0 | 1 |   RefCount (5+)   |
      +---+---+---+---+---------------+
      |          Index (8+)           |
      +-------------------------------+
```
ヘッダフィールド削除

削除は '001' 3bitパターンで始まります、続いて削除する項目を参照する値が続きます(5bitプレフィックスの整数値で表現されます)、そして削除する項目のインデックスが続きます(8bitプレフィックスの整数値で表現されます)。

エンコーダは、デコーダが宣言したメモリ上限以下に収まるようにするためにいつでも動的ヘッダテーブルのエントリを削除できます。この命令は、指定されたエントリを参照する全ての専攻フレームが受信された後で、それらを削除する準備をすべきとデコーダに通知します。削除命令はデコーダのガーベジコレクション処理を容易にするためにそのようなフレームのカウントを含みます。


# 2.2.3.  The QPACK-ACK frame
各ピアは、削除の確認するためにコネクションのコントロールストリーム上でQPACK-ACKフレーム(0xTBD)を定期的に送信しなければなりません(MUST)。ピアは最後のフレーム以降に削除が完了したものがなければ、新しいQPACK-ACKフレームの送信を省略できます(MAY)。

QPACK-ACKフレームはフラグは定義されておらず、ビットマップから更生されます。ビットマップの最初のビットは静的テーブルの後ろの最初のインデックス(現在は62)を反映しており、連続する各ビットは次の整数値を示します。先行するQPACK-ACKフレーム以降にもしインデックスされたエントリの削除が完了していれば各ビットはセットされます(MUST)。そうでなければセットされません(MUST NOT)。

受信時に、エンコーダはどの項目が削除されたか確認するためにテーブルを使用します。この時点で、その領域はエンコーダによって復元され、エンコーダは将来の命令のために安全に再利用できます。

# 3.  Use in HTTP/QUIC
HTTP/QUIC [I-D.ietf-quic-http] は現在 HTTP/2からのHPACKエンコーダ/デコーダ保持しており、シーケンス番号を用いて順番を強制します。QPACKを使用すると以下のように変更されます

- シーケンス番号がHEADERSフレーム(Section 5.2.2)とPUSH_PROMISEフレーム(Section 5.2.6)から削除されます
- ヘッダブロックフラグメントはHPACKデータの代わりにQPACKデータから構成されます
- ヘッダブロックフラグメンの順番の要件は削除されます

HEADERSまたはPUSH_PROMISEフレームは、任意の数のQPACK命令を含むことができますが、QPACK命令は、連続するHEADERSフレーム間の境界を越えてはいけません（SHOULD NOT）。

部分的なHEADERSまたはPUSH_PROMISEフレームは到着時に処理してもよく(MAY)、結果の部分ヘッダーセットは、実装要件に従って送信またはバッファされます。

# 4.  Performance Considerations
QPACKはヘッダのデコードにおいてストリーム間のヘッドラインブロッキングを最小限に抑えるように設計されておりますが、パケットの損失または遅延がヘッダー圧縮のパフォーマンスに影響を及ぼす場合があります。

エントリ定義を含むフレームが失われたり遅延したりすると、インデックス化されたエントリへの参照がブロックされます。エンコーダは、挿入が完全であることが分かるまで動的テーブルを参照するのではなく、インデックス化リテラル命令を繰り返すことによって、圧縮効率をトレードオフし、ブロッキングを回避することを選択することができます（MAY）。

削除の完了を妨げる遅延フレームは、最大テーブルサイズが原因でエンコーダが新しいエントリを追加することを妨げることがあります。これはエンコーダがリクエスを継続するのにブロックはしませんが、圧縮のパフォーマンスを大鯖に制限する可能性があります。各エンコーダはテーブルの上限に達する前にエントリを削除したほうが良いです。デコーダはQPACK-ACKフレームを送信して、エンコーダがテーブル領域を復元できるようにすべきです(SHOULD)。

この状況はテーブルサイズを急激に縮小することでも発生することに注意して下さい。エンコーダは少なくとも1RTTの間新しいエントリを追加できないことに気づくでしょう。

デコーダは、部分的なヘッダブロックが届いた時に処理をするか選択できます(MAY)。部分的なヘッダブロックを処理できないと、ブラオック内の定義に依存する他のストリームにヘッドオブラインブロッキングが生じる可能性がありますが、それらを処理するということはおそらく符号化された状態よりも大きな出力結果をバッファリングすることを意味します。

# 5.  Security Considerations
QACKのセキュリティに関する考慮事項は、HPACKと同じであると考えられます。