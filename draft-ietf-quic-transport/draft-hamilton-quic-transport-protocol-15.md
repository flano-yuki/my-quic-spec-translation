https://tools.ietf.org/html/draft-ietf-quic-transport-15

# Abstract
この文書はQUICトランスポートプロトコルのコアを定義します。この文書ではコネクションの確立、パケットフォーマット、多重化、信頼性について説明します。付随する文書は、暗号ハンドシェイクおよびロス検出について記述します。

# 1 イントロダクション
QUICは、UDP上で動作する多重化された安全なトランスポートプロトコルです。 QUICは、複数のアプリケーションに汎用の安全なトランスポートを可能にする柔軟な機能を提供することを目指しています。

- バージョンネゴシエーション
- 低レイテンシのコネクション確立
- 暗号化され認証されるヘッダとペイロード
- ストリームの多重化
- ストリームとコネクションレベルのフロー制御
- コネクションマイグレーションとNATリバインディングからの回復

QUICはUDPを使用しており、レガシーなクライアントオペレーティングシステムやミドルボックスの変更を必要としません。QUICはすべてのヘッダを認証し、そのシグナリングを含め、やりとりするほとんどのデータを暗号化します。 これによりミドルボックスの更新に依存することなくプロトコルを進化させることができます。

この文書では、コネクションの確立、ストリームの多重、ストリームと接続レベルのフロー制御、コネクションマイグレーション、データの信頼性に関するQUICプロトコルの概念設計、ワイヤフォーマット、メカニズムなど、QUICのコアプロトコルについて説明します。

付随する文書には、QUICのロス検出と輻輳制御[QUIC-RECOVERY]と、鍵ネゴシエーションのためのTLS 1.3利用[QUIC-TLS]が記載されています。

QUICバージョン1は、[QUIC-INVARIANTS]のプロトコル不変仕様に準拠しています。

# 2. 表記と定義
この文書のキーワード "MUST"、"MUST NOT"、"REQUIRED"、"SHALL"、"SHALL NOT"、"SHOULD"、"SHOULD NOT"、"RECOMMENDED"、"MAY"、そして "OPTIONAL" はここで示されるようにすべて大文字で書かれた場合は BCP 14 [RFC2119] [RFC8174] で記述されたとおりに解釈されます。

この文書で使用されている用語の定義:

クライアント: QUICコネクションを開始するエンドポイント
サーバ: 接続にくるQUICコネクションを受け付けるエンドポイント
エンドポイント: コネクションのクライアントもしくはサーバ
ストリーム: QUICコネクション内の論理的な双方向順序付きバイトチャネル
コネクション: 1つの暗号コンテキストとその中に多重化されたストリームを持つ、2つのQUICエンドポイント間の通信
コネクションID: エンドポイントでQUICIコネクションを識別するのに使用される識別子
QUIC packet: QUICエンドポイントによって交換されるデータの最小単位

QUICは名前であり、何かの略語ではありません。

## 2.1. 表記法
パケットとフレームダイアグラムは、[RFC2360]のセクション3.1で説明されているフォーマットを使用し、以下の追加の表記を使用します。

[x] xがオプショナルであることを示す
x (A) xがA bit長であることを示す
x (A/B/C) ... XがAまたはBまたはC bit 長であることを示す
x (i) ... xがSection 7.1の可変長エンコーディングを使用することを示す
x (*) ... xが可変長であることを示す

# 3. バージョン
QUICバージョンは32bitの符号なし数を使用して識別されます。

バージョン 0x00000000 はバージョンネゴシエーションを表すのに予約されています。QUICの他のバージョンは、このバージョンとは異なるプロパティを持つことがあります。すべてのプロトコルバージョンで一貫性があることが保証されているQUICのプロパティは、[QUIC-INVARIANTS]に記載されています。

[QUIC-TLS]で記述されるように、QUICのバージョン 0x00000001 は暗号ハンドシェイクとしてTLSを使用します。

上位16bitが0のバージョン番号は、将来のIETF文書で使用するために予約されています。
0x?a?a?a?aに従うバージョンはバージョンネゴシエーションをより確かなものにするのに使用されます。つまり、すべてのオクテットの下位4ビットが1010(2進数)のバージョン番号です。クライアントまたはサーバは、これらの予約されたバージョンのいずれかのサポートを広告してもよい(MAY)。

予約されたバージョン番号はおそらく実際のプロトコルを表さないでしょう。クライアントは、サーバがバージョンネゴシエーションを開始することを期待して、これらのバージョン番号の1つを使用してもよい(MAY)。サーバはこれらのバージョンの1つのサポートを宣伝してもよく、クライアントがその値を無視することを期待します。

[[RFC editor: please remove the remainder of this section before publication.]]

この仕様(0x00000001)の最終バージョンのバージョン番号は、RFCとして公開されているプロトコルのバージョン用に予約されています。ETFドラフトを識別するために使用されるバージョン番号は、ドラフト番号を0xff000000に追加することによって作成されます。 たとえば、draft-ietf-quic-transport-13は0xff00000Dと識別されます。

実装者は、 <https://github.com/quicwg/base-drafts/wiki/QUICVersions> にあるGitHub wikiの個人実験用に使用しているQUICのバージョン番号を登録することをお勧めします。

# 4. パケットタイプとフォーマット
QUICのパケットタイプとそのフォーマットについては、後のメカニズムで参照されるものもあるため最初に説明します。

すべての数は、ネットワークバイトオーダー(ビッグエンディアン)でエンコードされ、すべてのフィールドサイズはビット単位です。 フィールドの個々のビットを議論するとき、最下位ビットはビット0と呼ばれる。フィールドの値の説明には16進表記が使用されます。

Header Formが示すように、QUICパケットはロングヘッダかショートヘッダを持ちます。ロングヘッダはバージョンネゴシエーションと1-RTT鍵の確立の前に、接続の早い段階で使用されることが期待されます。 ショートヘッダはバージョン固有のヘッダで、バージョンネゴシエーション後に使用され、1-RTT鍵が確立されます。

# 4.1. ロングヘッダ
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|   Type (7)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |DCIL(4)|SCIL(4)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0/32..144)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Length (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packet Number (8/16/32)                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Payload (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   
                  Figure 1: ロングヘッダパケットのフォーマット
```


ロングヘッダはバージョンネゴシエーションが完了する前かつ1-RTT鍵が確立するよりも前に送信されるパケットで使用されます。両方の条件が満たされると、送信者はショートヘッダ(Section 4.2)を使用したパケットの送信に切り替えます。ロング形式では、バージョンネゴシエーションパケットなどの特別なパケットをこの一様な固定長パケット形式で表現できます。 ロングヘッダを使用するパケットには、次のフィールドがあります。

- Header Form: ロングヘッダでは、0オクテット目(最初のオクテット)の上位bit(0x80)は1がセットされます。
- Long Packet Type: 0オクテット目の残りの7ビットは、パケットタイプです。 このフィールドは、128のパケットタイプの1つを示すことができます。 このバージョンで指定されたタイプは、Table 1に表記されます。
- Version: QUICバージョンは、Typeに続く32ビットのフィールドです。このフィールドは、使用されているQUICのバージョンを示し、残りのプロトコルフィールドの解釈方法を決定します。
- DCIL と SCIL: バージョンに続くオクテットには、それに続く2つの接続IDフィールドの長さが含まれています。 これらの長さは2つの4ビット符号なし数としてエンコードされます。 Destination Connection ID Length(DCIL)フィールドはオクテットの上位4ビットを占有し、Source Connection ID Length(SCIL)フィールドはオクテットの下位4ビットを占有します。 長さ0は、接続IDも0オクテット長であることを示します。非ゼロの長さは、接続IDの全長を得るために3増加され、4から18オクテットの長さを生成する。 たとえば、値0x50のオクテットは、8オクテットの宛先接続IDとゼロ長のソース接続IDを表します。
- Destination Connection ID: Destination Connection IDフィールドは、接続IDの長さに続き、長さが0オクテットまたは4オクテットから18オクテットのいずれかです。 Section 4.10では、このフィールドの使い方をより詳しく説明します。
- Source Connection ID: Source Connection IDフィールドは、Destination Connection IDの後に続き、長さが0オクテットまたは4オクテットから18オクテットのいずれかです。 Section 4.10では、このフィールドの使い方をより詳しく説明します。
- Length: パケットの残りのオクテット長(つまり、Packet NumberとPayloadフィールド)。可変長整数としてエンコードされる(Section 7.1)。
- Packet Number:パケット番号フィールドは1また2または4オクテット長です。[QUIC-TLS]のSection 5.3で説明されているように、 パケット番号にはパケット保護とは別の気密保護があります。 パケット番号フィールドの長さは、平文パケット番号で符号化される。 詳細はSection 4.11を参照。
- Payload: このパケットのペイロード

パケットタイプは下記の通り定義されます:
```
                 +------+-----------------+-------------+
                 | Type | Name            | Section     |
                 +------+-----------------+-------------+
                 | 0x7F | Initial         | Section 4.6 |
                 |      |                 |             |
                 | 0x7E | Retry           | Section 4.4 |
                 |      |                 |             |
                 | 0x7D | Handshake       | Section 4.7 |
                 |      |                 |             |
                 | 0x7C | 0-RTT Protected | Section 4.8 |
                 +------+-----------------+-------------+`
                 
                   Table 1: ロングヘッダパケットのタイプ
```

ヘッダの形式、タイプ、コネクションIDのオクテット長さ、送信先と送信元のコネクションID、および長ロングヘッダパケットのバージョンフィールドは、バージョンに依存しません。 Table 1に定義されているパケットタイプのパケット番号と値は、バージョン固有です。異なるバージョンのQUICからのパケットがどのように解釈されるかの詳細については、[QUIC-INVARIANTS]を参照してください。

フィールドとペイロードの解釈は、バージョンとパケットタイプに固有です。 このバージョンのタイプ固有のセマンティクスについては次のセクションで説明します。

パケットの終わりは長さフィールドによって決まります。 Lengthフィールドは、Packet NumberフィールドとPayloadフィールドの両方をカバーします。どちらも機密保護されており、最初は不明な長さです。 、パケット番号の保護が解除されるとペイロードフィールドのサイズがわかります。

送信者は、複数のパケットを1つのUDPデータグラムに合体させることがあります。 詳細は、Section 4.9を参照。

# 4.2. ショートヘッダ

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |0|K|1|1|0|R R R|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                Destination Connection ID (0..144)           ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Packet Number (8/16/32)                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Protected Payload (*)                   ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

              Figure 2: ショートヘッダパケットのフォーマット
```

ショートヘッダは、バージョンと1-RTTキーがネゴシエーションされた後に使用できます。ショートヘッダが使用するパケットには、次のフィールドがあります:

- Header Form: ショートヘッダでは、0オクテット目(最初のオクテット)の上位bit(0x80)は0がセットされます。
- Key Phase Bit: 0オクテット目の次のbit(0x4)は鍵フェーズを示します。これは、パケットの受信者がパケットを保護するために使用されるパケット保護キーを識別できるようにします。 詳細は[QUIC-TLS]を参照。

 [[Editor's Note: this section should be removed and the bit definitions changed before this draft goes to the IESG.]]

- Third Bit: 0オクテットの3bit目(0x20)は1にセットされます。

 [[Editor's Note: this section should be removed and the bit definitions changed before this draft goes to the IESG.]]

- Fourth Bit: 0オクテットの4bit目(0x10)は1にセットされます。

 [[Editor's Note: this section should be removed and the bit definitions changed before this draft goes to the IESG.]]

- Google QUIC Demultiplexing Bit:0オクテットの5bit目(0x8)は0に設定されます。これにより、Google QUICの実装はショートヘッダとGoogle QUICパケットを区別できるようになります。なぜなら、Google QUICサーバはコネクションIDが常に存在することを想定するためです。Google QUICの新しいヘッダフォーマットへの移行が終了したら、このビットの特別な解釈をこの仕様から削除すべきです(SHOULD)。
- Reserved:　0オクテット目の6bit目、7bit目、8bit目は実験のために予約されています。これらのbitを使用する実験に携わらないエンドポイントはパケットのこれらのbitを無視しなければなりません(MUST)。これらのbitを積極的に使用していないエンドポイントは、特定の値に関する望ましくない推測から保護するために、送信するパケットに値をランダムに設定するべきです(SHOULD)。
- Destination Connection ID:Destination Connection ID はパケットの想定される受診者によって選択されるコネクションIDです。詳細はSection 6.1を参照。
- Packet Number: パケット番号フィールドは1また2また4オクテット長です。パケット番号はパケット番号には、[QUIC-TLS]のSection 5.3で説明されているように、パケット保護とは別の機密保護があります。 パケット番号フィールドの長さは、平文パケットの番号でエンコードされる。 詳細はSection 4.11を参照。
- Protected Payload:ショートヘッダを持つパケットには常に1-RTT鍵で保護されたペイロードが含まれます。

ショートヘッダパケットのヘッダ形式とコネクションIDフィールドは、バージョンに依存しません。 残りのフィールドは、選択したQUICバージョンに固有です。 異なるバージョンのQUICからのパケットがどのように解釈されるかの詳細については、[QUIC-INVARIANTS]を参照してください。

## 4.3. Version Negotiation Packet
Version Negotiationパケットは本質的にバージョン固有ではなく、ロングパケットヘッダを使用しません(Section4.1を参照。ロングヘッダを使用するパケットのようですが、クライアントによって受信されると、Version Negotiationパケットはバージョンフィールドが0であることによって識別されます。

Version Negotiationパケットは、サーバがサポートしていないバージョンを含むクライアントパケットへの応答であり、サーバによってのみ送信されます。

Version Negotiationパケットのレイアウトは次のとおりです: 

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|  Unused (7) |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Version (32)                         |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |DCIL(4)|SCIL(4)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0/32..144)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Supported Version 1 (32)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   [Supported Version 2 (32)]                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   [Supported Version N (32)]                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 3: Version Negotiation Packet
```

未使用フィールドの値は、サーバによってランダムに選択されます。

Version Negotiationパケットのバージョンフィールドは0x00000000に設定しなければなりません(MUST)。

サーバは、受信したパケットのSource Connection IDフィールドの値をDestination Connection IDフィールドに含める必要があります(MUST)。Source Connection IDの値は、受信したパケットのDestination Connection IDからコピーしなければなりません(MUST)。これは、クライアントによって最初にランダムに選択されます。 両方の接続IDをエコーすることで、サーバがパケットを受信したことと、Version Negotiationパケットが通信経路外の攻撃者によって生成されなかったことをクライアントに保証します。

Version Negotiationパケットの残りの部分は、サーバがサポートする32ビットバージョンのリストです。

Version Negotiationパケットは、クライアントがACKフレーム内で明示的にAckすることはできません。 別のInitialパケットを受信すると、暗黙的にVersion NegotiationパケットがAckされます。

Version Negotiationパケットには、ロングヘッダ形式を使用する他のパケットに存在するパケットPacket NumberフィールドとLengthフィールドは含まれません。 したがって、Version NegotiationパケットはUDPデータグラム全体を使用します。

バージョンネゴシエーションプロセスについては、Section 6.3を参照。

## 4.4. Retry Packet
Retryパケットは、0x7Eのタイプ値を持つロングパケットヘッダを使用します。これは、サーバによって作成されたアドレス検証トークンを送信します。このトークンは、ステートレスリトライを実行するサーバによって使用されます(Section 6.7参照)。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |1|    0x7e     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |DCIL(4)|SCIL(4)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0/32..144)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |    ODCIL(8)   |      Original Destination Connection ID (*)   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Retry Token (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                          Figure 4: Retry Packet
```

Retryパケット(Figure 4)は、[QUIC-INVARIANTS]のロングパケットヘッダの不変構造を使用します。つまり、SourceおよびDestination Connection IDフィールドまでのフィールドです。 Retryパケットには保護されたフィールドが含まれていません。Version Negotiationのように、RetryパケットにはコネクションIDを含むロングヘッダが含まれますが、Length、Packet Number、およびPayloadフィールドは省略されます。 これらは次のものにフィードとなります:

- ODCIL:Original Destination Connection IDフィールドの長さ。長さは、DCILおよびSCILフィールドと同じエンコーディングを使用して、オクテットの最下位4ビットにエンコードされます。 このオクテットの上位4ビットは予約されています。 これらのビットの使用がネゴシエートされていない限り、エンドポイントはランダムな値を送信すべきであり(SHOUD)、受信したいかなる値も無視しなければならない(MUST)。
- Original Destination Connection ID: Original Destination Connection IDには、この再試行が応答しているInitialパケットからの宛先接続IDの値が含まれています。 このフィールドの長さはODCILで与えられます。
- Retry Token: サーバがクライアントのアドレスを検証するために使用するトークン。

クライアントがInitialパケットのSource Connection IDに入れたコネクションIDをサーバはDestination Connection IDに設定します。

サーバは、Source Connection IDフィールドに選択したコネクションIDを含めます。この値は、クライアントが送信したパケットのDestination Connection IDフィールドと同じであってはならない(MUST)。 クライアントは、それが送信する後続パケットの宛先Destination Connection IDにこのコネクションIDを使用しなければならない(MUST)。

サーバは、Initialおよび0-RTTパケットへの応答としてRetryパケットを送信してもよい(MAY)。 サーバは、受信した0-RTTパケットを破棄またはバッファできます。Initialまたは0-RTTパケットを受信すると、サーバは複数のRetryパケットを送信できます。

クライアントは、接続試行ごとに最大1つのRetryパケットを受け入れて処理しなければならない(MUST)。 クライアントはサーバからInitialパケットまたはRetryパケットを受信して処理した後、後続の受信したRetryパケットは破棄しなければならない(MUST)。

クライアントは、送信したInitialパケットのDestination Connection IDと一致しないOriginal Destination Connection IDフィールドを含むRetryパケットを破棄しなければならない(MUST)。 これにより、通信経路外の攻撃者がRetryパケットを注入することを防ぎます。

クライアントは、接続確立を継続するために、提供されたRetry Tokenを含むInitialパケットでRetryパケットに応答します。

クライアントは、このInitialパケットのDestination Connection IDフィールドをRetryパケットのSource Connection IDの値に設定します。Destination Connection IDを変更すると、Initialパケットを保護するために使用される鍵も変更されます。 Tokenフィールドは、Retryパケットで提供されるトークンに設定されます。 サーバはコネクションIDをトークン検証ロジックの一部に含めることができるため、クライアントはSource Connection IDを変更してはいけません(4.6.2Section 4.6.2を参照)。

クライアントからの後続のすべてのInitialパケットは、RetryパケットのコネクションIDとトークン値を使用しなければならない(MUST)。 これとは別に、クライアントによって送信されたInitialパケットには、最初のInitialパケットと同じ制限が適用されます。 クライアントは、暗号ハンドシェイクメッセージを再利用するか、またはその裁量で新しいものを構築することができます。

クライアントは、サーバが提供するコネクションIDに0-RTTパケットを送信してRetryパケットを受信した後、0-RTTを試みることができます(MAY)。 新しい暗号ハンドシェイクメッセージを構築せずに追加の0-RTTパケットを送信するクライアントは、Retryパケットの後にパケット番号を0にリセットしてはならない(MUST NOT)。

サーバは、original_connection_idトランスポートパラメータ(Section 6.6.1を参照)を使用して、接続にRetryパケットの使用を確認します。 サーバがRetryパケットを送信する場合、RetryパケットのOriginal Destination Connection IDフィールドの値(つまり、クライアントの最初のInitialパケットのDestination Connection IDフィールド)をトランスポートパラメータに含める必要があります(MUST)。

クライアントがRetryパケットを受信して処理した場合、クライアントはoriginal_connection_idトランスポートパラメータが存在し、正しいことを検証します。 それ以外の場合は、トランスポートパラメータが存在しないことを検証します。 クライアントは、検証の失敗をRANSPORT_PARAMETER_ERRORタイプの接続エラーとして扱わなければならない(MUST)。

Retryパケットにはパケット番号は含まれておらず、クライアントによって明示的にAckはできません。

## 4.5. Cryptographic Handshake Packets

バージョンネゴシエーションが完了すると、暗号鍵を合意するために暗号ハンドシェイクが行われます。 暗号ハンドシェイクは、Initial(Section 4.6)とHandshake (Section 4.7)パケットで行われます。

これらのパケットはすべてロングヘッダを使用し、バージョンフィールドに現在のQUICバージョンを含んでいます。

バージョン未対応のミドルボックスによる改ざんを防止するために、Initialパケットは[QUIC-TLS]で説明されているように、接続キーとバージョン固有のキー(初期鍵)で保護されています。 この保護は、経路上の攻撃者に対して機密性または完全性を提供するものではなく、通信経路外の攻撃者に対してある程度の保護を提供します。


## Initial Packet

Initialパケットは、0x7Fのタイプ値を持つロングヘッダを使用します。Initialパケットはクライアントとサーバが鍵交換を実行するために送信される最初のCRYPTOフレームを伝送し、いずれの方向にもACKを伝送します。 初期パケットは [QUIC-TLS]で説明されているように、初期鍵によって保護されています。

Initialパケット(Figure 5)には、Lengthフィールドの前にロングヘッダに追加される2つの追加ヘッダフィールドがあります。

```
   +-+-+-+-+-+-+-+-+
   |1|    0x7f     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Version (32)                          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |DCIL(4)|SCIL(4)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |               Destination Connection ID (0/32..144)         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                 Source Connection ID (0/32..144)            ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Token Length (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Token (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                           Length (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Packet Number (8/16/32)                   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Payload (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                         Figure 5: Initial Packet
```

これらのフィールドには、RetryパケットまたはNEW_TOKENフレームで以前に提供されたトークンが含まれます:

- Token Length: Tokenフィールドの長さをバイト単位で指定する可変長整数。 トークンが存在しない場合、この値は0です。 サーバが送信した最初のパケットは、Token Lengthフィールドをゼロに設定しなければならない(MUST)。 0以外のToken Lengthフィールドを持つInitialパケットを受信したクライアントは、パケットを廃棄するか、またはPROTOCOL_VIOLATIONタイプのコネクションエラーとしなければならない(MUST)。
- Token:  トークンの値。

クライアントとサーバは、最初の暗号ハンドシェイクメッセージを含むパケットにInitialパケットタイプを使用します。 これには、バージョンネゴシエーション(Section 4.3)またはRetry パケット(Section 4.4)を受信した後に送信されるパケットなど、初期暗号メッセージを含む新しいパケットを作成する必要があるすべてのケースが含まれます。

サーバは、クライアントInitialへの応答として最初のInitialパケットを送信します。 サーバは複数の初期パケットを送信することがあります。 暗号鍵交換では、このデータの複数回のラウンドトリップまたは再送を必要とする可能性があります。

Initial パケットのペイロードは、暗号ハンドシェイクメッセージを含むCRYPTOフレーム(1つ以上)、ACKフレーム、またはその両方を含みます。PADDINGフレームとCONNECTION_CLOSEフレームも使用できます。 他のフレームを含むInitialパケットを受信したエンドポイントは、そのパケットを擬似的に破棄したり、コネクションエラーとして扱います。

クライアントから送信された最初のパケットには、常に最初の暗号ハンドシェイクメッセージの全体を含むCRYPTOフレームが含まれています。このパケットと暗号ハンドシェイクメッセージは、単一のUDPデータグラムに収まる必要があります(Section 6.4参照)。 送信される最初のCRYPTOフレームは常にオフセット0で始まります(Section 6.4参照)。

サーバがHelloRetryRequestを送信する場合、クライアントは2回目のInitialパケットを送信します。 このInitialパケットは暗号ハンドシェイクを継続し、最初のInitialパケットで送信されたCRYPTOフレームのサイズと一致するオフセットを持つCRYPTOフレームを含みます。 最初のものに続く暗号ハンドシェイクメッセージは、単一のUDPデータグラムに収まる必要はありません。

### 4.6.1. Connection IDs
以前にRetryパケットをサーバから受け取っていないクライアントによってInitialパケットが送信された際、Destination Connection IDフィールドに予測不可能な値が設定されます。これは最低でも8オクテットの長さでなければなりません(MUST)。 サーバからパケットが受信するまで、クライアントは接続試行を中止して新しい接続を開始しない限り、同じ値を使用しなければならなりません(MUST)。 最初のDestination Connection IDは、Initialパケットのパケット保護鍵を決定するために使用されます。

クライアントは、Source Connection IDフィールドに値を設定し、SCILフィールドを一致するように設定します。

サーバのInitialパケットのDestination Connection IDフィールドは、パケットの受信者(すなわち、クライアント)によって選択されるコネクションIDです。 Source Connection IDには、パケットの送信者が使用するコネクションIDが含まれます(Section 6.1を参照)。 サーバはハンドシェイク中に一貫したSource Connection IDを使用しなければならない(MUST)。

最初にサーバからInitialパケットまたはRetryパケットを受信すると、クライアントはサーバによって提供されたSource Connection IDを後続パケットのDestination Connection IDとして使用します。 これは、クライアントが接続確立時にDestination Connection IDを2回変更する可能性があることを意味します。 一度クライアントがサーバからInitialパケットを受信すると、クライアントは異なるSource Connection IDのパケットを受信しても破棄しなければならない(MUST)。

### 4.6.2.  Tokens
以前のコネクションにおいてクライアントがNEW_TOKENフレームで受信したトークンを持っており、そのサーバと同じだと想定されるサーバに対しては、InitialパケットのTokenフィールドにその値を含めることができます。

トークンを使用すると、サーバは接続間のアクティビティーを関連付けることが出来ます。具体的には、トークンが発行された接続、およびそれが使用されている接続です。 サーバとのIDの連続性をなくしたいクライアントは、NEW_TOKENフレームを使用して提供されたトークンを破棄してもよい(MAY)。 Retryパケットで得られたトークンは破棄してはならない(MUST NOT)。

クライアントはトークンを再利用すべきではありません(SHOULD NOT)。 トークンを再利用すると、ネットワーク経路上のエンティティによって接続が紐付けられます(Section 6.11.5を参照)。 クライアントは、トークンが最後に使用されてからネットワークアタッチメントポイントが変更されたと考えられる場合、トークンを再使用してはならない(MUST NOT) つまり、ローカルIPアドレスまたはネットワークインターフェイスに変更がある場合です。クライアントはトークンが最後に使用されてからネットワーク接続が変更された場合、トークンを再利用してはいけません (MUST NOT)。これは、ローカルIPアドレスネットワークインターフェースなどが変更した場合です。クライアントはハンドシェイクが完了する前に接続を変える場合は、接続処理をする必要があります。

サーバがアドレス検証トークンを持つInitialパケットを受信したとき、それを検証すべきです(SHOULD)。 トークンが無効である場合、サーバは、Retry送信することを含め、クライアントが検証されたアドレスを持っていないかのように処理しなければなりません(SHOULD)。 検証が成功した場合、サーバはハンドシェイクを続行すべきである(SHOULD)(Section 6.7参照)。

Note: パケットを破棄するのではなく、クライアントを未検証として扱う理由は、クライアントが以前の接続においてNEW_TOKENフレームでトークンを受け取っている可能性があります。サーバが状態を失った場合トークンをまったく検証できず、パケットが破棄すると接続は失敗してしまいます。

サーバは、NEW_TOKENフレームとRetryパケットで提供されるトークンを異なる風にエンコードし、後者をより厳密に検証してもよい(MAY)。

ステートレスな設計では、サーバは暗号化認証されたトークンを使用してクライアントに情報を渡します。トークンは、サーバが回復しクライアントアドレスの検証に使用することができます。トークンは暗号ハンドシェイクに統合されていないため、認証されません。たとえば、クライアントがトークンを再利用できる可能性があります。 これによる悪用する攻撃を回避するために、サーバはトークンの使用をクライアントアドレスの検証に必要な情報のみに制限できます。

### 4.6.3.  Starting Packet Numbers
いずれかのエンドポイントによって送信された最初のInitialパケットは、パケット番号0が含まれます。その後、パケット番号は単調に増加しなければなりません。 Initialパケットは、他のパケットとは異なるパケット番号空間にあります(Section 4.11参照)。


### 4.6.4.  0-RTT Packet Numbers
0-RTT保護パケットのパケット番号は、1-RTT保護パケットと同じスペースを使用します。

クライアントがRetryまたはVersion Negotiationパケットを受信した後に、0-RTTパケットはサーバによって破棄されたり失われる可能性があります。 クライアントは新しいInitialパケットを送信した後、0-RTTパケットでデータを再送できます(MAY)

クライアントは、0-RTTパケットに使用するパケット番号をリセットしてはいけません(MUST NOT)。クライアントが暗号ハンドシェイクメッセージを再生成しない限り、RetryまたはVersion Negotiationパケットに応答した結果に関わらず、0-RTTパケットを保護するために使用される鍵は変化しません。 この場合、同じパケット番号を持つパケットを送信すると、同じ鍵とノンスを使用して異なるコンテンツを保護できるため、すべての0-RTTパケットのパケット保護が危険にさらされる可能性があります。

RetryまたはVersion Negotiationパケット、特に後続のパケットに使用されるコネクションIDを変更するRetryを受信すると、0-RTTパケットが失われる可能性を示します。ハンドシェイクが完了すると、クライアントは0-RTTパケットへのAckのみを受信します。したがって、サーバは、0-RTTパケットが0のパケット番号で開始することを期待している可能性があります。そのため、0-RTTパケットのパケット番号の符号化長を決定する際に、クライアントは現在のパケット番号までのすべてのパケットのパケット番号0から送信中であると想定しなければならない(MUST)。したがって、0-RTTパケットは、 長いパケット番号のエンコーディングを使用します。クライアントは新しい暗号ハンドシェイクメッセージを生成し、0からパケット番号を開始すべきです(SHOULD)。これは、新しい0-RTTパケットが鍵とノンスの再利用のリスクを避けて、同じ鍵を使用しないことを保証します。 これにより、以前のハンドシェイク試行からの0-RTTパケットが接続の一部として受け入れられることも防止されます。

### 4.6.5.  Minimum Packet Size
Initialパケットを運ぶUDPデータグラムのペイロードは、PADDINGフレームをInitialパケットに追加することによって、またはさらにInitialパケットを0-RTTパケット(Section 4.9参照)と組み合わせることによって、少なくとも1200オクテット(Section 8参照)に拡張しなければなりません(MUST)。)

## 4.7.  Handshake Packet
Handshakeパケットは、タイプ値が0x7Dのロングヘッダを使用します。 サーバとクライアントからのAckと暗号ハンドシェイクメッセージを送信するために使用されます。サーバは、Retryパケットを送信しない場合、Initialパケットに応答して1つまたは複数のHandshakeパケットで暗号ハンドシェイクを送信します。 クライアントがサーバからHandshakeパケットを受信すると、Handshakeパケットを使用して、その後の暗号ハンドシェイクメッセージとAckがサーバに送信されます。

HandshakeパケットのDestination Connection IDフィールドには、パケットの受信者が選択したコネクションIDが含まれています。 Source Connection IDには、パケットの送信者が使用したいコネクションIDが含まれます(Section 4.10参照)。

サーバによって送信された最初のHandshakeパケットはパケット番号0です。Handshakeパケットは独自のパケット番号空間です。 パケット番号は通常他のハンドシェイクパケットに対してインクリメントされます。

サーバは、クライアントのアドレスを確認する前に受信したバイト数の3倍以上のバイト数を送信してはならない(MUST NOT)。送信元アドレスは、アドレス検証トークン(RetryパケットまたはNEW_TOKENフレームで送信される)を介して検証することも、ハンドシェイク鍵を使用して暗号化されたクライアントからのメッセージを処理することによって検証することもできます。 この制限は、増幅攻撃を緩和するために存在します。

ハンドシェイクデッドロックを引き起こすこの制限を防ぐために、クライアントは[QUIC-RECOVERY]で説明されているように、ハンドシェイクタイムアウト時に常にパケットを送信すべきです(SHOULD)。 クライアントが再送するデータを持たず、ハンドシェイク鍵を持たない場合、少なくとも1200オクテットのUDPデータグラムでInitialパケットを送信すべきです(SHOULD)。 クライアントがハンドシェイク鍵を持っているならば、それはハンドシェイクパケットを送るべきです(SHOULD)。

このパケットのペイロードにはCRYPTOフレームが含まれ、PADDINGまたはACKフレームを含むことができます。 Handshakeパケットには、CONNECTION_CLOSEまたはAPPLICATION_CLOSEフレームが含まれることがあります。 エンドポイントは、その他のフレームをもつHandshakeパケットの受信を接続エラーとして扱わなければなりません(MUST)。

## 4.8.  Protected Packets

すべてのQUICパケットはパケット保護を使用します。 静的なハンドシェイク鍵または0-RTT鍵で保護されているパケットは、ロングヘッダで送信されます。 1-RTT鍵で保護されたすべてのパケットはショートヘッダで送信されます。 異なるパケットタイプは、暗号化レベル、つまりパケット保護を解除するために使用される鍵を明示的に示します。 0-RTTと1-RTTで保護されたパケットは、単一のパケット番号空間を共有します。

ハンドシェイク鍵で保護されたパケットは、パケットの送信者がネットワークパス上にあることを確実にするためにパケット保護のみを使用します。 このパケット保護は有効な機密保護ではありません。 クライアントからInitialパケットを受信したエンティティは、パケット保護を解除するか、または正常に認証されるパケットを生成するために必要な鍵を回復できます。

0-RTT鍵および1-RTT鍵で保護されたパケットは機密性とデータ発信元の真正性が期待されます。 暗号ハンドシェイクは、通信するエンドポイントだけが対応する鍵を受信することを保証します。

0-RTT鍵で保護されたパケットは、0x7Cのタイプ値を使用します。 0-RTTパケットのコネクションIDフィールドは、Initialパケット(Section 4.6)で使用される値と一致しなければならない(MUST)。

保護されたパケットのバージョンフィールドは、現在のQUICバージョンです。

パケット番号フィールドはパケット番号を含みます、それは、パケット保護が適用された後に適用される追加の機密保護機能を持ちます(詳細については[QUIC-TLS]を参照)。 基本となるパケット番号は送信されるパケットごとに増加します。詳細は Section 4.11を参照。

ペイロードは、認証された暗号化を使用して保護されています。 [QUIC-TLS]は、パケット保護について詳しく説明しています。 復号後、平文はSection 5で説明されているように一連のフレームからなります。

# 4.9.  Coalescing Packets

送信者は複数のQUICパケット(通常はCryptographic HandshakeパケットとProtectedパケット)を1つのUDPデータグラムにまとめることができます。 これにより、ハンドシェイク中および直後にアプリケーションデータを送信するために必要なUDPデータグラムの数を減らすことができます。 送信者がパケットを結合させる必要はありませんが、そうしないと、ハンドシェイク中に非常に多くのデータグラムを送信する必要があります。 受信者は結合パケットを処理できなければならない(MUST)。

暗号化レベルを順番にあげる(初期、0-RTT、ハンドシェイク、1-RTT)パケットをまとめると、受信者はすべてのパケットを1回の処理で処理できる可能性が高くなります。 ショートヘッダを持つパケットには長さが含まれないため、常にUDPデータグラムに含まれる最後のパケットになります。

送信者は異なるDestination Connection IDを持つQUICパケットを単一のUDPデータグラムに結合してはならない(MUST NOT)。 受診者は、データグラムの最初のパケットとは異なるDestination Connection IDを持つ後続のパケットを無視すべきです(SHOULD)。

一つのUDPデータグラムにまとめられた全てのQUICパケットはそれぞれ分かれており、完全なものです。パケットヘッダ内のいくつかのフィールドの値は冗長かもしれませんが、フィールドは省略されません。結合したQUICパケットの受信側は、それぞれのQUICパケットを個別に処理し、別々のUDPデータグラムのペイロードとして受信したかのように個別にACKしなければならない(MUST)。

データグラム中の1つまたは複数のパケットがまだ処理できない場合(キーがまだ利用できない)、または処理が失敗した場合(復号化失敗、不明なタイプなど)、受信者は残りのパケットを処理しようとしなければならなりません(MUST)。 スキップされたパケットは、パケットが別々のデータグラムで順番通りではなく受信されたかのように、後の処理で破棄されるか、またはバッファできます(MAY)。

Retry (Section 4.4)と Version Negotiation (Section 4.3) パケットは結合できません。

## 4.10.  Connection ID Encoding
コネクションIDは、Section 6.1で説明されているように、パケットの一貫したルーティングを保証するために使用されます。 ロングヘッダには、2つのコネクションIDが含まれます。Destination Connection IDは、パケットの受信者によって選択され、一貫したルーティングを提供するために使用されます。 Source Connection IDは、ピアによって使用されるDestination Connection IDを設定するために使用されます。

ハンドシェイク中、ロングヘッダを持つパケットを使用して、各エンドポイントが使用するコネクションIDを確立します。 各エンドポイントは、Source Connection IDフィールドを使用して、送信されるパケットのDestination Connection IDフィールドで使用されるコネクションIDを指定します。 パケットを受信すると、各エンドポイントは送信するDestination Connection IDを設定し、受信したSource Connection IDの値と一致させます。

ハンドシェイク中、クライアントはRetryパケットとInitialパケットの両方を受信する可能性があるため、送信するDestination Connection IDを更新する機会が2回あります。クライアントは、サーバから受信する各タイプの最初のパケット(RetryまたはInitial)に応答して、Destination Connection IDで送信する値を変更するだけで済みます。 サーバはInitialパケットに基づいてその値を設定しなければならない(MUST)。追加の変更は許可されていません。 これらのタイプの後続パケットに異なるSource Connection IDが含まれている場合、それらは破棄されなければならない(MUST)。これにより、異なるコネクションIDを生成する複数のInitial パケットのステートレスな処理によって発生する可能性のある問題を回避します。

ショートヘッダには、Destination Connection IDのみが含まれ、明示的な長さは省略されます。 Destination Connection IDフィールドの長さは、エンドポイントが知っていることが期待されます。

コネクションIDベースのロードバランサを使用するエンドポイントは、固定長もしくは最小長、コネクションIDのエンコードについてロードバランサと合意することができます。 この固定部分は明示的な長さをエンコードすることができます。これにより、connection ID全体の長さが変化することが出来、またロードバランサによって引き続き使用することもできます。

クライアントから送信された最初のパケットには、Destination Connection IDのランダムな値が含まれています。 その接続で送信されるすべての0-RTTパケットに同じ値を使用しなければならない(Section 4.8)。 このランダムな値は、Initialパケットのパケット保護鍵を決定するために使用されます([QUIC-TLS]のSection 5.2を参照)。

コネクションIDは接続の存続期間中において変更することが出来ます、特にコネクションマイグレーション(Section 6.11)に応じてです。NEW_CONNECTION_IDフレーム(7.13節)は、新しい接続ID値を提供するために使用されます。NEW_CONNECTION_IDフレーム(Section 7.13)は、新しいコネクションID値を提供するために使用されます。

## 4.11.  Packet Numbers
パケット番号は、0から2^62-1の範囲の整数です。 この値は、パケット保護のための暗号ノンスの決定に使用されます。各エンドポイントは、送受信のために別々のパケット番号を保持します。

QUICでは、パケット番号は3つのスペースに分割されます:

- 初期スペース：すべてのInitialパケット(Section 4.6)はこのスペースです。
- ハンドシェイクスペース：すべてのHandshakeパケット(Section 4.7)がこのスペースです。
- アプリケーションデータスペース：すべての0-RTTおよび1-RTT暗号化パケット(Section 4.8)がこのスペースです。

[QUIC-TLS]で説明されるように、各パケットタイプは異なる保護鍵を使用します。

概念的には、パケット番号空間は、パケットを処理してAckされるコンテキストです。 Initialパケットは、初期パケット保護鍵でのみ送信され、InitialパケットであるパケットでAckされます。 同様に、Handshakeパケットはハンドシェイク暗号化レベルで送信され、HandshakeパケットでのみAckできます。

これにより、異なるパケットシーケンス番号空間で送信されたデータ間の暗号分離が強制されます。 各パケット番号空間は、パケット番号0で始まります。同じパケット番号空間で送信された後続のパケットは、パケット番号を少なくとも1つ増やさなければなりません。

同じパケット番号空間に0-RTTと1-RTTデータが存在し、2つのパケットタイプ間で損失回復アルゴリズムを実装しやすくします。

QUICエンドポイントは、1つのコネクション(つまり、同じ暗号化鍵の下)で同じパケット番号空間内のパケット番号を再使用してはならない(MUST NOT)。 送信のためのパケット番号が2^62-1に達するなら、送付者はCONNECTION_CLOSEフレームかそれ以上のパケットを送らないで接続を閉じなければなりません(MUST )。 エンドポイントは受信する更なるパケットに応答してStateless Reset(Section 6.13.4)を送信してもよい(MAY)。

QUICのロングヘッダとショートパケットヘッダでは、パケット番号を表すために必要なビット数は、パケット番号の最下位ビットの可変数だけを含めることによって削減されます。 最初のオクテットの最上位ビットの1つまたは2つは、Table 2に示すように、パケット番号の何ビットが提供されるかを決定します。

```
          +---------------------+----------------+--------------+
          | First octet pattern | Encoded Length | Bits Present |
          +---------------------+----------------+--------------+
          | 0b0xxxxxxx          | 1 octet        | 7            |
          |                     |                |              |
          | 0b10xxxxxx          | 2              | 14           |
          |                     |                |              |
          | 0b11xxxxxx          | 4              | 30           |
          +---------------------+----------------+--------------+
            Table 2: Packet Number Encodings for Packet Headers
```

これらのエンコーディングはSection 7.1のエンコーディングと似ていますが、異なる値を使用することに注意してください。

エンコードされたパケット番号は[QUIC-TLS]Section 5.3で説明されるように保護されています。 完全なパケット番号をリカバリする前に、パケット番号の保護が解除されます。 存在する有効ビットの数、それらのビットの値、および正しく認証されたパケット上で受信された最大パケット数に基づいて、受信側で完全なパケット番号が再構成されます。 パケット保護を正常に解除するには、完全なパケット番号を得る必要があります。

パケット番号保護が解除されると、パケット番号は次に予想されるパケットに最も近いパケット番号値を見つけることによって解読されます。 次に期待される期待パケットは、受信した最も高いパケット番号+1である。 たとえば、認証されたパケットの一番高いパケット番号が0xaa82f30eの場合、0x9b3の14ビット値を含むパケットは0xaa8309b3としてデコードされます。 パケット番号の復号のための擬似コードの例は、Appendix Aにあります。

送信者は、Ackされた最大のパケットと送信しようとしているパケット番号の差の二倍以上大きな値を表現できるパケット番号サイズをしようする必要があります(MUST)。パケットが受信された後に多くのより高い番号のパケットが到着するようなパケットの転送遅延がない限り、パケットを受信するピアパケット番号を正しく復号します。パケットが送信した多くのパケットの後に届いてもパケット番号を得るのに十分な大きさのパケット番号符号化をエンドポイントは使用すべきです(SHOULD)。

その結果、パケット番号符号化のサイズは、新しいパケットを含む連続した未ACKのパケット番号の数の底2の対数よりも少なくとも1大きくなります。

例えば、エンドポイントがパケット0x6afa2fに対するAckを受信した場合、0x6b2d79の数のパケットを送信するには14ビット以上のパケット番号エンコーディングが必要であり、0x6bc107の数のパケットを送信するためには30ビットのパケット番号符号化が必要です。

同じパケット番号空間の同じパケット番号を持つ異なるパケットを処理していないことが確実でない限り、受信者は新しい保護されていないパケットを破棄しなければならない(MUST)。 重複の抑制は[QUIC-TLS]のSection 9.3で説明される理由のためにパケット保護を取り除いた後に行わなければなりません(MUST)。 重複の抑制の効率的なアルゴリズムは、RFC2406のSection 3.4.3にあります。

Version Negotiationパケット(Section 4.3)にはパケット番号は含まれていません。 Retryパケット(Section 4.4)には、パケット番号フィールドを設定するための特別なルールがあります。

# 5.  Frames and Frame Types
パケット保護を解除した後のすべてのパケットのペイロードは、Figure 6に示すように一連のフレームで構成されています。Version NegotiationおよびStateless Resetにはフレームが含まれていません。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 1 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame 2 (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Frame N (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                          Figure 6: QUIC Payload

```

QUICペイロードは少なくとも1つのフレームを含まなければならず(MUST)、複数のフレームと複数のフレームタイプを含むことができます(MAY)。

フレームは、1つのQUICパケットに収まるものでなければならず、QUICパケット境界にまたがってはならなりません(MUST NOT)。 各フレームは、そのタイプを示すフレームタイプから始まり、その後に追加のタイプに依存するフィールドが続きます。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Frame Type (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                   Type-Dependent Fields (*)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 7: Generic Frame Layout
```

この仕様で定義されているフレームタイプをTable 3に示します。STREAMフレームのフレームタイプは、フレーム固有のフラグを送信します。 他のすべてのフレームでは、フレームタイプフィールドは単にフレームを識別します。 これらのフレームについては、後述のように詳細に説明します。

```
           +-------------+----------------------+--------------+
           | Type Value  | Frame Type Name      | Definition   |
           +-------------+----------------------+--------------+
           | 0x00        | PADDING              | Section 7.2  |
           |             |                      |              |
           | 0x01        | RST_STREAM           | Section 7.3  |
           |             |                      |              |
           | 0x02        | CONNECTION_CLOSE     | Section 7.4  |
           |             |                      |              |
           | 0x03        | APPLICATION_CLOSE    | Section 7.5  |
           |             |                      |              |
           | 0x04        | MAX_DATA             | Section 7.6  |
           |             |                      |              |
           | 0x05        | MAX_STREAM_DATA      | Section 7.7  |
           |             |                      |              |
           | 0x06        | MAX_STREAM_ID        | Section 7.8  |
           |             |                      |              |
           | 0x07        | PING                 | Section 7.9  |
           |             |                      |              |
           | 0x08        | BLOCKED              | Section 7.10 |
           |             |                      |              |
           | 0x09        | STREAM_BLOCKED       | Section 7.11 |
           |             |                      |              |
           | 0x0a        | STREAM_ID_BLOCKED    | Section 7.12 |
           |             |                      |              |
           | 0x0b        | NEW_CONNECTION_ID    | Section 7.13 |
           |             |                      |              |
           | 0x0c        | STOP_SENDING         | Section 7.15 |
           |             |                      |              |
           | 0x0d        | RETIRE_CONNECTION_ID | Section 7.14 |
           |             |                      |              |
           | 0x0e        | PATH_CHALLENGE       | Section 7.17 |
           |             |                      |              |
           | 0x0f        | PATH_RESPONSE        | Section 7.18 |
           |             |                      |              |
           | 0x10 - 0x17 | STREAM               | Section 7.20 |
           |             |                      |              |
           | 0x18        | CRYPTO               | Section 7.21 |
           |             |                      |              |
           | 0x19        | NEW_TOKEN            | Section 7.19 |
           |             |                      |              |
           | 0x1a - 0x1b | ACK                  | Section 7.16 |
           +-------------+----------------------+--------------+

                           Table 3: Frame Types

```

すべてのQUICフレームは冪等です。 すなわち、有効なフレームは複数回受信されたときに望ましくない副作用またはエラーを引き起こしません。

フレームタイプフィールドは、1つの例外を除いて、可変長整数エンコーディング(Section 7.1参照)を使用します。フレーム構文解析のシンプルで効率的な実装を保証するために、フレームタイプは可能な最短のエンコーディングを使用しなければならない(MUST)。このドキュメントで定義されているフレームタイプは2オクテット、4オクテットまたは8オクテットのエンコードが可能ですが、これらのフレームのフレームタイプフィールドは1オクテットでエンコードされます。 たとえば、0x4007は値7の可変長整数の正当な2オクテット符号化ですが、PINGフレームは常に値0x07の単一オクテットとしてエンコードされます。 エンドポイントは、必要以上に長いエンコーディングを使用するフレームタイプの受信を、PROTOCOL_VIOLATIONタイプの接続エラーとして扱わなければなりません(MUST)。

## 5.1.  Extension Frames
QUICフレームは、自己記述エンコーディングを使用しません。 したがって、エンドポイントはパケットを正常に処理するにはすべてのフレームの構文を理解する必要があります。 これにより、フレームの効率的なエンコードが可能になりますが、エンドポイントがそのピアに未知のタイプのフレームを送信できないことを意味します。

新しいタイプのフレームを使用したいQUICの拡張は、最初にピアがフレームを理解できることを保証しなければなりません(MUST)。エンドポイントは、トランスポートパラメータを使用して、1つのトランスポートパラメータで1つ以上の拡張フレームタイプを受信する意思を示すことができます。

拡張フレームは輻輳制御されなければならず(MUST)、ACKフレームが送信されなければならなりません(MUST)。 例外は、ACKフレームを置換または補完する拡張フレームです。 拡張で指定されていない限り、拡張フレームはフロー制御に含まれません。

IANAレジストリがフレームタイプの割り当てを管理するために使用されます。Section 13.2参照。

# 6.  Life of a Connection
QUICコネクションは2つのQUICエンドポイント間の1つの通信です。QUICの接続確立は、Section 6.4で説明するように、バージョンネゴシエーションと暗号化およびトランスポートハンドシェイクを組み合わせて接続確立の待ち時間を短縮します。接続が確立されると、Section 6.11で説明されるように、NATリバインディングまたは移動によって、いずれかのエンドポイントは異なるIPやポートに変わる可能性があります。 最後にSection 6.13で説明されているように、いずれかのエンドポイントが接続を終了することができます。

## 6.1.  Connection ID
各コネクションは一組の識別子を有し、そのいずれかを他のコネクションと区別するために使用することができます。コネクションIDは、各方向で独立して選択されます。 各コネクションIDには、メッセージの重複排除に役立つシーケンス番号に関連付けられます。

コネクションIDの主な機能は、下位プロトコル層(UDP、IP、およびそれ以下)でのアドレス変更が起きても、QUICコネクションのパケットを間違ったエンドポイントに配信しないようにすることです。 各エンドポイントは実装固有(場合によってはデプロイメント固有)の方法を使用してコネクションIDを選択します。その方法は、コネクションIDでルーティングされ、受診者によって識別できるようにします。

コネクションIDは、同じコネクションの以外のコネクションIDと関連付けに使用できる情報を含んではいけません(MUST NOT)。 簡単な例として、これは同じコネクションIDが同じコネクション上2回以上発行されてはならないことを意味します。

コネクションIDがルーティングのために必要でなく、パケットのアドレス/ポートのタプルがコネクションを識別するのに十分であるとき、長さゼロのコネクションIDが使用できます(MAY)。 ピアが長さゼロのコネクションIDを選択したエンドポイントは、コネクションの存続期間中、引き続き長さゼロのコネクションIDを使用しなければならず(MUST)、他のローカルアドレスからパケットを送信してはならない(MUST NOT)。

エンドポイントが非ゼロ長コネクションIDを要求した場合、エンドポイントに送信されるパケットの選択に必要なコネクションIDがピアに確保されていることを確認する必要があります。 これらのコネクションIDは、NEW_CONNECTION_IDフレーム(Section 7.13)を使用してエンドポイントによって提供されます。

### 6.1.1.  Issuing Connection IDs
エンドポイントによって発行される初期コネクションIDは、ハンドシェイク中のSource Connection IDです。初期コネクションIDのシーケンス番号は0です。preferred_addressトランスポートパラメータが送信される場合、指定されたコネクションIDのシーケンス番号は1です。後続のコネクションIDは、NEW_CONNECTION_IDフレーム(Section 7.13)を使用してピアに通信され、シーケンス番号は新たに発行されたコネクションIDごとに1ずつ増加する必要があります(MUST)。

Initialパケットでクライアントによってランダムに選択されたコネクションIDおよびResetパケットによって提供されるコネクションIDは、サーバが初期コネクションIDとして保持することを選択しない限り、シーケンス番号が割り当てられません。

エンドポイントがコネクションIDを発行するとき、コネクションの持続時間中、またはそのピアがRETIRE_CONNECTION_IDフレーム(Section 7.14)を介してコネクションIDを無効にするまで、このコネクションIDのパケットを受け入れなければならない(MUST)。

エンドポイントはピアが十分な数の利用可能な未使用コネクションIDを持つことを保証すべきである(SHOULD)。 各エンドポイントは独立して発行するコネクションIDの数を選びますが、エンドポイントは少なくとも8つのコネクションIDを提供して維持する必要があります(SHOULD)。エンドポイントは、コネクションIDがピアによってリタイアされたとき、またはエンドポイントが以前に使用されていないコネクションIDを持つパケットを受信したときに、常に新しいコネクションIDを提供することによって、これを実行できます。 マイグレーションを開始し、非ゼロ長のコネクションIDを必要とするエンドポイントは、マイグレーション前に新しいコネクションIDをピアに提供するか、またはピアがコネクションをクローズするリスクをおうべきです(SHOULD)。

### 6.1.2.  Consuming and Retiring Connection IDs
エンドポイントは、ピアのために使用するコネクションIDを、接続中のいつでも使用可能な別のコネクションIDに変更することができます。 エンドポイントはピアのマイグレーションに応じてコネクションIDを消費します(Section 6.11.5参照)。

エンドポイントは、ピアから受信した一連のコネクションIDを保持します。これらのIDのいずれもパケットを送信するときに使用できます。 エンドポイントはコネクションIDの利用停止を望むときにRETIRE_CONNECTION_IDフレームをピアに送信し、ピアがNEW_CONNECTION_IDフレームを使用して新しいコネクションIDを送るように指示します。

コネクションIDをリタイアさせるエンドポイントは、RETIRE_CONNECTION_IDフレームを送信した後、またはそのフレームがAckされるまでの間、そのコネクションIDの情報を保持できます。

Section 6.11.5で議論されるように、各コネクションIDはただ一つのローカルアドレスから送られたパケットで使わなければなりません(MUST)。 ローカルアドレスからマイグレーションするエンドポイントは、そのアドレスを使用する予定がなくなると、そのアドレスで使用されているすべてのコネクションIDを廃棄すべきです(SHOULD)。

## 6.2.  Matching Packets to Connections
やってくるパケットは受信時に分類されます。 パケットは既存のコネクションに関連付けることも、サーバのために新しいコネクションを作成することもできます。

ホストはパケットを既存のコネクションに関連付けることを試みます。 パケットに既存のコネクションに対応するDestination Connection IDがある場合、QUICはそれに応じてそのパケットを処理します。 1つのコネクションに複数のコネクションIDを関連付けることに注意してください。 Section 6.1を参照。

Destination Connection IDの長さがゼロでパケットがホストのコネクションIDを必要としない場合、コネクションのアドレス/ポートのタプルと一致する際、QUICはパケットをそのコネクションの一部として処理します。 エンドポイントはパケットがコネクションに対応していない場合は、ゼロ長のDestination Connection IDフィールドを持つパケットを破棄しなければならない(MUST)。

エンドポイントは、既存の接続に属さないパケットに対して、Stateless Reset(Section 6.13.4)を送信すべきです(SHOULD)。

### 6.2.1.  Client Packet Handling
クライアントに送信される有効なパケットには、常にクライアントが選択する値と一致するDestination Connection IDが含まれます。 長さゼロのコネクションIDを受信するクライアントは、アドレス/ポートのタプルを使用してコネクションを識別できます。 既存のコネクションと一致しないパケットは破棄されます。

パケットの順序入れ替わりや損失のために、クライアントはまだ計算されていない鍵で暗号化されたコネクション用のパケットを受信する可能性があります。 クライアントは、これらのパケットを破棄してもよいし(MAY)、鍵の計算を可能する後のパケットを期待してそれらをバッファしてもよい(MAY)。

クライアントがサポートされていないバージョンのパケットを受信した場合、そのパケットを破棄しなければならない(MUST)。

### 6.2.2.  Server Packet Handling
サーバがサポートされていないバージョンのパケットを受信した際、サーバがサポートしている任意のバージョンの新しいコネクションを開始するのに十分な大きさのパケットの場合は、Section 6.3.1で説明したVersion Negotiationパケットを送信すべきです(SHOULD)。 サーバはVersion Negotiationパケットのストームを避けるためにこれらのパケットのレートを制限してもよい(MAY)。

サポートされていないバージョンへの最初のパケットは、バージョン固有のフィールドに対して異なるセマンティクスとエンコーディングを使用できます。 特に、異なるバージョンのパケット保護鍵を使用する場合があります。 特定のバージョンをサポートしていないサーバは、パケットのペイロードを復号化することはできません。サーバは未知のバージョンからのパケットをデコードまたは暗号化すべきではありません(SHOULD NOT)。パケットが十分に長い場合は、サーバはVersion Negotiationパケットを送信します。

サーバは、サポートされていないバージョンを含む他のパケットを破棄しなければならない(MUST)。

サポートされているバージョンまたはバージョンフィールドを持たないパケットは、Section 6.2で説明されているコネクションに一致します。 一致しない場合、サーバは以下のように続きます。

パケットが仕様に完全に適合するInitialパケットである場合、サーバはハンドシェイクを続行する(Section 6.4)。 これにより、クライアントが選択したバージョンにサーバが合意します。

サーバが現在新しいコネクションを受け入れていない場合は、エラーコードSERVER_BUSYのCONNECTION_CLOSEフレームを含むInitialパケットを送信すべきです(SHOULD)。

パケットが0-RTTパケットである場合、サーバは、遅れて到着するInitialパケットを予期して、限られた数のパケットをバッファしてもよい(MAY)。 クライアントはサーバからのレスポンスを受信する前にHandshakeパケットを送信することを禁じられているため、サーバはそのようなパケットを無視すべきです(SHOULD)。

サーバは他のすべての状況下で受信パケットを廃棄しなければならない(MUST)。

## 6.3.  Version Negotiation
バージョンネゴシエーションは、クライアントとサーバが相互にサポートされているQUICバージョンに合意することを保証します。 サーバは、新しいコネクションを開始する可能性のある各パケットに応じてVersion Negotiationパケットを送信します。詳細はSection 6.2参照。

クライアントによって送信される最初のパケットのサイズによって、サーバがVersion Negotiationパケットを送信するかどうか決まります。 複数のQUICバージョンをサポートするクライアントは、送信する最初のパケットはサポートしているすべてのバージョンの最小パケットサイズのうち最大のものに埋め込むべきです(SHOULD)。相互にサポートされているバージョンが存在する場合、サーバが応答することを確実にします。

### 6.3.1.  Sending Version Negotiation Packets
クライアントによって選択されたバージョンがサーバに受け入れられない場合、サーバはVersion Negotiationパケット(Section 4.3参照)で応答します。 これには、サーバが受け入れるバージョンのリストが含まれます。

このシステムは、サーバが状態を保持せずにサポートされていないバージョンのパケットを処理することを可能にします。 レスポンスで送信されたInitialパケットまたはVersion Negotiationパケットのいずれかがロスしても、クライアントはレスポンスを正常に受信するか、接続試行を中止するまで、新しいパケットを送信します。

### 6.3.2.  Handling Version Negotiation Packets
クライアントがVersion Negotiationパケットを受信すると、まずDestinationおよびSource Connection IDフィールドが、クライアントが送信したパケットのSourceおよびDestination Connection IDフィールドと一致するかどうかがチェックされます。 このチェックが失敗した場合、パケットは破棄されなければならない(MUST)。

Version Negotiationパケットが有効であると判定されると、クライアントは、サーバによって提供されたリストから許容可能なプロトコルバージョンを選択します。 クライアントは、そのバージョンを使用してコネクションを作成しようとします。 クライアントが送信する初期パケットの内容は、バージョンネゴシエーションに応答して変更されないかもしれませんが、クライアントは送信するすべてのパケットで使用するパケット番号を増やさなければなりません。 パケットは引き続き長いヘッダを使用しなければならず、新しいネゴシエートされたプロトコルバージョンを含まなければならない(MUST)。クライアントが送信する初期パケットの内容は、バージョンネゴシエーションに応答して変更されないかもしれませんが、クライアントは送信するすべてのパケットで使用されるパケット番号を増やさなければなりません(MUST)。パケットは引き続きロングヘッダを使用しなければならず、新しくネゴシエートされたプロトコルバージョンを含まなければなりません(MUST)。

クライアントは1-RTTキーが得られ、Version Negotiationパケットではないパケットをサーバから受信するまで、ロングヘッダフォーマットを使用し、選択されたバージョンをすべてのパケットに含める必要があります。

サーバからのVersion Negotiationパケットに応じるとき以外、クライアントは使用するバージョンを変更してはいけません(MUST NOT)。一度クライアントがVersion Negotiationパケットではないパケットをサーバから受信すると、同じコネクション上の他のVersion Negotiationパケットを破棄しなければなりません(MUST)。 同様に、クライアントはVersion Negotiationパケットが既に受信し、Version Negotiationパケットの処理をしていた場合、クライアントはVersion Negotiationパケットを無視しなければならない(MUST)。

クライアントは、クライアントが選択したバージョンを示すVersion Negotiationパケットを無視しなければならない(MUST)。

クライアントはVersion Negotiationパケットを受信した後に0-RTTを試みてもよい(MAY)。 追加の0-RTTパケットを送信するクライアントは、その結果としてパケット番号を0にリセットしてはならない(MUST NOT)。Section 4.6.4参照。

Version Negotiationパケットには暗号保護はありません。 ネゴシエーションの結果は暗号ハンドシェイクの一部として再検証されなくてはなりません(MUST)。(Section 6.6.4を参照)。

### 6.3.3.  Using Reserved Versions
将来サーバが新しいバージョンを使用できるように、クライアントはサポートされていないバージョンを正しく処理する必要があります。 これを確実にするために、サーバはVersion Negotiationパケットを生成している間、予約されたバージョン(Section 3を参照)を含めるべきです(SHOULD)。

このバージョンネゴシエーションの設計により、サーバは拒否したパケットの状態を維持することを回避できます。 バージョンネゴシエーションの検証(Section 6.6.4を参照)は、バージョンネゴシエーションの結果のみを検証します。バージョンネゴシエーションの結果は、どの予約バージョンが送信されたものであっても同じです。 したがって、サーバは、Version Negotiation パケットとそのトランスポートパラメータに異なる予約バージョン番号を送信することができます(MAY)。

クライアントは、予約されたバージョン番号を使用してパケットを送信してもよい(MAY)。 これはサーバからサポートされているバージョンのリストを要求するために使用できます。

## 6.4.  Cryptographic and Transport Handshake
QUICはコネクション確立のレイテンシを最小限に抑えるために、暗号化とトランスポートのハンドシェイクを組み合わせて使用します。 QUICはCRYPTOフレーム(Section 7.21)を使用して暗号ハンドシェイクを送信します。 QUICのバージョン0x00000001は、[QUIC-TLS]で説明されているようにTLS 1.3を使用します。 異なるQUICバージョン番号は、異なる暗号ハンドシェイクプロトコルが使用することを示すことができます。

QUICは、信頼性の高い、暗号化されたハンドシェイクデータの配送を提供します。 QUICのパケット保護は、暗号ハンドシェイクプロトコルの要件を満たす機密性と完全性の保護を保証します。

- 認証された鍵交換
  - サーバは常に認証されます
  - クライアントはオプションで認証されます
  - すべての接続は、個別で無関係なキーを生成します
  - キーイングマテリアルは、0-RTTと1-RTTの両方のパケットのパケット保護に使用できます
  - 1-RTT鍵はforward secrecyです
- ピアのトランスポートパラメータの値は認証されます (Section 6.6参照)
- バージョンネゴシエーションの承認は認証されます (Section 6.6.4参照)
- アプリケーションプロトコルのネゴシエーションは認証されます (この目的でTLSはALPN [RFC7301]を使用します)
- クライアントが要求するトランスポートアドレスでアドレス指定されたパケットをクライアントが受信できるという保証を提供するデータを伝送する能力(Section 6.9参照)
- サーバにとって、クライアントによって主張されたトランスポートアドレスで処理されたパケットをクライアントが確かに受信できるという保証されたデータを伝送可能

最初のCRYPTOフレームは一つのパケットで送らなければなりません(MUST)。 アドレス検証によって行われるどんな2回目の送信も、単一パケット内で送信されなければなりません(MUST)。 これにより、複数のパケットからメッセージを再構成する必要がなくなります。

暗号ハンドシェイクプロトコルの最初のクライアントパケットは、1232オクテットのQUICパケットペイロードに収まる必要があります(MUST)。 これには、暗号ハンドシェイクプロトコルに使用できるスペースを削減するオーバーヘッドが含まれます。

CRYPTOフレームは、異なるパケット番号空間で送信することができます。各パケット番号空間内のCRYPTOフレームは、オフセット0から始まるハンドシェイクデータの別個のシーケンスで送信されます。

## 6.5.  Example Handshake Flows
TLSとQUICとの統合の詳細については、[QUIC-TLS]を参照してください。ここではいくつかの例を示します。

Figure 8は、1-RTTハンドシェイクの概要を示しています。 各行には、最初にQUICパケットのパケットタイプとパケット番号が示され、その後にパケットに含まれるフレームが続きます。 したがって、たとえば、最初のパケットはパケット番号0のInitialというタイプであり、ClientHelloを運ぶCRYPTOフレームを格納しています。

異なる暗号化レベルのものでも、複数のQUICパケットが単一のUDPデータグラムに統合される可能性があることに注意してください(Section 4.9を参照)。このハンドシェイクは、わずか4つのUDPデータグラム、 たとえば、サーバの最初の送信には、初期暗号化レベル(難読化)、ハンドシェイクレベル、および1-RTT暗号化レベルのサーバからの「0.5-RTTデータ」のパケットが含まれています。

```
   Client                                                  Server

   Initial[0]: CRYPTO[CH] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                          Handshake[0]: CRYPTO[EE, CERT, CV, FIN]
                                    <- 1-RTT[0]: STREAM[1, "..."]

   Initial[1]: ACK[0]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[0]: STREAM[0, "..."], ACK[0] ->

                              1-RTT[1]: STREAM[55, "..."], ACK[0]
                                          <- Handshake[1]: ACK[0]

                     Figure 8: Example 1-RTT Handshake
```

Figure 9は、0-RTTハンドシェイクと0-RTTデータの1つのパケットによるコネクションの例を示しています。 Section 4.11で説明したように、サーバは1-RTT暗号化レベルで0-RTTデータをACKし、1-RTT暗号化レベルのクライアントのシーケンス番号は0-RTTパケットから増加し続けます。

```
   Client                                                  Server

   Initial[0]: CRYPTO[CH]
   0-RTT[0]: STREAM[0, "..."] ->

                                    Initial[0]: CRYPTO[SH] ACK[0]
                           Handshake[0] CRYPTO[EE, CERT, CV, FIN]
                             <- 1-RTT[0]: STREAM[1, "..."] ACK[0]

   Initial[1]: ACK[0]
   0-RTT[1]: CRYPTO[EOED]
   Handshake[0]: CRYPTO[FIN], ACK[0]
   1-RTT[2]: STREAM[0, "..."] ACK[0] ->

                            1-RTT[1]: STREAM[55, "..."], ACK[1,2]
                                          <- Handshake[1]: ACK[0]

                     Figure 9: Example 0-RTT Handshake
```

## 6.6.  Transport Parameters
コネクション確立中、両方のエンドポイントはトランスポートパラメータの認証された宣言を行います。これらの宣言は、各エンドポイントによって一方的に行われます。 エンドポイントは、これらのパラメータが意味する制限に準拠する必要があります。 各パラメータの説明には、その処理のためのルールが含まれています。

トランスポートパラメータのフォーマットは、Figure 10のTransportParameters構造体です。これは、[TLS13]のSection 3のプレゼンテーション言語を使用して記述されています。

```
      uint32 QuicVersion;

      enum {
         initial_max_stream_data_bidi_local(0),
         initial_max_data(1),
         initial_max_bidi_streams(2),
         idle_timeout(3),
         preferred_address(4),
         max_packet_size(5),
         stateless_reset_token(6),
         ack_delay_exponent(7),
         initial_max_uni_streams(8),
         disable_migration(9),
         initial_max_stream_data_bidi_remote(10),
         initial_max_stream_data_uni(11),
         max_ack_delay(12),
         original_connection_id(13),
         (65535)
      } TransportParameterId;

      struct {
         TransportParameterId parameter;
         opaque value<0..2^16-1>;
      } TransportParameter;

      struct {
         select (Handshake.msg_type) {
            case client_hello:
               QuicVersion initial_version;

            case encrypted_extensions:
               QuicVersion negotiated_version;
               QuicVersion supported_versions<4..2^8-4>;
         };
         TransportParameter parameters<22..2^16-1>;
      } TransportParameters;

      struct {
        enum { IPv4(4), IPv6(6), (15) } ipVersion;
        opaque ipAddress<4..2^8-1>;
        uint16 port;
        opaque connectionId<0..18>;
        opaque statelessResetToken[16];
      } PreferredAddress;

               Figure 10: Definition of TransportParameters
```

[QUIC-TLS]で定義されたquic_transport_parameters拡張の「extension_data」フィールドには、TransportParameters値が含まれています。 したがって、トランスポートパラメータをエンコードするためにTLSエンコーディングルールが使用されます。

QUICはトランスポートパラメータを一連のオクテットにエンコードし、その後、暗号ハンドシェイクに含めます。 ハンドシェイクが完了すると、ピアによって宣言されたトランスポートパラメータが使用可能になります。 各エンドポイントは、ピアによって提供される値を検証します。特に、コネクション確立が適切に完了したとみなされる前に、バージョンネゴシエーションを検証(Section 6.6.4を参照)しなければならない(MUST)。

定義された各トランスポートパラメータの定義は、Section 6.6.1に含まれています。 与えられたパラメータは、指定されたトランスポートパラメータ拡張で最大でも1回しか現れてはならない(MUST)。 エンドポイントは重複したトランスポートパラメータの受信をタイプTRANSPORT_PARAMETER_ERRORのコネクションエラーとして扱わなければなりません。

### 6.6.1.  Transport Parameter Definitions
エンドポイントは下記のトランスポートパラメータを使用できます(MAY):

initial_max_data (0x0001): 初期最大データパラメータには、コネクションで送信できるデータの最大量の初期値が含まれます。 このパラメータは、オクテット単位の符号なし32ビット整数としてエンコードされます。 これはハンドシェイクが完了した直後に接続のMAX_DATA(Section 7.6)を送信するのと同じです。 トランスポートパラメータがない場合、接続はフロー制御の制限値は0で開始されます。

initial_max_bidi_streams (0x0002): 初期最大双方向ストリームパラメータは、ピアが開始することができる双方向ストリームの初期最大数が符号なし16ビット整数としてエンコードされます。 このパラメータがないかゼロの場合は、MAX_STREAM_IDフレームが送信されるまで双方向ストリームを作成できません。 このパラメータを設定するのは、対応するストリームIDを含むハンドシェイクを完了した直後にMAX_STREAM_ID(Section 7.8)を送信するのと同じです。 たとえば、0x05の値は、クライアントが値16のMAX_STREAM_IDを、サーバが値17のMAX_STREAM_IDを受信するのと等価です。

initial_max_uni_streams (0x0008): 最初の最大単方向ストリームパラメータには、ピアが開始できる単方向ストリームの初期最大数が符号なし16ビット整数としてエンコードされます。 このパラメータがないかゼロの場合、MAX_STREAM_IDフレームが送信されるまで単方向ストリームは作成できません。 このパラメータを設定するのは、対応するストリームIDを含むハンドシェイクを完了した直後にMAX_STREAM_ID(Section 7.8)を送信するのと同じです。たとえば、0x05の値は、クライアントが値18のMAX_STREAM_IDを、サーバが値19のMAX_STREAM_IDを受信するのと等価です。

idle_timeout (0x0003): アイドルタイムアウトは秒の値で、符号なし16ビット整数としてエンコードされます。 このパラメータがないかゼロの場合、アイドルタイムアウトは無効になります。

max_packet_size (0x0005): 最大パケットサイズパラメータは、エンドポイントが受信するパケットのサイズに制限を設け、符号なし16ビット整数としてエンコードします。この制限を超えるパケットが廃棄されることを示します。 このパラメータのデフォルトは、UDPペイロードとして許可されている65527です。1200未満の値は無効です。 この制限は保護されたパケット(Section 4.8)にのみ適用されます。

ack_delay_exponent (0x0007): ACKフレームのACK Delayフィールドのデコードに使用される指数を示す8ビットの符号なし整数値。Section 7.16を参照。 この値が存在しない場合は、デフォルト値の3が仮定されます(乗数8を示します)。 デフォルト値は、初期およびHandshakeパケットで送信されるACKフレームにも使用されます。 20を超える値は無効です。

disable_migration (0x0009): エンドポイントはコネクションのマイグレーションをサポートしていません(Section 6.11)。 ピアは、ハンドシェイクの実行に使用されたもの以外のローカルアドレスからプロービングパケット(Section 6.11)を含むパケットを送信してはいけません。 このパラメーターの値は長さゼロです。

max_ack_delay (0x000c): Ackの送信を遅延させる最大時間をミリ秒単位の8ビットの符号なし整数値。 この値が指定されていない場合、デフォルト値は25ミリ秒となります。

いずれかのピアは、データを受信する可能性のある各タイプのストリームでフロー制御の初期値を宣言してもよい(MAY)。 以下の各トランスポートパラメータは、オクテット単位の符号なし32ビット整数としてエンコードされます。

initial_max_stream_data_bidi_local (0x0000): ローカル開始の双方向ストリームの初期ストリーム最大データには、トランスポートパラメータを設定するエンドポイントによって新たに作成された双方向ストリームの初期フロー制御上限が含まれています。 クライアントトランスポートパラメータでは、これは0x0で終わるストリームに適用されます。 サーバトランスポートパラメータでは、これは0x1で終わるストリームに適用されます。

initial_max_stream_data_bidi_remote (0x000a): ピア開始の双方向ストリームの初期ストリーム最大データには、トランスポートパラメータを設定するエンドポイントによって新たに作成された双方向ストリームの初期フロー制御上限が含まれています。クライアントトランスポートパラメータでは、これは0x1で終わるストリームに適用されます。 サーバトランスポートパラメータでは、これは0x0で終わるストリームに適用されます。

initial_max_stream_data_uni (0x000b): 単方向ストリームの初期ストリーム最大データには、トランスポートパラメータを受信するエンドポイントによって新たに作成された単方向ストリームの初期フロー制御上限が含まれています。 クライアントトランスポートパラメータでは、これは0x3で終わるストリームに適用されます。 サーバトランスポートパラメータでは、これは0x2で終わるストリームに適用されます。

存在する場合、初期ストリームフロー制御上限を設定するトランスポートパラメータは、オープン直後に対応するタイプのすべてのストリームにMAX_STREAM_DATAフレーム(Section 7.7)を送信することと同等です。 トランスポートパラメータがない場合、そのタイプのストリームはフロー制御の上限が0で始まります。

Retryパケットを送信した場合、サーバはoriginal_connection_id転送パラメータを含まなければならなりません(MUST):

original_connection_id (0x000d): クライアントが送信した最初のInitialパケットからのDestination Connection IDフィールドの値。 この転送パラメータは、サーバによってのみ送信されます。

サーバは以下のトランスポートパラメータを含めてもよい(MAY)：

stateless_reset_token (0x0006): ステートレスリセットトークンは、ステートレスリセットの検証に使用されます。Section 6.13.4を参照。 このパラメータは、16オクテットの値です。

preferred_address (0x0004): サーバのPreferred Addressは、Section 6.12で説明されるように、ハンドシェイクの終了時にサーバアドレスの変更を行うために使用されます。

クライアントは、ステートレスリセットトークンまたはpreferred addを含めてはならない(MUST NOT)。 サーバはいずれかのトランスポートパラメータの受信した場合、TRANSPORT_PARAMETER_ERRORタイプのコネクションエラーとして扱わなければならない(MUST)。

### 6.6.2.  Values of Transport Parameters for 0-RTT
0-RTTデータを送信しようとするクライアントは、サーバによって使用されるトランスポートパラメータを記憶しなければならない(MUST)。コネクション確立中にサーバが通知するトランスポートパラメータは、そのハンドシェイク中に確立された鍵マテリアルを使用して再開されるすべてのコネクションに適用されます。 記憶されたトランスポートパラメータは、ハンドシェイクが完了し、サーバからの新しいトランスポートパラメータが提供されるまで、新しいコネクションに適用されます。

0-RTTデータを受け入れるとき、サーバは通知したトランスポートパラメータを覚えておくか、完全性が守られた値をチケットに保存しておいて、その情報を復元することができます。サーバはトランスポートパラメータを使用して、0-RTTデータを受け入れるかどうかを決定します。

サーバは0-RTTを受け入れても良い(MAY)。続いて新しいコネクションで使用するために、トランスポートパラメータに異なる値を提供してもよい。サーバが0-RTTデータを受け入れる場合、サーバはクライアントによって0-RTTデータで違反された可能性のある上限値を減らしたり変更してはいけません(MUST NOT)。特に、0-RTTデータを受け入れるサーバは、それらのパラメータが記憶された値よりも小さいinitial_max_data、nitial_max_stream_data_bidi_local、initial_max_stream_data_bidi_remote、およびinitial_max_stream_data_uniの値を設定してはならない(MUST NOT)。

特定のトランスポートパラメータの値を省略または0に設定すると0-RTTデータは有効になりますが、使用できません。アプリケーションデータの送信を許可するトランスポートパラメータの適切な集合は、0-RTTの非ゼロ値に設定すべきです(SHOULD)。  これには、initial_max_dataとinitial_max_bidi_streamsとinitial_max_stream_data_bidi_remote、またはinitial_max_uni_streamsおよびinitial_max_stream_data_uniである。

新しいコネクションを確立するとき、サーバの以前のpreferred_addressの値を使用してはならない(MUST NOT)。むしろ、クライアントはハンドシェイクのサーバの新しいpreferred_address値を確認するのを待つべきです。

トランスポートパラメータの暗黙の値がサポートできない場合、サーバは0-RTTデータを拒否するかハンドシェイクを中断しなければならない(MUST)。

### 6.6.3.  New Transport Parameters
新しいトランスポートパラメータを使用して、プロトコルの新しい動作をネゴシエーションできます。エンドポイントはサポートしないトランスポートパラメータを無視しなければなりません(MUST)。したがって、トランスポートパラメータが存在しない場合、パラメータを使用してネゴシエートされる任意のプロトコル機能が無効になります。

新しいトランスポートパラメータは、Section 13.1のルールに従って登録することができます。

### 6.6.4.  Version Negotiation Validation
暗号ハンドシェイクには完全性ｎ保護がありますが、QUICバージョンダウングレードには2つの方法があります。 １つ目は、攻撃者はInitialパケットのQUICバージョンを置き換えます。2つ目は、攻撃者によって偽のVersion Negotiationパケットが送信されます。これらの攻撃から保護するために、トランスポートパラメータにはバージョン情報をエンコードする3つのフィールドが含まれています。これらのパラメータは、バージョンの選択を遡及的に認証するために使用されます(Section 6.3を参照)。

暗号ハンドシェイクは、トランスポートパラメータ(Section 6.6)の一部として、ネゴシエーションされたバージョンに対する完全性保護を提供します。その結果、攻撃者によるバージョンネゴシエーションへの攻撃を検出することができます。

クライアントは、トランスポートパラメータにinitial_versionフィールドを含めます。 initial_versionは、クライアントが最初に使用しようとしたバージョンです。サーバがVersion Negotiationパケットを送信しなかった場合は、これはサーバのトランスポートパラメータのnegotiated_versionフィールドと同じになります。

ステートフルな方法ですべてのパケットを処理するサーバは、バージョンネゴシエーションの実行方法を覚えていて、initial_version値を検証します。

受信するすべてのパケットの状態を維持しないサーバ(ステートレスサーバ)は、別のプロセスを使用します。 initial_versionが使用中のQUICのバージョンと一致する場合、ステートレスサーバはその値を受け入れることができます。

initial_versionが使用中のQUICのバージョンと異なる場合、ステートレスサーバはパケットを受信したinitial_versionの値が、Version Negotiationパケットで送信したことがあることを確認しなければならない(MUST)。サーバがinitial_versionに含まれるバージョンを受け入れ、その値が使用中のQUICバージョンと異なる場合、サーバはVERSION_NEGOTIATION_ERRORエラーで接続を終了しなければならない(MUST)。

サーバには、使用中のQUICのバージョンと、サーバがサポートするQUICバージョンのリストを持ちます。

negotiated_versionフィールドは、使用中のバージョンです。 これはサーバが受け入れるInitialパケット(RetryまたはVersion Negotiationパケットを引き起こすInitialパケットではない)にある値に設定しなければなりません。 使用中のQUICのバージョンと一致しないnegotiated_versionを受け取ったクライアントは、VERSION_NEGOTIATION_ERRORエラーで接続を終了しなければならない(MUST)。

サーバには、version negotiationパケット(Section 4.3)のsupported_versionsフィールドで送信するバージョンのリストを持ちます。 サーバはversion negotiationパケットを送信しなかった場合でもこのフィールドに値を設定します。

クライアントは、negotiated_versionがsupported_versionsリストに含まれていること、およびバージョンネゴシエーションが実行されている場合は、それがネゴシエーションされたバージョンとして選ばれていることを検証します。 現在のQUICバージョンがsupported_versionsリストにリストされていない場合、クライアントはVERSION_NEGOTIATION_ERRORエラーコードで接続を終了しなければならない(MUST)。 バージョンネゴシエーションをしたが、supported_versionsリストの値と異なるバージョンが選択された場合、クライアントはERSION_NEGOTIATION_ERRORエラーコードで終了する必要があります(MUST)。

エンドポイントが複数のQUICバージョンを受け入れると、サポートするQUICバージョンで定義されているいずれかのトランスポートパラメータを解釈する可能性があります。 QUICパケットヘッダのversionフィールドは、トランスポートパラメータを使用して認証されます。トランスポートパラメータのversionフィールドの位置とフォーマットは、異なるQUICバージョン間で同一であるか、またはその解釈に関する混乱を避けるために明確に異なるものでなければならない(MUST)。 新しいフォーマットを導入できる1つの方法としては、異なるコードポイントを持つTLS拡張を定義することです。

## 6.7.  Stateless Retries
サーバは状態をコミットせずにクライアントからのInitialパケットを処理できます。 これにより、サーバはアドレス検証(Section 6.9)を実行したり、接続確立コストを延期することができます。

コネクション状態を保持せずにInitialパケットへの応答を生成するサーバはRetryパケット(Section 4.4)を使用しなければならない(MUST)。 このパケットは、クライアントに接続試行を再開させ、トークンを新しい初期パケット(セクション4.6)に含めて送信元アドレスの所有権を証明します。このパケットは、クライアントに接続試行を再開させ、トークンを新しいInitialパケット(Section 4.6)に含めることで送信元アドレスの所有を証明します。

## 6.8.  Using Explicit Congestion Notification
QUICエンドポイントはExplicit Congestion Notification(ECN)[RFC3168]を使用してネットワークの輻輳を検出し、それに対応します。 ECNはパケットのIPヘッダにドロップする代わりにコードポイントを設定することによって、ネットワークノードにネットワークの輻輳を示すことができるようになります。 [QUIC-RECOVERY]で説明されているように、エンドポイントはレスポンスで送信するレートを減らすことによって輻輳に対処します。

ECNを使用するには、QUICエンドポイントはまず、パスがECNマーキングをサポートしているかどうかを判断し、ピアがIPヘッダ内のECNコードポイントにアクセスできるかどうかを判断します。 ECNマーク付きパケットがドロップされたり、ECNのマーキングがパス上で書き換えられたりした場合は、ネットワークパスはECNをサポートしていません。 エンドポイントは、コネクションの確立時および新しいパスへの移行時の両方でパスを検証します(Section 6.11)。

各エンドポイントはパスのために自身から他のペアに対するIPヘッダのECNコードポイントをECN Capable Transport(ECT)に設定することによって、ECNを独立して検証し、ECNの使用を有効にします。 ECNがピアへのパス上で使われなくても、エンドポイントは受け取ったECNマーク(アクセス可能であれば)に関するフィードバックを提供しなければなりません(MUST)。

パスがECNをサポートし、ピアがECNフィードバックを提供できることを確認するには、エンドポイントはすべての送信パケット[RFC8311]のIPヘッダにECT(0)コードポイントを設定しなければならない。

IPヘッダに設定されたECTコードポイントがネットワークデバイスによって壊されていない場合、受信パケットにはピアによって送信されたコードポイントまたは輻輳が発生しているネットワークデバイスによって設定された輻輳経験(CE)コードポイントのいずれかが含まれます。

ECTまたはCEコードポイントを持つパケットを受信すると、IP ECNコードポイントにアクセスできるエンドポイントは、対応するECT(0)、ECT(1)、またはCEカウントを増加させ、後続(Section 8.1)のACKフレーム (Section 7.16を参照)。

受信者によって重複として検出されたパケットは、受信者のローカルECNコードポイントのカウントに影響しません。 関連するセキュリティ上の懸念事項については、Section 12.7を参照してください。

エンドポイントがECTまたはCEコードポイントのないパケットを受信した場合、Section 8.1の通りACKフレームを返します。

エンドポイントが受信したECNコードポイントにアクセスできない場合、Section 8.1の通り受信したフレームをACKフレームでAckします。

送信したECTコードポイントを持つパケットがACKフレーム内でピアによって新たにAckされた場合、エンドポイントはネットワークまたはピアがECNをもはやサポートしないことを想定して、後続パケットのECTコードポイントの設定を停止する。

ネットワークによるECNコードポイントの破損からコネクションを保護するために、エンドポイントはACKフレームを受信したときに次のことを検証します:

- ECT(0)とECT(1)のカウンタの増加は、少なくとも対応するコードポイントで送信された新たにAckパケットの数でなければならない(MUST)。
- ACKフレームで報告されたECT(0)、ECT(1)、およびCEカウンタの合計増加は、少なくともこのACKフレームで新たにAckされたパケットの総数でなければなりません。

ACKフレームをロスした場合、エンドポイントはパケットのAckを見逃す可能性があります。したがって、ECT(0)、ECT(1)、およびCEカウンタの合計増加は、ACKフレームでAckされたパケット数よりも大きくなる可能性があります。  これが発生したとき、ローカルの参照カウントはACKフレームのカウンターと一致するために増やさなければなりません(MUST)。

検証に成功すると、エンドポイントはパスがECN対応であることを前提として、続くパケットにECTコードポイントを設定し続けます。

エンドポイントが送信パケットにECTコードポイントを設定しピアからのAckがないために再送信タイムアウトが発生した場合([QUIC-RECOVERY]を参照)、またネットワークによってECNコードポイントを破損していると思われる理由がある場合、 エンドポイントは後続のパケットでECTコードポイントの設定を中止できます(MAY)。そうすることで、IPヘッダのECNコードポイントを破棄または破損させるネットワークをコネクションが通ることが可能になります。

## 6.9.  Proof of Source Address Ownership
通常クライアントが要求するトランスポートアドレス(IPおよびポート)をクライアントが所有しているかどうかをチェックするのにトランスポートプロトコルは1回のラウンドトリップを消費します。クライアントが要求されたトランスポートアドレスに送信されたパケットを受信できることを確認することで、悪意あるクライアントによるなりすましが防止されます。

この技術は、主にトラフィック増幅攻撃にQUICが使用されないようにするために使用されます。 このような攻撃では、犠牲者宛の偽の送信元アドレス情報を持つパケットがサーバに送信されます。 サーバがそのパケットに対応してより多くのパケットを生成する場合、攻撃者はサーバを使用して、自分自身で送信できるよりも多くのデータを被害者に送信することができます。

この攻撃を軽減するためにいくつかの方法がQUICで使用されています。 最初に、最初のハンドシェイクパケットは、UDPペイロードの少なくとも1200オクテットのUDPデータグラムで送信されます。 これにより、サーバは、確証のないリモートアドレスに対して増幅攻撃を引き起こすリスクなく同様の量のデータを送信することができます。

サーバは最初にハンドシェイクレベルのメッセージが受信を受信すると、クライアントがメッセージを受信したことを最終的に確認できます。 これは、サーバがハンドシェイクを完了するための計算コストを避けたい場合や、ハンドシェイク中に送信されるパケットのサイズが大きすぎる場合は不十分です。これは0-RTTでは特に重要です。サーバは、クライアントからのearly dataで転送されるデータへのレスポンスとして、アプリケーションデータトラフィック(リクエストに対するレスポンスなど)を提供したい場合があります。

暗号ハンドシェイクを完了する前に追加のデータを送信するには、クライアントの主張するアドレスをクライアントが所有していることを検証する必要があります。

したがって、送信元アドレス検証は、コネクションの確立中にコアトランスポートプロトコルによって実行されます。

コネクションのマイグレーション後に異なるタイプの送信元アドレス検証が実行されます(Section 6.10)。

### 6.9.1.  Client Address Validation Procedure
QUICはトークンベースのアドレス検証を使用します。 サーバがクライアントアドレスの検証を行いたいときは、クライアントはトークンをクライアントに提供します。トークンの真正性をチェックすることができ(Section 6.9.3を参照)、クライアントがトークンを返すことができる限り、クライアントはトークンを受け取ったことをサーバに証明できます。

クライアントのInitialパケットを受信すると、サーバはトークンを含むRetryパケットを送信してアドレスの検証を要求できます。    このトークンは、クライアントの次のInitialパケットでそのまま伝えられます。 トークンは、トークンを生成したサーバによって使用されるため、形式の定義はありません。 トークンには、主張されたクライアントアドレス(IPおよびポート)、タイムスタンプ、およびサーバが将来トークンを検証するために必要とするその他の補足情報に関する情報が含まれています。

Retryパケットはクライアントに送信され、正当なクライアントはハンドシェイクを続行するときにRetryパケットからのトークンを含むInitialパケットで応答します。 トークンの受信に応じて、サーバはコネクションを中止するか、または接続を続行することができます。

コネクションはアドレス検証なしまたは限定された検証のみで受け入れてもよい(MAY)、しかしサーバは未検証アドレスに送信するデータを制限しなければならない(SHOULD)。 暗号ハンドシェイクが成功で完了した場合、クライアントがサーバからパケットを受信したという暗黙の証拠となります。

クライアントはトークンを含むInitialパケットへの応答として追加のRetryパケットが送信されるのを許容すべきです。 サーバが以前に生成されたトークンを使用してクライアントのアドレスを検証できない可能性があり、新しいRetryを送信する必要のある状況があります。 クライアントが許容する試行回数の合理的な上限は3回です。つまり、クライアントは新しいRetryパケットからアドレス検証トークンを最大3回エコーしなければなりません(MUST)。 その後、接続試行を諦めてもよい(MAY)。

### 6.9.2.  Address Validation for Future Connections
サーバは、あるコネクション中にのちのコネクションで使用できるアドレス検証トークンをクライアントに提供することができます(MAY)。 サーバが0-RTTデータへのレスポンスとしてクライアントに大量のデータを送信する可能性があるため、アドレス検証は特に0-RTTでは重要です。

サーバは、NEW_TOKENフレームのセクション7.19を使用して、将来の接続を検証するために使用できるアドレス検証トークンをクライアントに提供します。 クライアントは、このトークンを使用して、初期パケットのヘッダにそれを含めることによって、将来の接続を検証することができる。クライアントは、将来の接続のために再試行で提供されたトークンを使用してはならない(MUST NOT)。

サーバは、NEW_TOKENフレーム(Section 7.19)を使用して、将来のコネクションで検証するために使用できるアドレス検証トークンをクライアントに提供します。 クライアントは、このトークンを使用して、Initialパケットのヘッダにそれを含めることによって、将来のコネクションを検証されます。クライアントは、Retryで提供されたトークンを将来のコネクションのために使用してはならない(MUST NOT)。

Retryパケット用に作成されたトークンとは異なり、トークンが作成されてからトークンが後で使用されるまでに時間がかかることがあります。 したがって、リサンプショントークンは有効期限を含むべきです(SHOULD)。 サーバは、明示的な有効期限または発行されたタイムスタンプを含めることができ、有効期限を動的に計算することができます(MAY)。 2つの異なるコネクションでクライアントのポート番号が同じである可能性はほとんどありません。 したがって、ポートを検証の成功する可能性は低いです。

### 6.9.3.  Address Validation Token Integrity
アドレス検証トークンは、推測するのが困難でなければなりません(MUST)。 トークンに十分大きさのランダムな値を含めることで十分ですが、これはクライアントに送信する値を記憶するサーバによります。

トークンベースのスキームにより、サーバは検証に関連するすべての状態をクライアントにオフロードできます。 この設計が機能するためには、トークンはクライアントによる変更または改ざんに対する完全性保護によってカバーされてなくてはなりません(MUST)。完全性の保護がなければ、悪意のあるクライアントは、サーバが受け入れるトークンの値を生成したり推測したりする可能性があります。 サーバのみがトークンの完全性保護キーにアクセスする必要があります。

## 6.10.  Path Validation
パス検証は、エンドポイントが特定のパス上のピアの到達可能性を検証するために使用されます。 つまり、特定のローカルアドレスと特定のピアアドレスとの間の到達可能性をテストします。ここで、アドレスはIPアドレスとポートの2つのタプルです。 パスの妥当性検証では、パケットをピアに送受信できることをテストします。

パス検証は、新しいローカルアドレスからのピアの到達可能性を検証するために、マイグレーションするエンドポイントによってコネクションのマイグレーション中に使用されます(Section 6.11およびSection 6.12を参照)。 パス検証は、マイグレーション先のエンドポイントが新しいアドレスに送信されたパケットを受信できることを確認するためにも使用されます。 つまり、マイグレーション中のエンドポイントから受信したパケットは、偽装された送信元アドレスではありません。

パス検証は、どちらのエンドポイントでもいつでも使用できます。 例えば、エンドポイントは一定期間通信を行わなかった後にピアがそのアドレスを所有していることを確認することがあります。

パス検証は、NATトラバーサルのメカニズムとしては設計されていません。 NATトラバーサルをサポートするNATバインディングを作成するには、ここで説明したメカニズムが効果的かもしれませんが、最初にそのパスでパケットを送信しなくても、自身や他のピアがパケットを受信できることが期待されます。 効果的なNATトラバーサルには、ここでは提供されていない追加の同期メカニズムが必要です。

エンドポイントは、他のフレームとパス検証に使用されるPATH_CHALLENGEフレームとPATH_RESPONSEフレームをバンドルできます(MAY)。 例えば、エンドポイントは、PMTU発見のためにPATH_CHALLENGEをパケットに入れることが出来ます、またはエンドポイントはPATH_RESPONSEをそれ自身のPATH_CHALLENGEとバンドルすることができる。

新しいパスを調べるとき、エンドポイントはそのピアがレスポンスに使用可能な未使用のコネクションIDを持つことを確認したいことがあります。 エンドポイントは同じパケット内にNEW_CONNECTION_IDとPATH_CHALLENGEフレームを含めて送信できます。 これによりレスポンスを送信するときに、未使用のコネクションIDをピアが使用できるようになります。

### 6.10.1.  Initiation
パス検証を開始するために、エンドポイントは、検証されるパスにランダムなペイロードを含むPATH_CHALLENGEフレームを送信します。

エンドポイントはパケット損失の可能性があるので追加のPATH_CHALLENGEフレームを送れます(MAY)。 エンドポイントはInitialパケットよりも頻繁にPATH_CHALLENGEを送信して、コネクションのマイグレーションが新しいコネクションを確立するよりも新しいパスに負荷をかけないようにする必要があります(SHOULD NOT)。

エンドポイントはすべてのPATH_CHALLENGEフレームで新しいランダムデータを使用しなければならない(MUST)。これによって、ピアのレスポンスを原因のPATH_CHALLENGEに関連付けることができます。

### 6.10.2.  Response
PATH_CHALLENGEフレームを受信すると、エンドポイントはPATH_CHALLENGEフレームに含まれているデータをPATH_RESPONSEフレームでエコーすることによって直ちにレスポンスしなければなりません(MUST)。PATH_CHALLENGEは偽装されたアドレスから送信される可能性があるため、PATH_RESPONSEフレームを送信するレートをエンドポイントが制限できます(MAY)。また、高い頻度で送られるレスポンスを発生させるPATH_CHALLENGEフレームを黙って破棄できます(MAY)。

パケットがピアとの間で送受信できるようにするには、PATH_RESPONSEは契機となったPATH_CHALLENGEと同じパスで送信される必要があります(MUST)。つまり、PATH_CHALLENGEが受信したのと同じローカルアドレスから、PATH_CHALLENGEが受信されたのと同じリモートアドレスに変更されます。

### 6.10.3.  Completion
新しいアドレスは、以前PATH_CHALLENGEで送信したデータを含むPATH_RESPONSEフレームが受信されたときに有効と見なされます。PATH_CHALLENGEフレームを含むパケットに対するAckの受信は、Ackが悪意のあるピアによって偽装される可能性があるため、適切な検証ではありません。

パス検証が成功するためには、対応するPATH_CHALLENGEが送信されたのと同じリモートアドレスからPATH_RESPONSEフレームを受信しなければならない(MUST)。 PATH_CHALLENGEが送信されたものとは異なるリモートアドレスからPATH_RESPONSEフレームを受信した場合、PATH_CHALLENGEで送信されたデータと一致する場合でも、パスの検証は失敗したとみなされます。

さらに、PATH_RESPONSEフレームは、対応するPATH_CHALLENGEが送信されたのと同じローカルアドレスで受信しなければならない(MUST)。PATH_CHALLENGEが送信されたローカルアドレスとは異なるローカルアドレスでPATH_RESPONSEフレームが受信された場合、PATH_CHALLENGEで送信されたデータと一致する場合でも、パスの検証は失敗したとみなされます。 したがって、エンドポイントはPATH_RESPONSEフレームがPATH_CHALLENGEフレームと同じペイロードで同じパスで受信されたときにパスが有効であるとみなします。

### 6.10.4.  Abandonment
エンドポイントはいくつかのPATH_CHALLENGEフレームを送信した後、またはある時間が経過した後、パス検証を放棄しなければならない(SHOULD)。 このタイマーを設定するとき、実装は新しいパスが元のものより長いラウンドトリップタイムを持つ可能性があることに注意します。

エンドポイントは新しいパス上で他のフレームを含むパケットを受信する可能性がありますが、パス検証に成功するためには適切なデータを持つPATH_RESPONSEフレームが必要です。

パスの検証が失敗した場合、そのパスは使用不可とみなされます。 これは、必ずしもコネクションの失敗を意味するものではありません。エンドポイントは他の適切なパスでパケットを送信し続けることができます。 使用可能なパスがない場合、エンドポイントは新しいパスが使用可能になるのを待つか、コネクションをクローズすることができます。

パスの検証は、失敗以外の理由で中止される可能性があります。 これは主に、あるパス上でのパス検証が進行中に新しいパスへのコネクションのマイグレーションが開始された場合に起こります。

## 6.11.  Connection Migration
QUICで、エンドポイントの新しいネットワークへのマイグレーションによって引き起こされるエンドポイントアドレス(つまり、IPアドレスおよび/またはポート)の変更があってもコネクションを維持できるようになっています。 このセクションでは、エンドポイントが新しいアドレスにマイグレーションするプロセスについて説明します。

ハンドシェイクが終了しエンドポイントが1-RTT鍵を持つ前に、エンドポイントはコネクションのマイグレーションを開始してはならない(MUST NOT)。 QUICの設計はハンドシェイクの間エンドポイントのアドレスが変わらないことに依存しています。

ピアがハンドシェイク中に "disable_migration"トランスポートパラメータを送信した場合、エンドポイントはコネクションのマイグレーションを開始してはならない(MUST NOT)。 このトランスポートパラメータを送信したにもかかわらずピアが別のネットワークにマイグレーションしたことを検出したエンドポイントは、これをINVALID_MIGRATIONタイプの接続エラーとして扱います。

ピアのアドレスの変更が意図的なマイグレーションであるとは限りません。 ピアはNATリバインディングの影響を受ける可能性があります。中間装置(通常はNAT)によるアドレスの変更は、新しい送信ポートまたは新しい送信IPアドレスをフローに割り当てます。 NATリバインディングによって接続が切断されない場合は、エンドポイントはパスの検証(Section 6.10)を実行すべきです(SHOULD)。

このドキュメントでは、Section 6.12で説明されている場合を除いて、新しいクライアントアドレスへのコネクションのマイグレーションを制限しています。 クライアントはすべてのマイグレーション開始に責任を持ちます。

 サーバはそのアドレスから非プロービングパケット(Section 6.11.1を参照)を受信するまで、非プロービングパケットをクライアントアドレスに送信しません。クライアントが知らないサーバアドレスからパケットを受信した場合、クライアントはこれらのパケットを破棄してもよい(MAY)。

### 6.11.1.  Probing a New Path
新しいローカルアドレスへコネクションをマイグレーションする前に、エンドポイントはパスの検証(Section 6.10)をして新しいローカルアドレスからピア到達可能性を確認してもよい(MAY)。 パスの検証に失敗した場合は、新しいパスがこのコネクションで使用できないことを意味します。有効な代替パスが存在する限り、パスの検証に失敗しても接続は終了しません。

エンドポイントは、新しいローカルアドレスから送信されるプローブに新しいコネクションIDを使用します(Section 6.11.5を参照)。 新しいローカルアドレスを使用するエンドポイントは、少なくとも1つの新しいコネクションIDがピアで使用可能であることを確認する必要があります。これは、プローブにNEW_CONNECTION_IDフレームを含めることで実現できます。

ピアからPATH_CHALLENGEフレームを受信すると、ピアがパス上の到達可能性をプロービングしていることが示されます。 エンドポイントはSection 6.10に従ってPATH_RESPONSEを送信します。

PATH_CHALLENGE、PATH_RESPONSE、NEW_CONNECTION_ID、およびPADDINGフレームは「プロービングフレーム」であり、他のすべてのフレームは「非プロービングフレーム」です。プロービングフレームのみを含むパケットは「プロービングパケット」であり、他のフレームを含むパケットは「非プロービングパケット」です。

### 6.11.2.  Initiating Connection Migration
エンドポイントは、そのアドレスからプロービングフレーム以外のフレームを含むパケットを送信することによって、コネクションを新しいローカルアドレスにマイグレーションできます。

各エンドポイントは、接続確立中にピアのアドレスを検証します。 したがって、マイグレーションするエンドポイントは、現在のアドレスで受信できることを知っているピアに送信できます。 したがって、エンドポイントは、ピアのアドレスを最初に検証することなく、新しいローカルアドレスにマイグレーションすることができます。

マイグレーション時に、新しいパスがエンドポイントの現在の送信レートに対応していない可能性があります。 したがって、エンドポイントはSection 6.11.4で説明するように、輻輳制御をリセットします。

新しいパスには、ECN機能がない可能性があります。 したがってエンドポイントはSection 6.8で説明されているようにECN機能を検証します。

新しいパス上で送信されたデータに対するAckを受信することは、新しいアドレスからピアの到達可能性を証明する役割を果たします。 Ackはどのパスでも受信できるため、新しいパスの到達可能性は確立されないことに注意してください。 新しいパス上での帰りの到達可能性を確立するために、エンドポイントは新しいパス上でパスの有効性を確認するパス検証(Section 6.10)を同時に開始してもよい(MAY)。

### 6.11.3.  Responding to Connection Migration
ピアアドレスから非プロービングフレームを含む新しいパケットを受信することは、ピアがそのアドレスにマイグレーションしたことを示します。

このようなパケットに応じて、エンドポイントは新しいピアアドレスに後続のパケットを送信し始めなければなりません(MUST)。そしてパス検証(Section 6.10)を開始して未検証アドレスのピアの所有権を確認しなければなりません(MUST)。

エンドポイントは未検証のピアアドレスにデータを送信してもよいが(MAY)、Section 6.11.3.1とSection6.11.3.2で説明されているような潜在的な攻撃から保護しなければなりません。 そのアドレスが最近確認できてい場合は、エンドポイントはピアアドレスの検証をスキップしてもよい(MAY)。

エンドポイントは、最も高い番号の非プローブパケットに応じてパケットを送信するアドレスのみを変更します。 これにより、エンドポイントは、順番の変わったパケットを受信した場合に古いピアアドレスにパケットを送信しないようにします。

非プロービングパケットを送信するアドレスを変更した後、エンドポイントは他のアドレスのパス検証を破棄できます。

新しいピアアドレスからパケットを受信することは、ピア側のNATリバインディングの結果である可能性があります。

新しいクライアントアドレスを検証した後、サーバは新しいアドレス検証トークン(Section 6.9)をクライアントに送信すべきです(SHOULD)。

#### 6.11.3.1.  Handling Address Spoofing by a Peer
ピアが送信元アドレスを偽装して、エンドポイントが多すぎる量のデータを意図しないホストに送信する可能性があります。 エンドポイントが偽装ピアよりも非常に多くのデータを送信する場合、攻撃者はコネクションのマイグレーションを使用して犠牲者に対して生成できるデータの量を増やすことができます。

Section 6.11.3で説明したように、ピアの新しいアドレスの所有を確認するために、エンドポイントはピアの新しいアドレスを検証する必要があります。 ピアのアドレスが有効であるとみなされるまで、エンドポイントはアドレスに送信するデータのレートを制限しなければならなりません(MUST)。エンドポイントは、推定ラウンドトリップタイム([QUIC-RECOVERY]で定義されているkMinimumWindow)あたりの最小輻輳ウィンドウ量以上のデータを送信してはならない(MUST NOT)。この制限がない場合、エンドポイントは疑いのない犠牲者に対するサービス拒否攻撃のために使用される危険性があります。 エンドポイントはこのアドレスへのラウンドトリップタイム測定値を持たないので、推定値はデフォルトの初期値であるべきである([QUIC-RECOVERY]を参照)(SHOULD)。

エンドポイントがセクション6.11.3で説明したピアアドレスの検証をスキップした場合、エンドポイントは送信レートを制限する必要はありません。

#### 6.11.3.2.  Handling Address Spoofing by an On-path Attacker
経路上の攻撃者は、偽装されたパケットをコピーして偽のアドレスで元のパケットの前に届くように転送することによって、偽のコネクションのマイグレーションを引き起こす可能性があります。偽装されたアドレスを持つパケットは、コネクションのマイグレーションのために届いたと思われ、元のパケットは重複として認識され破棄されます。偽のマイグレーションの後、送信元アドレスのエンティティが、送信されたPATH_CHALLENGEフレームを読んだり応答しようとしても必要な暗号鍵を持っていないため、送信元アドレスの検証は失敗します。

このような偽のマイグレーションによってコネクションが切断するのを防ぐために、新しいピアアドレスの検証に失敗した場合、エンドポイントは最後に検証されたピアアドレスを使用するように戻らなければなりません(MUST)。

エンドポイントが最後に検証されたピアアドレスに関する状態を持たない場合、すべての接続状態を破棄してコネクションをクローズしなければならない(MUST)。 この結果、そのコネクション上の新しいパケットは通常通り処理されます。 例えばエンドポイントはそれ以上の受信パケットに対してはステートレスリセットを送ることができます(MAY)。

正当なピアアドレスからより大きいパケット番号のパケットを受信すると、別のコネクションのマイグレーションがトリガーされることに注意してください。これにより、偽のマイグレーションのアドレスの検証が中止されます。

### 6.11.4.  Loss Detection and Congestion Control
新しいパスで使用可能なキャパシティは、以前のパスと同じではない可能性があります。 以前のパスで送信されたパケットは新しいパスの輻輳制御やRTT推定に影響してはなりません(SHOULD NOT)。ピアの新しいアドレスの所有権を確認すると、エンドポイントは新しいパスの輻輳制御とRTT推定をすぐにリセットすべきです(SHOULD)。

以前の送信レートが新しいパスに対して妥当であることが合理的に確かでない限り、エンドポイントは以前のパスで使用された送信レートを使用してはならい(MUST NOT)。たとえば、クライアントのポート番号の変更は、中間装置リバンディングが起こった可能性を意味しており、パスの完全な変更ではない可能性があります。 これはヒューリスティックで決定されますが、これは完全ではないかもしれません。 新しいパスのキャパシティが大幅に減少した場合、最終的には輻輳制御の輻輳シグナルに応じして適切に送信速度を低下されます。

2つのパスが異なるラウンドトリップタイムを有することがあるので、マイグレーション中にエンドポイントがデータおよびプローブを複数のアドレスから送受信するときに正しくない順番で受信することがあります。 複数のパス上のパケットの受信者は、受信したすべてのパケットをカバーするACKフレームを送信します。

コネクションのマイグレーション中に複数のパスが使用される可能性がありますが、単一の輻輳制御コンテキストと単一の損失回復コンテキスト([QUIC-RECOVERY]で説明される)が適切な場合があります。送信者は、プローブパケットの損失検出を独立して扱い過度に輻輳制御が送信レートを低下させないようにプローブパケットの例外扱いできます。PATH_CHALLENGEが送信されると、エンドポイントは別のタイマーを設定し、対応するPATH_RESPONSEが受信されると取り消します。 PATH_RESPONSEが受信される前にタイマーがきえると、エンドポイントは新しいPATH_CHALLENGEを送信し、より長い時間タイマーを再設定することがあります。

### 6.11.5.  Privacy Implications of Connection Migration
複数のネットワークパス上で変わらないコネクションIDを使用することで、能動的観測者はそれらのパス間の通信を関連付けることができます。ネットワーク間をマイグレーションするエンドポイントは、そのピア以外のエンティティによって通信が関連付けられないようにするため、Section 6.1で説明したように、異なるローカルアドレスから送信するときに異なるコネクションIDが使用します。 これがエンドポイントにとって効果的であるためには、提供するコネクションIDが他のエンティティと紐付けられない必要があります。

これにより、異なるネットワーク上の同じコネクションからアクティビティを紐付けるためのコネクションIDの使用が不要になります。 パケット番号を保護することにより、パケット番号を使用してコネクションの関連付けもできません。 これは、タイミングやサイズといったパケットの他のプロパティを使用してのコネクションの関連付けを妨げません。

クライアントは実装依存で、いつでも新しいコネクションIDに移行することができます(MAY)。 たとえば、ネットワークの非アクティブ期間の後に、クライアントがデータの再送信を開始すると、NATリディングが発生する可能性があります。

非アクティブの期間の後にデータを送信する際、クライアントは新しいコネクションIDと送信元UDPポートを使用することで、ヒモ付の可能性を低減したい場合があります。 パケットの送信と同時にUDPポートを変更すると、パケットがコネクションのマイグレーションを引き起こす可能性があります。これにより、NATリバンディングや本当のマイグレーションが発生していないクライアントであっても、サポートするマイグレーションの仕組みが実行されます。 ポート番号を変更すると、ピアがその輻輳状態をリセットする可能性があります(Section 6.11.4を参照)。そのため、ポートはたまにしか変更しないようにすべきです(SHOULD)。

長さがゼロより大きいコネクションIDを使用するエンドポイントは、マイグレーション後にピアが同じDestination Connection IDを使用し続ける場合、そのアクティビティを関連付けできます。 以前使用されていないDestination Connection IDを持つパケットを受信したエンドポイントは、他のネットワークパスで使用されていないコネクションIDを持つパケットを送信するように変更する必要があります。ここでの目標は、異なるパスで送信されたパケットを相互に関連付けできないようにすることです。 このプライバシー要件を満たすために、マイグレーションを開始し、0より大きい長さのコネクションIDを使用するエンドポイントは、マイグレーションの前にピアに新しいコネクションIDを提供すべきです(SHOULD)。

注意：両方のエンドポイントがピアからのコネクションIDの変更に応じてコネクションIDを変更すると、無限の変更シーケンスが引き起こされます。

## 6.12.  Server's Preferred Address
QUICでは、サーバが1つのIPアドレスで接続を受け入れ、ハンドシェイクの直後にこれらのコネクションをより優先するアドレスに転送できます。 これは、複数のサーバで共有されているアドレスにクライアントが最初に接続する場合に便利ですが、コネクションの安定性を確保するために一つのユニキャストアドレスを使用することが好ましいでしょう。 このセクションでは、接続をサーバの優先アドレスに移行するためのプロトコルについて説明します。

接続中のコネクションを新しいサーバアドレスに移行するのは、今後の標準化作業となるでしょう。 クライアントがpreferred_addressトランスポートパラメータによって示されていない新しいサーバアドレスからパケットを受信した場合、クライアントはこれらのパケットを破棄すべきです(SHOULD)。

### 6.12.1.  Communicating A Preferred Address
TLSハンドシェイクにpreferred_addressトランスポートパラメータを含めることによって、サーバは優先アドレスを伝達します。

ハンドシェイクが終了すると、クライアントはpreferred_addressトランスポートパラメータで指定されたコネクションIDを使用して、サーバの優先アドレスのパス検証(Section 6.10を参照)を開始する必要があります(SHOULD)。

パス検証が成功した場合、クライアントは新しいコネクションIDを使用して、すぐに新しいサーバアドレスへ今後のパケットを送信し始めるべきで、古いサーバアドレスの使用を中止するべきです(SHOULD)。 パス検証が失敗した場合、クライアントはすべての今後のパケットをサーバの元のIPアドレスに送信し続けなければならない(MUST)。

### 6.12.2.  Responding to Connection Migration
ハンドシェイクが完了した後、サーバは優先IPアドレス宛てのパケットを受信する可能性があります。 このパケットにPATH_CHALLENGEフレームが含まれている場合、サーバはSection 6.10に従ってPATH_RESPONSEフレームを送信しますが、サーバは元のIPアドレスから他のすべてのパケットを送信し続けなければなりません。

また、サーバは自身の優先アドレスとクライアントからのプローブを受信したクライアントアドレスでパス検証を開始すべきです(SHOULD)これは、攻撃者によって開始された偽のマイグレーションを防ぐのに役立ちます。

サーバがパス検証を完了し、新しい一番大きいパケット番号を持つ非プロービングパケットを優先アドレスで受信すると、サーバは優先IPアドレスからクライアントへの送信を開始します。 古いIPアドレスでコネクションに対するパケットを受信した場合は破棄すべきです(SHOULD)。しかし、遅延パケットを処理し続けてもよい(MAY)。

### 6.12.3.  Interaction of Client Migration and Preferred Address
クライアントは、サーバの優先アドレスに移行する前にコネクションのマイグレーションを実行する必要があります。 この場合、クライアントは、クライアントの新しいアドレスからの元のサーバアドレスと優先サーバアドレスの両方に対するパス検証を同時に実行すべきです(SHOULD)。

サーバの優先アドレスのパス検証が成功した場合、クライアントは元のアドレスの検証を中止し、サーバの優先アドレスを使用するように移行する必要があります(MUST)。 サーバの優先アドレスのパス検証に失敗したがサーバの元のアドレスの検証が成功した場合、クライアントは自身の新しいアドレスから元のアドレスを使用するように移行することができます(MAY)

サーバの優先アドレスへの接続が同じクライアントアドレスからのものでない場合、サーバはSection 6.11.3.1とSection 6.11.3.2で説明した潜在的な攻撃から保護しなければなりません(MUST)。 意図的な同時のマイグレーションに加えて、クライアントのアクセスネットワークがサーバの優先アドレスに対して異なるNATバインディングを使用したために、これが発生することもあります。

サーバは異なるアドレスからプローブパケットを受信すると、クライアントの新しいアドレスへのパス検証を開始すべきです(SHOULD)。 サーバはパス検証が完了する前に、最低限の輻輳ウィンドウ分以上の非プロービングパケットを新しいアドレスに送信してはならない(MUST NOT)。

## 6.13.  Connection Termination
コネクションは、事前にネゴシエートされた期間の間アイドルになるまでオープンしたままです。 一度確立されたQUICコネクションは、次の3つの方法のいずれかで終了されます。

- アイドルタイムアウト(Section 6.13.2)
- 即時クローズ(Section 6.13.3)
- ステートレスリセット(Section 6.13.4)

### 6.13.1.  Closing and Draining Connection States
コネクションがきれいにクローズされ、遅延または順番通りでないパケットが適切に破棄されるように、クローズ中とdraining中の接続状態が存在します。 これらの状態は[QUIC-RECOVERY]で定義されている現在のRetransmission Timeout(RTO)間隔の3倍の間持続するべきです(SHOULD)。

エンドポイントは、即時クローズを開始した後にクローズ期間に入ります(Section 6.13.3)。 クローズ中にエンドポイントは、CONNECTION_CLOSEフレームまたはAPPLICATION_CLOSEフレームを含まないパケットを送信してはいけません(MUST NOT)(Section 6.13.3を参照)。

クローズ中状態では、クローズのフレームを含むパケットのみを送信することができます。 エンドポイントは、クローズのフレームを含むパケットを生成するのと、パケットがそのコネクションに属するものとして識別するのに十分な情報しか保持しません。コネクションIDとQUICバージョンは、クローズ中のコネクションのパケットを識別するのに十分な情報です。エンドポイントは他のすべての接続状態を破棄できます。エンドポイントは受信パケットのパケット保護鍵を保持して、クローズのフレームを読み込んで処理できるようにてもよい(MAY)。

ピアがクローズかdrainingのシグナルを受信すると、draining状態になります。 draining状態のエンドポイントはパケットを送信してはいけない(MUST NOT)という点以外はクローズ中状態と同様です。 一度コネクションがdraining状態になると、パケット保護鍵を保持する必要はありません。

エンドポイントは、ピアがクローズ中かdraining中なのを確認できれば、クローズ期間からdraining期間に移行することができます(MAY)。 クローズのフレームを受信すると、ステートレスリセットを受信するのには十分な確認となります。 draining期間は、クローズ期間が終了したときに終了すべきです(SHOULD)。 つまりエンドポイントは同じ終了時刻を使用でき、クローズのパケットの再送信は行いません。

クローズまたはdraining期間の終了前にコネクション状態を廃棄すると、遅れたパケットまたは順番通りでないパケットの処理が不十分になる可能性があります。 
エンドポイントはUDPソケットを閉じることができる状態といったコネクション上でパケットが遅れて届くような状態を作らないように、エンドポイントはより速いリソースのリカバリを可能にすることができるdraining期間を省略してもよい(MAY)。新しいコネクションを受け入れるためにオープンソケットを維持しているサーバは、クローズまたはdraining期間を早期に終了してはならない(SHOULD NOT)。

クローズ期間またはdraining期間が終了すると、エンドポイントはすべてのコネクション状態を破棄すべきです(SHOULD)。 この結果、コネクション上の新しいパケットは通常通り処理されます。 例えば、エンドポイントはそれ以上のどんな受信パケットにもステートレスリセットを送ってもよい(MAY)。

ステートレスリセット(Section 6.13.4)が送信された場合、drainingおよびクローズの期間は適用されません。

エンドポイントはクローズ中またはdraining中に鍵の更新処理を行うことは想定されていません。 鍵の更新により、エンドポイントがクローズ中状態からdraining状態に移行するのを防ぐことができますが、それ以外の影響はありません。

エンドポイントは新しい送信元アドレスからパケットを受信することができ、終了時にクライアントコネクションのマイグレーション(Section 6.11)を指示できます。 クローズ中状態のエンドポイントは、アドレスが検証されるまで(Section 6.01を参照)、この新しいアドレスに送信するパケット数を厳密に制限しなければならない(MUST)。 代わりに、クローズ中状態にあるサーバは新しい送信元アドレスから受信したパケットを破棄することを選択してもよい(MAY)。

### 6.13.2.  Idle Timeout
アイドルタイムアウトが有効の場合、アドバタイズされたアイドルタイムアウト(Section 6.6.1を参照)より長くアイドル状態のコネクションはクローズされます。 アイドルタイムアウトが切れると、コネクションはdraining状態になります。

各エンドポイントは、自分のアイドルタイムアウトをピアにアドバタイズします。 アイドルタイムアウトは最後に受信したパケットから開始します。 新しいアクティビティがアイドルタイムアウトを延期することを確実にするために、エンドポイントはパケットを送信するときにこのタイマーを再起動します。ACKまたはPADDING以外のフレームを含む別のパケットが送信され、他のパケットがAckまたは欠損したと宣言されていない場合、エンドポイントはアイドルタイムアウトを延期しません。ACKフレームまたはPADDINGフレームだけを含むパケットは、エンドポイントに送信する他のフレームがあるまでAckされないため、タイムアウトがリフレッシュされない可能性があります。

アイドルタイムアウトの値は非対称のこともあります。 エンドポイントによってアドバタイズされる値は、そのエンドポイントによってのみコネクションが生存しているか判別するのに使用されます。 ピアのアイドルタイムアウト期間の終了間近でパケットを送信するエンドポイントは、パケットが到着する前にそのピアがdraining状態になると、それらのパケットが破棄されるリスクがあります。 ピアがRTO([QUIC-RECOVERY]のSection 4.3.3を参照)内でタイムアウトする可能性がある場合、安全に再送できないデータを送信する前に、生存性をテストすることが推奨されます。

### 6.13.3.  Immediate Close
エンドポイントはクローズのフレーム(CONNECTION_CLOSEまたはAPPLICATION_CLOSE)を送信してすぐにコネクションを終了します。 クローズのフレームは直ちに全てのストリームをクローズします。 オープンなストリームは暗黙的にリセットされたと見なすことができます。

クローズのフレームを送信した後、エンドポイントはすぐにクローズ中状態になります。 クローズ期間中、クローズのフレームを送信するエンドポイントは受信したパケットに対して、クローズのフレームを含む別のパケットで応答すべきである(SHOULD)。

エンドポイントがクローズ中のコネクションを維持している状態を最小限に抑えるために、エンドポイントはまったく同じパケットを送信してもよい(MAY)。 しかしながら、エンドポイントは生成するクローズのフレームを含むパケットを生成する数を制限すべきです(SHOULD)。 例えば、エンドポイントは追加のパケットを送信するのにあたって、送るまでの受信パケットの数を徐々に増やしたり送信するパケット間の時間を長くすることができます。

注意：パケットの再送信を許可することは、すべてのパケットに新しいパケット番号を付与することを推奨するアドバイスと矛盾します。 新しいパケット番号で送信することは、クローズしたコネクションに関連する予想されないロスリカバリおよび輻輳制御にとって主にメリットがあります。 最後のパケットを再送することは、より状態を少なくできます。

クローズのフレームを受信した後、エンドポイントはdraining状態に入ります。クローズのフレームを受け取ったエンドポイントは、draining状態に入る前にクローズのフレームを含む単一のパケットを送信でき(MAY)、もし適切であればCONNECTION_CLOSEフレームとNO_ERRORコードを使用します。エンドポイントはそれ以上パケットを送信してはならない(MUST NOT)。そうしない場合は、いずれかのピアのクローズ期間が終了するまでクローズのフレームの交換が続く可能性があります。

即時クローズは、アプリケーションプロトコルが接続をクローズするように整えられた後に使用できます。 これは、アプリケーションプロトコルが正常なシャットダウンをネゴシエーションした後のことです。 アプリケーションプロトコルは、両方のエンドポイントがコネクションのクローズに同意するのに必要なメッセージを交換します。その後、アプリケーションはコネクションのクローズを要求します。 アプリケーションプロトコルは、適切なエラーコードを含むAPPLICATION_CLOSEメッセージを使用して終了を通知できます。

### 6.13.4.  Stateless Reset
ステートレスリセットは、コネクションの状態にアクセスできないエンドポイントの最後の手段として提供されます。 クラッシュまたは停止により正常に続行できないエンドポイントに、ピアはそのコネクションでデータを送信し続ける可能性があります。 致命的なコネクションエラーを伝えることを望むエンドポイントは、十分な状態があれば、クローズのフレームを使用しなければならない(MUST)。

この処理をサポートするために、エンドポイントによってトークンが送信されます。 トークンはいずれかのピアから送られたNEW_CONNECTION_IDフレームで送信されます。サーバはハンドシェイク中にstateless_reset_tokenトランスポートパラメータを指定できます(クライアントはトランスポートパラメータに機密保護がないためできません)。 この値は暗号化によって保護されるため、クライアントとサーバだけがこの値を知ることが出来ます。NEW_CONNECTION_IDフレームを介して送信されたトークンは、関連付けられたコネクションIDがRETIRE_CONNECTION_IDフレーム(Section 7.14)で終了すると無効になります。

処理できないパケットを受信したエンドポイントは、次のレイアウトのパケットを送信します:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+
   |0|K|1|1|0|0|0|0|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Random Octets (160..)                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                   Stateless Reset Token (128)                 +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 11: Stateless Reset Packet
```

この設計により、ステートレスリセットパケットは、可能な限り、ショートヘッダを持つ通常のパケットと区別できなくなります。

メッセージはheaderオクテットを持ち、任意の数のランダムオクテットが続き、Stateless Reset Tokenが続きます。

ステートレスリセットは、受信者によってショートヘッダを持つパケットとして解釈されます。 パケットが正しいものと見えるように、Random Octetsフィールドに少なくとも20オクテットのランダムまたは予測不可能な値を設定する必要があります。これは、許可された最大長のdestination connection ID、パケット番号、および最小ペイロードとして認められることを意図しています。Stateless Reset Tokenは、パケット保護するAEADによる最小限の伸長に対応します。 エンドポイントがより大きいAEADによる最小の伸張をもつパケット保護スキームをネゴシエーションしたならば、より多くのランダムなオクテットが必要かもしれません。

エンドポイントは、受信したパケットよりも非常に大きなステートレスリセットを送信すべきではありません(SHOULD NOT)。 エンドポイントは、有効なQUICパケットよりも小さすぎるパケットを廃棄しなければならない(MUST)。 [QUIC-TLS]で定義された一連のAEAD関数では、19オクテット未満のパケットは決して有効ではありません。

エンドポイントはロングヘッダを持つパケットに対してステートレスリセットを送信してもよい(MAY)。 これは、ステートレスリセットトークンがまだピアに利用可能でない場合には有効ではありません。 このQUICバージョンでは、ロングヘッダを持つパケットはコネクション確立時にのみ使用されます。ステートレスリセットトークンはコネクション確立が完了するか完了間近まで使用できないため、ロングヘッダを持つ未知のパケットは無視する方が効果的です。

エンドポイントはショートヘッダのパケットからSource Connection IDを判別できないため、ステートレスリセットパケットにDestination Connection IDを設定することはできません。 したがって、Destination Connection IDは以前のパケットで使用された値とは異なります。 ランダムなDestination Connection IDによって、コネクショIDはNEW_CONNECTION_IDフレーム(Section 7.13)を使用して提供された新しいコネクションIDにマイグレーションしたように見えます。

ランダム化されたコネクションIDを使用すると、次の2つの問題が発生します:

- パケットがピアに届かない可能性があります。 Destination Connection IDがピアに向かってルーティングするために重要である場合、このパケットは誤ってルーティングされる可能性があります。 そのために別のステートレスリセットを引き起こす可能性もあります(Section 6.13.4.3を参照)。 Stateless Resetが正しくルーティングされないと、エラーを迅速に検出してリカバリさせるのに効果がありません。 この場合、エンドポイントはコネクションが失敗したことを検出するために、タイマーなどの他の方法に依存する必要があります。
- ランダムに生成されたコネクションIDは、ピア以外のエンティティがステートレスリセットと識別するために使用できます。 たまに異なるコネクションIDを使用するエンドポイントでは、これに関する不確定性が生じることがあります。

パケットの最後の16オクテットはStateless Reset Tokenの値に設定されます。ステートレスリセットは、エラー状態のシグナリングには適切ではありません。 致命的なコネクションエラーを伝えたいエンドポイントは、十分な状態があればCONNECTION_CLOSEまたはAPPLICATION_CLOSEフレームを使用しなければならない(MUST)。

このステートレスリセットのデザインは、QUICバージョン1に固有です。QUICの複数バージョンをサポートするエンドポイントは、エンドポイントが対応している(または状態を失う前にサポートしていた)任意のバージョンのうちピアによって受け入れられるステートレスリセットを生成する必要があります。 QUICの新しいバージョンの設計者はこれを認識し、この設計を再利用するか、データを送信するために使用されるパケットの最後の16オクテット以外の部分を使用する必要があります。

#### 6.13.4.1.  Detecting a Stateless Reset
ショートヘッダを持つパケットを復号化できない場合、または重複パケットの場合は、エンドポイントはステートレスリセット可能性を検出します。 次に、エンドポイントはパケットの最後の16オクテットを、そのピアによって提供されたStateless Reset TokenをNEW_CONNECTION_IDフレームまたはサーバのトランスポートパラメータのものと比較します。これらの値が同一である場合、エンドポイントはdraining期間に入らなければなりません(MUST)、そしてこのコネクション上でそれ以上のパケットを送信してはいけません。 同じでなかった場合、パケットは破棄されます。

#### 6.13.4.2.  Calculating a Stateless Reset Token
ステートレスリセットトークンは、推測するのが困難でなければならない(MUST)。 ステートレスリセットトークンを作成するために、エンドポイントは作成するすべてのコネクションに対するシークレットをランダムに生成することができます[RFC4086]。ただし状態を失う可能性のあるエンドポイントに対して、クラスタ内に複数のインスタンスが存在する場合や、ストレージの問題がある場合は整合性の問題が生じます。ステートレスリセットは、ステートが失われた場合を処理するために特別に存在するため、このアプローチは最適ではありません。

エンドポイント(Section 6.1を参照)が選択したコネクションIDと静的な鍵を入力とするpreimage-resistant関数の2回の反復で生成される証拠となるデータを使用することで、同じエンドポイントのすべてのコネクションで単一の静的な鍵を使用できます。 エンドポイントはHMAC [RFC2104](例えば、HMAC(static_key、connection_id))またはHKDF [RFC5869]を使用することができます(例えば、入力となるキーマテリアルとして静的な鍵を使用し、コネクションIDをソルトとして使用する)。 この関数の出力は16オクテットに切り捨てられ、そのコネクションのStateless Reset Tokenが生成されます。

状態を失ったエンドポイントは、同じメソッドを使用して有効なステートレスリセットトークンを生成できます。 コネクションIDは、エンドポイントが受信するパケットから得られます。

この設計はエンドポイントがパケットのコネクションIDを使用してコネクションをリセットできるように、ピアが常にパケット内でコネクションIDを送信することに依存しています。 この設計を使用するエンドポイントは、すべてのコネクションに同じコネクションID長を使用するか、コネクションIDの長さをエンコードして、状態なしで回復できるようにする必要があります。 さらに、コネクションゼロの接続IDを提供してはいけません(MUST NOT)。

Stateless Reset Tokenを公開すると、どのエンティティでもコネクションを終了できるので1回しか使用できません。 Stateless Reset Tokenを選択するこの方法は、コネクションIDと静的な鍵の組み合わせが別のコネクションでは発生しないことを意味します。静的な鍵を共有するインスタンスによって同じコネクションIDが使用されている場合、または攻撃者がパケットを状態がなく同じ静的な鍵(Section 12.8を参照)を持つインスタンスにルーティングできる可能性がある場合、サービス拒否攻撃が可能です。 リセットされStateless Reset Tokenが明らかになったコネクションのコネクションIDは、静的な鍵を共有するノードでの新しいコネクションで再利用できません。

Stateless Resetパケットには暗号化保護は無いことに注意してください。

#### 6.13.4.3.  Looping
Stateless Resetの設計は、有効なパケットと区別できないようになっています。 これは、Stateless ResetがレスポンスとしてStateless Resetの送信を引き起こし、無限のやりとりにつながる可能性があることを意味します。

エンドポイントは、ループを防止するのに十分な状態を維持しない限り、送信するすべてのStateless Resetがそれをトリガーしたパケットよりも小さいことを保証しなければなりません(MUST)。 ループが発生すると、結果的にパケットが小さくなりレスポンスが起こらなくなります。

エンドポイントは送信したStateless Resetパケットの数を記憶しておき、限界に達すると新しいStateless Resetパケットの生成を停止することができます。 異なるリモートアドレスに別々の制限を用いることで、他のピアまたは他のコネクションで上限に達した場合でもStateless Resetを使用してコネクションをクローズすることができます。

Stateless Resetのサイズを推奨される最小オクテットサイズの37オクテット以下にすると、パケットがStateless Resetであることが観測者に明らかになる可能性があります。 逆に、小さなパケットに対してStateless Resetを送信することを拒否すると、Stateless Resetは非常に小さなパケットしか送信されないコネクションが壊れた場合を検出するのに役立たない可能性があります。 このような障害は、タイマーなどの他の手段によってのみ検出できます。

パケットを少なくとも38オクテットにパディングして処理できれば、エンドポイントはパケットがStateless Resetをトリガーする可能性を高めることが出来ます。

# 7.  Frame Types and Formats
Section 5で説明したように、パケットには1つ以上のフレームが含まれます。 このセクションでは、コアQUICフレームタイプのフォーマットとセマンティクスについて説明します。

## 7.1.  Variable-Length Integer Encoding
通常QUICフレームは、非負の整数値に対して可変長符号化を使用します。 このエンコーディングは、小さい数字をエンコードするのに必要なオクテットを少なくします。

QUICの可変長整数符号化は、第1オクテットの最上位2ビットを、オクテット単位の整数符号化長を底が2の対数で符号化するのに予約します。 残りはネットワークバイトオーダで整数値がエンコードされます。

つまり、整数は1、2、4、8オクテットでエンコードされ、それぞれ6、14、30、62ビットの値をエンコードできます。 Table 4は符号化をまとめたものです。

```
          +------+--------+-------------+-----------------------+
          | 2Bit | Length | Usable Bits | Range                 |
          +------+--------+-------------+-----------------------+
          | 00   | 1      | 6           | 0-63                  |
          |      |        |             |                       |
          | 01   | 2      | 14          | 0-16383               |
          |      |        |             |                       |
          | 10   | 4      | 30          | 0-1073741823          |
          |      |        |             |                       |
          | 11   | 8      | 62          | 0-4611686018427387903 |
          +------+--------+-------------+-----------------------+

                   Table 4: Summary of Integer Encodings
```

例えば、8オクテットシーケンスc2 19 7c 5e ff 14 e8 8c(16進数)は、10数値で151288809941952652にデコードされます。 4オクテットシーケンス9d 7f 3e 7dは494878333にデコードされ、 2オクテットシーケンス7b bdは15293にデコードされます。 単一のオクテット25は37にデコードされます(2オクテットシーケンス40 25と同様)。

エラーコード(Section 11.3)は整数を使用して記述されますが、この符号化は使用しません。

## 7.2.  PADDING Frame
PADDINGフレーム(type=0x00)は意味のある値をもちません。 パケットのサイズを増やすには、PADDINGフレームを使用できます。 パディングを使用して、最初のクライアントパケットを最小必要サイズに増やしたり、保護されたパケットのトラフィック分析に対して保護を提供することができます。

パディングフレームには内容がありません。 すなわちPADDINGフレームはそのフレームをPADDINGフレームとして識別する単一のオクテットからなります。

## 7.3.  RST_STREAM Frame
エンドポイントは、RST_STREAMフレーム(type=0x01)を使用してストリームを直ちに終了させることがあります。

RST_STREAMを送信した後、エンドポイントは指定したストリーム上のSTREAMフレームの送信および再送信をやめます。 RST_STREAMの受信者は、そのストリームで既に受信したデータを破棄できます。

送信専用ストリームでRST_STREAMフレームを受信したエンドポイントは、エラーPROTOCOL_VIOLATIONで接続を終了しなければならない(MUST)。

RST_STREAMフレームは次のとおりです:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Application Error Code (16)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       Final Offset (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

フィールドは:

- Stream ID: 終了するストリームのストリームIDを可変長整数でエンコードします。
- Application Protocol Error Code: ストリームがクローズされる理由を示す16ビットアプリケーションプロトコルエラーコード(Section 11.4を参照)。
- Final Offset: RST_STREAM送信側がこのストリームに書き込むデータの最後のバイトオフセットを示す可変長整数。

## 7.4.  CONNECTION_CLOSE frame
エンドポイントはCONNECTION_CLOSEフレーム(type=0x02)を送信して、コネクションがクローズされることをピアに通知します。 CONNECTION_CLOSEは、QUICレイヤのエラー、またはエラーがないことをNO_ERRORコードで通知するために使用されます。

明示的にクローズされていないオープンなストリームがある場合、それらはコネクションがクローズされたときに暗黙的にクローズされます。

CONNECTION_CLOSEフレームは次のとおりです:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Error Code (16)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Frame Type (i)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Reason Phrase Length (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Reason Phrase (*)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

CONNECTION_CLOSEフレームのフィールドは次のとおりです:

- Error Code: コネクションをクローズする理由を示す16ビットのエラーコード。 CONNECTION_CLOSEは、Section 11.3.で定義されたスペースのコードを使用します。
- Frame Type: エラーを引き起こしたフレームのタイプをエンコードする可変長整数。 フレームタイプが不明な場合、値0(PADDINGフレームに相当)が使用されます。
- Reason Phrase Length: 理由句の長さをバイト単位で指定する可変長整数。 CONNECTION_CLOSEフレームはパケット間で分割できないので、実際にはパケットサイズの制限により、理由句で使用可能なスペースも制限されます。
- Reason Phrase: コネクションがクローズされた理由を人間が読むことができる説明文。 送信者がエラーコードよりさらに詳細を提示しないことを選択した場合、ここは長さゼロになる可能性があります。 UTF-8でエンコードされた文字列[RFC3629]であるべきです(SHOULD)。

## 7.5.  APPLICATION_CLOSE frame
APPLICATION_CLOSEフレーム(type=0x03)は、QUICを使用するプロトコルのエラーを通知するために使用されます。

APPLICATION_CLOSEフレームは次のとおりです:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Error Code (16)     |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Reason Phrase Length (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Reason Phrase (*)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

APPLICATION_CLOSEフレームのフィールドは次のとおりです:

- Error Code: このコネクションをクローズする理由を示す16ビットのエラーコード。 APPLICATION_CLOSEは、アプリケーションプロトコルエラーコードスペースのコードを使用します(Section 11.4を参照)。
- Reason Phrase Length: このフィールドの形式と意味は、CONNECTION_CLOSEのReason Phrase Lengthフィールドと同じです。
- Reason Phrase: このフィールドの形式と意味は、CONNECTION_CLOSEのReason Phraseフィールドと同じです。

APPLICATION_CLOSEは、CONNECTION_CLOSEフレーム(Section 7.4)と同様のフォーマットとセマンティクスを持っています。 Error Codeフィールドのセマンティクスと、Frame Typeフィールドの省略とは別として、両方のフレームはコネクションをクローズするために使用されます。

## 7.6.  MAX_DATA Frame
MAX_DATAフレーム(type=0x04)は、フロー制御で使用され、コネクション全体で送信できる最大量のデータをピアに通知します。

このフレームは次のとおりです:
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Maximum Data (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

MAX_DATAフレームのフィールドは次のとおりです:

- Maximum Data: コネクション全体で送信できるデータの最大量を示すオクテット単位の可変長整数。

STREAMフレームで送信されるすべてのデータは、この制限に対してカウントされます。 終了状態のストリームを含む、すべてのストリーム上で最大の受信オフセットの合計は、受信側にアドバタイズされた値を超えてはいけません(MUST NOT)。初期上限を変更した場合を除いて(Section 6.6.2を参照)、エンドポイントは送信した最大データ値よりも多くのデータを受信した場合には、FLOW_CONTROL_ERRORエラーでコネクションを終了しなければならない(MUST)。

## 7.7.  MAX_STREAM_DATA Frame
MAX_STREAM_DATAフレーム(type=0x05)は、ストリーム上で送信できる最大データ量をピアに通知するためにフロー制御で使用されます。

受信専用ストリームでMAX_STREAM_DATAフレームを受信したエンドポイントは、エラーPROTOCOL_VIOLATIONでコネクションを終了する必要があります(MUST)。

オープンしていない送信専用ストリームでMAX_STREAM_DATAフレームを受信したエンドポイントは、エラーPROTOCOL_VIOLATIONで接続を終了しなければならない(MUST)。

エンドポイントは、オープンしていない双方向ストリームでMAX_STREAM_DATAフレームを問題なく受け取ることができることに注意してください。

このフレームは次のとおりです:
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Maximum Stream Data (i)                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

MAX_STREAM_DATAフレームのフィールドは次のとおりです:

- Stream ID: 可変長整数としてエンコードされた、影響を受けるストリームのストリームID。
- Maximum Stream Data: 指定されたストリーム上で送信できるデータの最大量を示すオクテット単位の可変長整数。

上限に対してデータをカウントする際、エンドポイントはストリーム上で送受信されるデータの最大受信オフセットを考慮に入れます。 ロスまたは順番の入れ替わりは、ストリーム上で受信した最大のオフセットが、そのストリームで受信されたデータの合計サイズよりも大きくなる可能性があることを意味します。 受信したSTREAMフレームが、受信した最大のオフセット値を増加させないこともあります。

ストリーム上で送信されるデータは、受信側によってアドバタイズされた最も大きいMaximum Stream Dataを超えてはならない(MUST NOT)。 影響を受けるストリームに対して送信した最も大きいMaximum Stream Dataよりも多くのデータを受信した場合、エンドポイントはFLOW_CONTROL_ERRORエラーでコネクションを終了しなければならない(MUST)。

## 7.8.  MAX_STREAM_ID Frame
MAX_STREAM_IDフレーム(type=0x06)は、オープンが許可されたストリームIDの最大値をぴあに通知します。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Maximum Stream ID (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

MAX_STREAM_IDフレームのフィールドは次のとおりです: 

- Maximum Stream ID:　可変長整数として符号化されたコネクションの単方向または双方向ピア開始ストリームIDの最大ID。 この制限は、ストリームIDの下位2番目のビットが1の場合は単方向ストリームに適用され、0の場合は双方向ストリームに適用されます。

ロスまたは順番の入れ替わりは、クライアントが以前に受信したよりも低いストリーム制限を示すMAX_STREAM_IDフレームを受信する可能性があることを意味します。 最大ストリームIDを増加させないMAX_STREAM_IDフレームは無視しなければならない(MUST)。

ピアは、受信した最大のMaximum Stream IDよりも高いストリームIDを持つストリームを開始してはならない(MUST NOT)。 これが初期上限(Section 6.6.2)の変更の結果でない限り、エンドポイントが送信したよりも高いストリームIDを持つストリームをピアが開始するならば、エンドポイントはSTREAM_ID_ERRORエラーでコネクションを終了しなければならない(MUST)。

## 7.9.  PING Frame
エンドポイントはPINGフレーム(type=0x07)を使用して、ピアがまだ生存していることを確認したり、ピアへの到達性をチェックしたりできます。 PINGフレームには、追加のフィールドはありません。

PINGフレームの受信者は、単にこのフレームを含むパケットをAckする必要があります。PINGフレームは、アプリケーションまたはアプリケーションプロトコルがコネクションのタイムアウトを防止したいときにコネクションを維持するのに使用できます。 アプリケーションプロトコルは、PINGの生成が推奨される条件に関するガイダンスを提供すべきです(SHOULD)。

## 7.10.  BLOCKED Frame
送信者は、コネクションレベルのフロー制御( Section 10.2.1を参照)のためにデータを送信したいができないときは、BLOCKEDフレーム(タイプ= 0x08)を送信すべきである(SHOULD)。 BLOCKEDフレームは、フロー制御アルゴリズムの調整へのインプットとして使用できます(Section 10.1.2を参照)。

BLOCKEDフレームは次のとおりです:
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Offset (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

BLOCKEDフレームには1つのフィールドが含まれています:

- Offset: ブロッキングが発生したコネクションレベルのオフセットを示す可変長の整数。

## 7.11.  STREAM_BLOCKED Frame
送信者は、ストリームレベルのフロー制御のためにデータを送信したいができないときは、STREAM_BLOCKEDフレーム(type=0x09)を送信すべきである(SHOULD)。 このフレームは、BLOCKED(Section 7.10)に類似しています。

送信専用ストリームのSTREAM_BLOCKEDフレームを受信したエンドポイントは、エラーPROTOCOL_VIOLATIONでコネクションを終了しなければならない(MUST)。

STREAM_BLOCKEDフレームは次のとおりです:
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Offset (i)                          ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
STREAM_BLOCKEDフレームには2つのフィールドがあります:

- Stream ID: フロー制御がブロックしているストリームを示す可変長整数。
- Offset: ブロッキングが発生したストリームのオフセットを示す可変長整数。

## 7.12.  STREAM_ID_BLOCKED Frame
送信者は、ストリームをオープンしようとするが、ピアによって設定された最大のストリームIDの制限(Section 7.8を参照)によってできない場合STREAM_ID_BLOCKEDフレーム(type=0x0a)を送信できます。 これはストリームをオープンしませんが、ストリームの制限によりストリームの作成が妨げられ、新しいストリームが必要であることをピアに通知し、

STREAM_ID_BLOCKEDフレームは次のとおりです: 
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

STREAM_ID_BLOCKEDフレームには、1つのフィールドが含まれています。

- Stream ID: 送信者がオープンを許可された最も大きいストリームIDを示す可変長整数。

## 7.13.  NEW_CONNECTION_ID Frame
エンドポイントはNEW_CONNECTION_IDフレーム(type=0x0b)を送信して、コネクションを移行する際に関連付けを行えないようにするのに使用できる代わりのコネクションIDをピアに提供します(Section 6.11.5を参照)。

NEW_CONNECTION_IDフレームは次のとおりです:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |   Length (8)  |            Sequence Number (i)              ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Connection ID (32..144)                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                                                               +
   |                                                               |
   +                   Stateless Reset Token (128)                 +
   |                                                               |
   +                                                               +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

フィールドは:

- Length: コネクションIDの長さを示す8ビットの符号なし整数。 4未満または18より大きい値は無効であり、PROTOCOL_VIOLATIONタイプのコネクションエラーとして扱われなければなりません(MUST)。
- Sequence Number: 送信者がコネクションIDに割り当てたシーケンス番号。Section 6.1.1参照。
- Connection ID: 指定された長さのコネクションID
- Stateless Reset Token: 関連付けられたコネクションIDが使用されたときにステートレスリセットに使用される128ビットの値(Section 6.13.4を参照)。

現在、ピアが長さ0のDestination Connection IDを持つパケットを送信することをエンドポイントが要求する場合、エンドポイントはこのフレームを送信してはならない(MUST NOT)。コネクションIDの長さをゼロに変更すると、コネクションIDの値が変更されたのを識別することが困難になります。長さ0のDestination Connection IDを持つパケットを送信しているエンドポイントは、NEW_CONNECTION_IDフレームの受信をPROTOCOL_VIOLATIONタイプのコネクションエラーとして扱わなければならない(MUST)。

送信エラー、タイムアウト、再送信により、同じNEW_CONNECTION_IDフレームが複数回受信される可能性があります。 同じフレームを複数回受信することは、接続エラーとして扱われてはなりません(MUST NOT)。 受信者は、NEW_CONNECTION_IDフレーム内にあるシーケンス番号を使用して、古いものからの新しいコネクションIDを識別することができます。

エンドポイントは以前に発行されたコネクションIDを異なるステートレスリセットトークンまたは異なるシーケンス番号で繰り返すNEW_CONNECTION_IDフレームを受信した場合、エンドポイントはその受信をPROTOCOL_VIOLATIONタイプのコネクションエラーとして扱いしてよい(MAY)。

## 7.14.  RETIRE_CONNECTION_ID Frame
エンドポイントはRETIRE_CONNECTION_IDフレーム(type=0x1b)を送信して、ピアによって発行されたコネクションIDを使用しないことを示します。 これには、ハンドシェイク中に提供されたコネクションIDが含まれます。 RETIRE_CONNECTION_IDフレームを送信することは、ピアへ将来に使用するための追加のコネクションIDを要求する(Section 6.1を参照)という機能もあります。 NEW_CONNECTION_IDフレーム(Section 7.13)を使用して、新しいコネクションIDをピアに配信できます。

コネクションIDをリタイアさせると、そのコネクションIDに関連付けられたステートレスリセットトークンは無効になります。

RETIRE_CONNECTION_IDフレームは次のとおりです:
```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      Sequence Number (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

フィールドは:

- Sequence Number: リタイアさせるコネクションIDのシーケンス番号。Section 6.1.2を参照。

以前にピアに送信されたシーケンス番号より大きいシーケンス番号を含むRETIRE_CONNECTION_IDフレームの受信は、タイプPROTOCOL_VIOLATIONのコネクションエラーとしてもよい(MAY)。

ピアによってピアの長さ0のコネクションIDが指定されている場合、エンドポイントはこのフレームを送信できません。 長さ0のコネクションIDを提供するエンドポイントは、RETIRE_CONNECTION_IDフレームの受信をタイプPROTOCOL_VIOLATIONのコネクションエラーとして処理しなければならない(MUST)。

## 7.15.  STOP_SENDING Frame
エンドポイントはSTOP_SENDINGフレーム(type = 0x0c)を使用して、アプリケーションの要求で受信データが破棄されていることを通知することができます。 これはシグナルを送り、ピアにストリーム上の送信を直ちに終了させます。

STOP_SENDINGフレームの受信は、存在し、「Ready」状態ではない送信ストリームに対してのみ有効です(9.2.1項を参照)。「Ready」または存在しない送信ストリーム上でSTOP_SENDINGフレームを受信すると、タイプがPROTOCOL_VIOLATIONのコネクションエラーとして扱われなければならない(MUST)。 受信専用ストリームのSTOP_SENDINGフレームを受信したエンドポイントは、エラーPROTOCOL_VIOLATIONでコネクションを終了しなければならない(MUST)。

STOP_SENDINGフレームは次のとおりです:
```

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream ID (i)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Application Error Code (16)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

フィールドは:

- Stream ID: 無視されるストリームのストリームIDを示す可変長整数。
- Application Error Code: 16ビットのアプリケーション指定の送信者がストリームを無視している理由(Section 11.4を参照)。

## 7.16.  ACK Frame
受信者は、ACKフレーム(タイプ0x1aと0x1b)を送信して、受信者が受信して処理したパケットを送信者に通知します。 ACKフレームは、1つまたは複数のACKブロックを含みます。 ACKブロックはAckするパケットの範囲です。 フレームタイプが0x1bの場合、ACKフレームには、この時点までコネクションで受信したECNマークの合計も含まれます。

QUICのAckは取消不能です。 ひとたびAckされると、パケットは将来のACKフレームで記載されなくてもAckされたままです。 これはTCP SACK([RFC2018])とは異なります。

送信者は、異なるパケット番号空間では同じパケット番号を再使用することが想定されます。ACKフレームは、送信者が送信したパケットと同じ番号空間のパケット番号をAckするだけです。

Version NegotiationとRetry パケットは、パケット番号が含まれていないため、Ackできません。 ACKフレームを利用するのではなく、これらのパケットはクライアントによって送信された次のInitialパケットによって暗黙的にAckされます。

ACKフレームを以下に示します:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Largest Acknowledged (i)                ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          ACK Delay (i)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                       ACK Block Count (i)                   ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          ACK Blocks (*)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         [ECN Section]                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                        Figure 12: ACK Frame Format
```

ACKフレームのフィールドは次のとおりです:
- Largest Acknowledged: ピアがAckしている最大のパケット番号を表す可変長整数。 この値は、通常ピアがACKフレームを生成する前に受信したパケット番号の最大値です。 QUICロングヘッダまたはショートヘッダのパケット番号とは異なり、ACKフレームの値は切りつめられません。
- ACK Delay: このACKが送信されたときに、Largest Acknowledgedフィールドに示されているAckされた最大のパケットがこのピアによって受信されてからの時間を示すマイクロ秒単位の可変長整数。 ACK Delayフィールドの値は、符号化された値にACKフレームの送信者によって設定された「ack_delay_exponent」トランスポートパラメータを指数とする2の冪乗
に比例します。"ack_delay_exponent"のデフォルトは3で、乗数は8です(Section 6.6.1を参照)。 このようにスケーリングすることで、より低い解像度を犠牲にしてより短い符号化で、より広い範囲の値が可能になります。
- ACK Block Count: First ACK Blockの後のAdditional ACK Block(およびGap)フィールドの数を指定する可変長整数。
- ACK Blocks: 正常に受信されたパケット番号のブロックが1つ以上含まれています(Section 7.16.1を参照)。

### 7.16.1.  ACK Block Section
ACKブロックセクションは、パケット番号の降順にGapとACK Blockフィールドが交互になっています。 最初のAck Blockフィールドの後ろには、可変数のGapとAdditional ACK Blockが交互に続きます。 ギャップおよび追加のACKブロックフィールドの数はACK Block Countによって決定されます。

Gap及びACKACK Blockは、効率のために相対的な整数符号化を使用する。 符号化された各値は正であるが、値は引かれていくので、各ACK Blockは徐々に低い番号のパケットを記載していきます。連続するパケットの範囲が小さい限り、可変長整数符号化は、各範囲を少数のオクテットで表現できることを保証します。

ACKフレームは、ECNフィードバックを示すために最下位ビット(つまり、タイプ0x1b)を使用し、パケットのIPヘッダにECT(0)、ECT(1)、またはCEのECNコードポイントを持つパケットを受信したことを報告します。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                      First ACK Block (i)                    ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Gap (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Additional ACK Block (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Gap (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Additional ACK Block (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
                                  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             Gap (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Additional ACK Block (i)                 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                       Figure 13: ACK Block Section
```

各ACK Blockはそのブロックで一番大きいパケット番号からのAckするパケットの数を指定し、連続したパケット領域をAckします。値0は、最大のパケット番号だけがAckされることを示します。 
ACK Blockの値を大きくするとより広い領域を示し、領域内の最小パケット番号はより低い値になります。 したがって、ACKのために最大のパケット番号が与えられた場合、最小の値は次の式によって決定されます:

```
  smallest = largest - ack_block
```

ACK BlockによってAckされるパケットの範囲には、最小のパケット番号から最大の番号までの範囲が含まれます。最初のACKブロックの最大値は、Largest Acknowledgedフィールドによって決定されます。 追加のACKブロックの最大値は、すべての先行するACKブロックおよびギャップのサイズを累積的に減算することによって決定されます。

各GapはAckされていないパケットの範囲を示します。 ギャップ内のパケットの数は、 Gapの符号化された値よりも1つ多い。

Gapフィールドの値は、次の式を使用して、ギャップに続くACK Blockの最大パケット番号値を計算します。

```
largest = previous_smallest - gap - 2
```

ACK Blockの最大または最小パケット数の計算値が負である場合、エンドポイントはACKフレームのエラーを示すタイプFRAME_ENCODING_ERRORのコネクションエラーとしなければならない(MUST)。

ACK Blockセクションのフィールドは次のとおりです:

- First ACK Block:　Largest Acknowledgedに続くAckされる連続したパケットの数を示す可変長整数。
- Gap (repeated): 直前のACKブロックのパケット番号より1小さいところから連続するAckされないパケットの数を示す可変長整数。
- Additional ACK Block (repeated): 直前のギャップによって決定された最大のパケット番号から続く連続したAckされるパケットの数を示す可変長整数。

## 7.16.2.  ECN section
ECNセクションは、ACKフレームタイプのバイトが0x1bの場合にのみパースする必要があります。 ECNセクションは、以下に示すように3つのECNカウンターで構成されています。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECT(0) Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECT(1) Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        ECN-CE Count (i)                     ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

- ECT(0) Count: 受信した ECT(0)コードポイントを持つパケットの総数を表す可変長整数。
- ECT(1) Count: 受信した ECT(1)コードポイントを持つパケットの総数を表す可変長整数。
- CE Count: 受信した CEコードポイントを持つパケットの総数を表す可変長整数。

## 7.16.3.  Sending ACK Frames
実装はACKフレームとPADDINGフレームだけを含むパケットに対してACKフレームを含むパケットを生成してはいけません(MUST NOT)。しかし、他のパケットに対してACKフレームを送信するときは、ACKフレームとPADDINGフレームだけを含むパケットをAckしなければならない(MUST)。

実装はACKフレームとPADDINGフレーム以外のフレームを含む受信パケットごとにACKフレームのみを含むパケットを複数送信してはいけません(MUST NOT)。 ACKとPADDING以外のフレームを含むパケットは、直ちにAckされなければいけません(MUST)。もしくは遅延ACKタイマーが期限切れになった時にAckされなければなりません(MUST)。

受信者の遅延ACKタイマーは、現在のRTT推定値または "max_ack_delay"トランスポートパラメータで示す値を超えてはならなりません(SHOULD NOT)。 これにより、Ackを必要とするパケットが受信されたときに、少なくともRTTごとにAck応答が送信されることが保証されます。 送信者は、タイマーベースの再送タイムアウトを決定する際に、受信側の "max_ack_delay"値を使用できます。

Ackは複数のパケットが一緒に受信されない限り、Ackを必要とする2つのパケットを受信したらすぐにAckを送信するべきです(SHOULD)。

送信者がまだ受信していないACK Blocksに限定するために、受信者は、どのACKフレームがそのピアによってAckされたかを追跡すべきです(SHOULD)。 ACKフレームがAckされると、それがAckしたパケットは再びAckされるべきではありません(SHOULD NOT)。

ACKフレームのみのパケットに対してACKフレームは送信されないため、ACKフレームのみを送信した受信者は、送信者がACKフレーム以外のフレームをそのパケットに含めた場合に、受診者は最初のACKに対するAckを受信します。送信者は、可能であれば、他のフレームとACKフレームを同梱すべきです(SHOULD)。

エンドポイントは同じパケット番号空間のパケットでACKフレームを送信することによって、特定のパケット番号空間で送信されたパケットのみをAckできます。

受信者の状態またはACKフレームのサイズを制限するために、受信者は送信するACK Blocksの数を制限してもよい(MAY)。 受信者は送信者が不必要にいくつかのデータを再送する可能性があるということを理解して、ACKフレームのAckを受信しないことでこれを行うことができます。標準のQUIC [QUIC-RECOVERY]アルゴリズムは、十分新しいパケットがAck後に失われたパケットを宣言します。 したがって受信者は、新たに受信したパケットより過去に受信したパケットを優先してAckすべきです(SHOULD)。

### 7.16.4.  ACK Frames and Packet Protection
ACKフレームは、Ackされるパケットと同じパケット番号空間を持つパケットで送信しなければなりません(Section 4.8を参照)(MUST)。 例えば、1-RTTキーで保護されているパケットは、1-RTTキーで保護されているパケットでAckされなければならない(MUST)。

クライアントが0-RTTパケット保護で送信するパケットは、1-RTT鍵で保護されたパケットでサーバによってAckされなければならない(MUST)。これは、サーバの暗号化ハンドシェイクメッセージが遅延または失われた場合、クライアントがこれらのAckを使用できないことを意味します。サーバによって送信された1-RTT鍵によって保護されている他のデータにも同じ制限が適用されます。

エンドポイントは、CRYPTOフレームを含むパケットには、少ない遅延でAckを送信すべきです(SHOULD)。 [QUIC-RECOVERY]のSection 4.3.1を参照してください。

## 7.17.  PATH_CHALLENGE Frame
エンドポイントはPATH_CHALLENGEフレーム(type = 0x0e)を使用して、ピアへの到達性をチェックし、コネクションのマイグレーション中にパス検証を行うことができます。

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                                                               |
   +                            Data (8)                           +
   |                                                               |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

Data: この8バイトのフィールドに任意のデータを持ちます

PATH_CHALLENGEフレームは推測が難しい8オクテットのデータを含み、値を推測するよりパケットを受信するほうがより容易であることが保証されます。

このフレームの受信者は同じデータを含むPATH_RESPONSEフレーム((Section 7.18)を作らなければなりません(MUST)。

## 7.18.  PATH_RESPONSE Frame
PATH_RESPONSEフレーム(type=0x0f)は、PATH_CHALLENGEフレームに応じて送信されます。 そのフォーマットはPATH_CHALLENGEフレーム(Section 7.17)と同じです。

PATH_RESPONSEフレームの内容が、以前にエンドポイントによって送信されたPATH_CHALLENGEフレームの内容と一致しない場合、エンドポイントはタイプPROTOCOL_VIOLATIONのコネクションエラーとしてもよい(MAY)。

## 7.19.  NEW_TOKEN frame
サーバはNEW_TOKENフレーム(type=0x19)を送って、将来のコネクションにおいてInitialパケットのヘッダで送信されるトークンをクライアントに提供します。

NEW_TOKENフレームは次のとおりです:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Token Length (i)  ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                            Token (*)                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

NEW_TOKENフレームのフィールドは次のとおりです:

- Token Length: トークンの長さをバイト単位で指定する可変長整数。
- Token: クライアントが将来のInitialパケットで使用する意味のないデータ列です。

## 7.20.  STREAM Frames
STREAMフレームは暗黙的にストリームを作成し、ストリームデータを伝送します。 STREAMフレームは、0b00010XXX(0x10から0x17までの値のセット)の形式をとります。 フレームタイプの3つの下位ビットの値によって、フレームに存在するフィールドが決まります。

- フレームタイプのOFFビット(0x04)は、Offsetフィールドが存在することを示します。 1に設定すると、Offsetフィールドが存在します。0に設定すると、Offsetフィールドは存在せず、ストリームデータはオフセット0で開始されます(つまり、フレームにはストリームの最初のオクテット、またはデータを持たないストリームの終わりです)。
- フレームタイプのLENビット(0x02)は、長さフィールドが存在することを示します。 このビットが0に設定されている場合、Lengthフィールドは存在せず、Stream Dataフィールドはパケットの最後までつづきます。 このビットを1に設定すると、Lengthフィールドが存在します。
- フレームタイプのFINビット(0x01)は、ストリームの最終オフセットを含むフレームでのみ設定されます。 このビットを設定すると、このフレームがストリームの最後であることを示します。

エンドポイントが送信専用ストリームでSTREAMフレームを受信した場合、エラーPROTOCOL_VIOLATIONでコネクションを終了しなければならない(MUST)。

STREAMフレームを以下に示します:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         Stream ID (i)                       ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         [Offset (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                         [Length (i)]                        ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Stream Data (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 14: STREAM Frame Format
```

STREAMフレームには次のフィールドがあります:

- Stream ID: ストリームのストリームIDを示す可変長整数(Section 9.1を参照)。
- Offset: このSTREAMフレーム内のデータのストリーム内バイトオフセットを指定する可変長整数。 このフィールドは、OFFビットが1に設定されている場合に存在します。Offsetフィールドがない場合、オフセットは0です。
- Length: このSTREAMフレーム内のStream Dataフィールドの長さを指定する可変長整数。 このフィールドは、LENビットが1に設定されている場合に存在します。LENビットが0に設定されている場合、Stream Dataフィールドはパケット内の残りのすべてのオクテットとなります。
- Stream Data:　指定されたストリームから転送されるバイト列。

Stream Dataフィールドの長さが0の場合、STREAMフレーム内のオフセットは、送信される次のバイトのオフセットになります。

ストリームの最初のバイトはオフセットが0です。ストリームに配信される最大のオフセット、つまり再構成されたオフセットとデータ長の合計は2 ^ 62未満でなければなりません(MUST)。

ストリームの多重化は、複数のストリームのSTREAMフレームを1つ以上のQUICパケットにインタリーブすることによって行われます。 1つのQUICパケットは、1つ以上のストリームのSTREAMフレームを複数含むことができます。

実装上の注意：QUICのメリットの1つは、複数ストリームにわたるヘッド・オブ・ライン・ブロッキングを避けることです。パケットロスが発生すると、そのパケットのデータを含むストリームのみがブロックされ、再送が受信されるのを待っている間に、他のストリームは処理を続けられます。複数のストリームのデータが1つのQUICパケットにまとめられている場合、そのパケットの欠損はそれらすべてのストリームの処理がブロックすることに注意してください。 したがって、実装は、伝送効率を損なわないように、パケットに最大までデータを詰め込まず、必要な数のストリームを送信パケットにバンドルすることを推奨します。

## 7.21.  CRYPTO Frame
CRYPTOフレーム(type=0x18)は、暗号ハンドシェイクメッセージを送信するために使用されます。 CRYPTOフレームはすべてのパケットタイプで送信できます。 CRYPTOフレームは、暗号プロトコルに中所通りのバイトストリームを提供します。    CRYPTOフレームは、ストリーム識別子を持たないことを除いて、STREAMフレームと機能的に同一です。 これらはフロー制御されません。 オフセットのオプション、長さのオプション、終端のしるしとなるオプションは持ちません。

CRYPTOフレームを以下に示します:

```
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Offset (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                          Length (i)                         ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                        Crypto Data (*)                      ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 15: CRYPTO Frame Format
```

CRYPTOフレームには、次のフィールドがあります:

- Offset: このCRYPTOフレーム内のデータストリーム内のバイトオフセットを指定する可変長の整数。
- Length: このCRYPTOフレーム内のCrypto Dataフィールドの長さを指定する可変長整数。
- Crypto Data: 暗号メッセージデータ。

各暗号化レベルにはオフセットの0から始まる暗号ハンドシェイクデータのフローがあります。これは、各暗号化レベルは別々のCRYPTOデータストリームとして扱われることを意味します。

データがどのストリームに属するかを示すストリームIDを含むSTREAMフレームとは異なり、CRYPTOフレームは暗号化レベルごとに1つのストリームでデータを転送します。 ストリームに明示的な終了がないため、CRYPTOフレームにはFINビットがありません。

# 8.  Packetization and Reliability

送信者は、1つまたは複数のフレームを1つのQUICパケットにバンドルします(Section 5を参照)。送信者はQUICパケットにできるだけ多くのフレームを入れることによって、パケットごとの帯域と計算コストを最小にすべきです(SHOULD)。送信者はデータを最大限もってはいないパケットを送信する前に、複数のフレームを入れるために短い時間待って、多くの小さなパケットを送信しないようにすることができます(MAY)。
この待ち時間は実装によって決定されます。実装は遅延させることに関して保守的に慎重になるべきです。遅れが発生すると、アプリケーションが認識する待ち時間が長くなる可能性があるためです。

## 8.1.  Packet Processing and Acknowledgment
パケット保護が正常に解除されパケットに含まれるすべてのフレームが処理されるまで、パケットはAckされてはならない(MUST NOT)。 STREAMフレームの場合、データがアプリケーションプロトコルによって受信される準備としてエンキューされていることを意味しますが、データが渡され使用されていることは必要ではありません。

パケットが完全に処理されると、受信者は受信パケットのパケット番号を含む1つ以上のACKフレームを送信することによって受信をAckします。無限のフィードバックループとならないように、エンドポイントは受信パケットしたパケットにギャップがあっても、ACKフレームまたはPADDINGフレームだけを含むパケットに大したACKフレームを送信してはいけません(MUST NOT)。

エンドポイントは次に送るACKフレームで、ACKフレームかPADDINGフレームだけを含むパケットをAckしなければなりません(MUST)。

PADDINGフレームは受信者からのACKフレームを引き出さないが、輻輳制御目的のために転送中であるとみなされる[QUIC-RECOVERY]。 PADDINGフレームだけを送信すると、輻輳制御装置([QUIC-RECOVERY]で説明される)によって送信者が制限を受ける可能性があります。 したがって、受信側からAckを引き出すために、送信側は他のフレームにPADDINGフレームを加えて送信されることを確実にすべきです(SHOULD)。

Ackを生成する頻度の戦略と影響については、[QUIC-RECOVERY]で詳しく説明しています。

## 8.2.  Retransmission of Information
ロスしたと判断されたQUICパケットは、全ては再送されません。 ロスしたパケット内に含まれるフレームについても同様です。 その代わりに、フレームで転送される可能性のある情報は、必要に応じて新しいフレームで再び送信されます。

新しいフレームとパケットは、ロスしたと判断される情報を転送するために使用されます。 一般に、情報を含むパケットが失われたと判断されたときに情報が再度送信され、その情報を含むパケットがAckされたときに送信は停止されます。

- CRYPTOフレームで送信されたデータは、[QUIC-RECOVERY]の規則に従って、すべてのデータがAckされるか、またはピアがデータを受信したことを暗黙的に知るまで再送されます。
- STREAMフレームで送信されたアプリケーションデータは、エンドポイントがそのストリームに対してRST_STREAMを送信していない限り、新しいSTREAMフレームで再送信されます。 エンドポイントがRST_STREAMフレームを送信すると、それ以上のSTREAMフレームは必要ありません。
- ACKフレームで最新のAckが送信されます。 ACKフレームはSection 7.16.3で説明されているようにAckしてないものへのAckだけを含むべきです(SHOULD)。
- RST_STREAMフレームが送信されることによるストリーム通信のキャンセルは、Ackされるまで、またはピアによってすべてのストリームデータがAckされるまで(すなわち、送信ストリームで"Recvd"または"Data Recvd"状態に達するまで)送信されます。 RST_STREAMフレームの内容は、再度送信されたときに変更してはならない(MUST NOT)。
- 同様に、STOP_SENDINGフレームによるストリーム送信を中止する要求は、受信ストリームが"Data Recvd"状態または"Reset Recvd"状態に入るまで送信されます。Section 9.3を参照してください。
- CONNECTION_CLOSEフレームとAPPLICATION_CLOSEフレームを使用してのコネクションクローズのシグナルは、パケットロスが検出されたときには送信されませんが、Section 6.13で説明されます。
- 現在のコネクションの最大データはMAX_DATAフレームで送信されます。最後に送信されたMAX_DATAフレームを含むパケットが失われたと宣言された場合、またはエンドポイントが上限を更新することを決めた場合は更新された値がMAX_DATAフレームで送信されます。 上限が頻繁に増加し、不必要に多くのMAX_DATAフレームが送信されるため、このフレームをあまりにも頻繁に送信しないように注意する必要があります。
- 現在の最大ストリームデータオフセットは、MAX_STREAM_DATAフレームで送信されます。 MAX_DATAと同様に、ストリームの最新のMAX_STREAM_DATAフレームを含むパケットがロスしたとき、または上限が更新されたときに、フレームがあまりにも頻繁に送信されないように注意して更新された値が送信されます。 受信ストリームが "Size Known"状態になると、エンドポイントはMAX_STREAM_DATAフレームの送信を停止すべきです(SHOULD)。
- 指定されたタイプのストリームの最大ストリームIDは、MAX_STREAM_IDフレームで送信されます。 MAX_DATAと同様に、ストリームタイプフレームの最新のMAX_STREAM_IDを含むパケットが失われたと宣言されたとき、または上限が更新されたときにフレームがあまりにも頻繁に送信されないように注意して更新された値が送信されます。
- ブロックされたというシグナルは、BLOCKED、STREAM_BLOCKED、およびSTREAM_ID_BLOCKEDフレームで伝達されます。  BLOCKEDストリームにはコネクションスコープがあり、STREAM_BLOCKEDフレームにはストリームスコープがあり、STREAM_ID_BLOCKEDフレームには特定のストリームタイプにスコープが設定されています。   スコープの最新のフレームを含むパケットがロスしても、エンドポイントが対応する上限でブロックされている場合にのみ、新しいフレームが送信されます。 これらのフレームには送信された時にブロックしていた原因となっていた上限が常に含まれます。
- 一致するPATH_RESPONSEフレームが受信されるまで、または生存性またはパス検証チェックの必要性がなくなるまで、PATH_CHALLENGEフレームを使用して生存性またはパス検証チェックが定期的に送信されます。 PATH_CHALLENGEフレームには、送信されるたびに異なるペイロードが含まれます。
- 新しいコネクションIDはNEW_CONNECTION_IDフレームで送信され、それらを含むパケットがロスした場合は再送信されます。 このフレームの再送は、同じシーケンス番号値を転送します。 同様に、リタイアコネクションIDはRETIRE_CONNECTION_IDフレームで送信され、それらを含むパケットが失われた場合に再送信されます。
- PADDINGフレームには情報が含まれていないため、PADDINGフレームをロスしてもリカバリする必要はありません。

ロスを検出すると、送信者は適切な輻輳制御動作を行わなければならない(MUST)。 ロス検出と輻輳制御の詳細については[QUIC-RECOVERY]を参照してください。

# 8.3.  Packet Size
QUICパケットサイズには、QUICヘッダと整合性チェックが含まれますが、UDPヘッダまたはIPヘッダは含まれません。

クライアントは、送信した最初のInitial パケットが少なくとも1200オクテットのUDPデータグラムで送信されることを保証しなければなりません(MUST)。 Initialパケットをパディングするか、同じデータグラムに0-RTTパケットを含めることは、この要件を満たす方法です。このサイズのUDPデータグラムを送信することでネットワークパスが合理的なMaximum Transmission Unit(MTU;最大伝送ユニット)をサポートしていることを確認し、未確認のクライアントアドレスに対するサーバの応答が原因となる増幅攻撃の振幅を軽減できます。

クライアントがPath Maximum Transmission Unit(PMTU)が選択したサイズをサポートしていると信じられる場合、クライアントからの最初のInitialパケットを含むデータグラムは1200オクテットを超えてもよい(MAY)。

クライアントから受信した最初のInitialパケットUDPデータグラムが1200オクテットよりも小さい場合、サーバはエラーコードPROTOCOL_VIOLATIONのCONNECTION_CLOSEフレームを送信してもよい(MAY)。 サーバは他のフレームタイプを応答してはいけません(MUST NOT)。あるいは、問題のパケットの一部が正しく処理されたかのように動作します。

## 8.4.  Path Maximum Transmission Unit
Path Maximum Transmission Unit(PMTU)は、IPヘッダ、UDPヘッダ、およびUDPペイロード全体の最大サイズです。 UDPペイロードには、QUICパケットヘッダ、保護されたペイロード、およびすべての認証フィールドが含まれます。

すべてのQUICパケットは、パケットの断片化やドロップを避けるために、推定PMTU内に収まるようなサイズを設定すべきです(SHOULD)。 帯域の効率を最適化するために、エンドポイントはPacketization Layer PMTU Discovery([PLPMTUD])を使用すべきです(SHOULD)。 エンドポイントは、PMTU検出([PMTUDv4]、[PMTUDv6])を使用してPMTUを検出し、PMTUを適切に設定し、以前のPMTU決定の結果を保存できます(MAY)。

これらのメカニズムがない場合、QUICエンドポイントは1280オクテットを超えるIPパケットを送信すべきではありませｎ(SHOULD NOT)。 最小のIPヘッダサイズを仮定すると、IPv6の場合は1232オクテット、IPv4の場合は1252オクテットのQUICパケットサイズになります。 いくつかのQUIC実装は、未知のトンネリングオーバーヘッドやIPヘッダオプションが与えられる可能性があるQUICパケットのサイズ計算をより控えめに行っても良い。

任意の種類のPMTUディスカバリを実装するQUICエンドポイントは、ローカルIPアドレスとリモートIPアドレスの各組み合わせごとに推定値を計算すべきです(SHOULD)。 ローカルアドレスとリモートアドレスの各ペアは、パス内で異なる最大MTUを持つ可能性があります。

QUICはネットワークパスが少なくとも1280オクテットのMTUをサポートすることに依存します。 これはIPv6の最小MTUであり、IPv4ネットワークでもサポートされています。 エンドポイントは、より小さな上限が存在する可能性があることを示すシグナルを受信したとしても、この数よりもMTUを減らしてはならない(MUST NOT)。

QUICエンドポイントが、ローカルIPアドレスとリモートIPアドレスのペアのPMTUが1280オクテットを下回っていると判断した場合、影響を受けたパスでのQUICパケットの送信を直ちに停止する必要があります(MUST)。 これにより、代替パスが見つからない場合にコネクションが切断される可能性があります。

### 8.4.1.  IPv4 PMTU Discovery
IPv4での従来のICMPベースのパスMTU検出[PMTUDv4]は、IP/ポート4タプルを正しく推測し、MTUを非効率な帯域幅に低減するoff-path攻撃に対して潜在的に脆弱です。

その結果、IPv4でPMTUDを実装するエンドポイントは、このリスクを軽減するための手順を実行する必要があります。 たとえば、アプリケーションでは次のことが可能です。  TCPコネクションはICMPメッセージにエコーされたトランスポートヘッダ(少なくとも8バイト)を使用して、現在のコネクションに対して有効なTCPシーケンス番号を検証することで、このリスクを軽減します。しかし、QUICはUDP上で動作するため、IPv4でのエコー情報はIPおよびUDPヘッダのみで構成され、通常はoff-path攻撃を緩和するにはエントロピーが不十分です。

その結果、IPv4でPMTUDを実装するエンドポイントは、このリスクを軽減するための手順を実行すべきです(SHOUD)。 たとえば、アプリケーションでは以下のことができます:

- 少ない割合いでパケットにIPv4 Don't Fragment(DF)ビットを設定し、未処理のDFパケットが存在しない場合には、ほとんどが無効なICMPメッセージが受信されるので、偽物として識別することができます。
- 受信したDatagram Too Bigメッセージをさらに検証するために、DFパケットから得られたIPやUDPヘッダ(例えばIP IDやUDPチェックサム)を追加の情報として保存しておく
- ICMPパケットに含まれるレポートによるPMTUの減少は、QUICのロス検出アルゴリズムがパケットが実際に失われたと判断するまでは暫定的なものです

### 8.4.2.  Special Considerations for Packetization Layer PMTU Discovery
PADDINGフレームは、PMTUプローブパケットに便利な選択肢となります。PADDINGフレームはAckを発生させますが、確実に配送される必要はありません。 結果として、プローブパケットにおけるPADDINGフレームのロスは、遅延を誘発する再送を必要としません。 しかし、PADDINGフレームは輻輳ウィンドウを消費するため、後続のアプリケーションデータの送信を遅延させる可能性があります。

[PLPMTUD]のSection 7.2のアルゴリズムを実装するとき、search_lowの初期値はIPv6最小パケットサイズと一致していなければなりません(SHOULD)。 このサイズをサポートしていないパスは、Initialパケットを転送できないため、QUIC準拠ではありません。

[PLPMTUD]のSection 7.3では、プローブパケットのサイズの大小に関するトレードオフについて議論しています。 QUICプローブパケットにはアプリケーションデータが含まれている必要がないため、プローブサイズの増加による影響は少なくなります。

# 9.  Streams: QUIC's Data Structuring Abstraction
QUICのストリームは、抽象化された軽量で順序付けられたバイトストリームを提供します。

QUICには2つの基本的なタイプのストリームがあります。 単方向ストリームは、ストリームの開始者からピアへの一方向のデータを転送します。双方向ストリームは、双方向にデータを送信できます。 単方向ストリームと双方向ストリームを区別するために、異なるストリーム識別子が使用されます。また、クライアントもしくはサーバのどちらによって開始されたストリームなのかも分けられます。

いずれのタイプのストリームも、いずれかのエンドポイントによって作成され、他のストリームとインタリーブされたデータを同時に送信することができ、キャンセルすることができます。

ストリームオフセットによってストリーム上のオクテットは順番通りに配置されます。 エンドポイントは、ストリーム上で受信したデータを順番どおりに受け渡す事ができなければなりません(MUST)。実装は、順番通りでないデータを受け渡す機能を提供することを選択してもよい(MAY)。 異なるストリーム上のオクテット間の順序を保証する手段はありません。

ストリームの作成と廃棄には、少なからず帯域と計算コストが必要です。 1つのSTREAMフレームは、ストリームの作成、データの伝送、およびストリームの終了を行うことができます。

ストリームは個別にフロー制御され、エンドポイントはメモリのコミットメントを制限し、Back Pressureを適用することができます。 ストリームの作成はフロー制御され、その時のピアによる最大ストリームIDの制限をうけます。

QUICストリームの別のビューは、SST [SST]でエフェメラルストリームが使用される方法と同様に、弾性的な「メッセージ」抽象化であり、一部のアプリケーションにとってはより魅力的な記述である可能性があります。

QUICストリームの別の視点は、 [SST]でエフェメラルストリームが使用される方法と同様に、柔軟な「メッセージ」の抽象化であり、一部のアプリケーションにとってはより魅力的な表現となります。

## 9.1.  Stream Identifiers
ストリームは、ストリームIDと呼ばれる符号なし62ビット整数で識別されます。 ストリームIDの最下位2ビットは、ストリームのタイプ(単方向または双方向)およびストリームの開始者を識別するために使用されます。

ストリームIDの最下位ビット(0x1)はストリームの開始者を識別します。 クライアントは偶数番号のストリーム(最下位ビットが0に設定されているストリーム)を開始します。 サーバは奇数番号のストリームを開始します(ビットは1に設定されます)。ストリーム識別子を分離することで、クライアントとサーバは使用する識別子をネゴシエーションすることによってレイテンシ生じる遅延なくストリームをオープンすることができます。

エンドポイントが自身が開始するストリーム(つまり、クライアントの場合は奇数、サーバの場合は偶数)のフレームを受信したが、まだオープンしていない場合はエラーコードSTREAM_STATE_ERRORでコネクションを終了する必要があります。

ストリームIDの下位2ビット目(0x2)は、単方向ストリームと双方向ストリームを区別します。 単方向ストリームは常にこのビットを1に設定し、双方向ストリームはこのビットを0に設定します。

したがって、ストリームIDからの2つのタイプのビットは、Table 5にまとめられるようにストリームを識別します。

```
              +----------+----------------------------------+
              | Low Bits | Stream Type                      |
              +----------+----------------------------------+
              | 0x0      | Client-Initiated, Bidirectional  |
              |          |                                  |
              | 0x1      | Server-Initiated, Bidirectional  |
              |          |                                  |
              | 0x2      | Client-Initiated, Unidirectional |
              |          |                                  |
              | 0x3      | Server-Initiated, Unidirectional |
              +----------+----------------------------------+

                         Table 5: Stream ID Types
```

クライアントによって開始された最初の双方向ストリームはストリーム0です。

QUICエンドポイントはストリームIDを再使用してはいけません(MUST NOT)。 各タイプのストリームは数字順に作成されます。 ストリームが順番通りではなく使用された場合は、同じ向きを持つ同じタイプでより小さいストリームがオープンすることになります。

ストリームIDは可変長整数としてエンコードされます(Section 7.1を参照)。

## 9.2.  Stream States
このセクションでは送信者や受信者の状態に関する2つのタイプのQUICストリームについて説明します。 2つのステートマシンについて説明します。1つはエンドポイントがデータを送信するストリーム(Section 9.2.1)。 もう一つは、エンドポイントがデータを受信するストリームです(Section 9.2.2)。

単方向ストリームは、該当するステートマシンを直接使用します。双方向ストリームは、両方のステートマシンを使用します。 ほとんどの場合、ストリームが単方向であるか双方向であるかにかかわらずこれらのステートマシンは同じです。 ストリームをオープンする条件は、双方向ストリームの場合はやや複雑です。なぜならば送信側または受信側のいずれかでオープンすると、ストリームが両方向でオープンするからです。

エンドポイントはストリームを最大ストリーム制限まで任意の順序でオープンすることができますが、エンドポイントは各タイプの送信側のストリームを順番にオープンすべきです(SHOULD)。

注：これらの状態は大いに有益です。 このドキュメントでは、ストリームの状態を使用して、さまざまなタイプのフレームを送信できるタイミングと方法、および異なるタイプのフレームを受信したときに予想される対応についてのルールを記述します。これらのステートマシンはQUICの実装に役立つことを意図していますが、これらのステートは実装を制約するものではありません。これらのステートが実装されている実装と一致している限り、実装は異なるステートマシンを定義することができます。

### 9.2.1.  Send Stream States
Figure 16は、データをピアに送信する側のストリーム状態を示しています。

```
          o
          | Create Stream (Sending)
          | Create Bidirectional Stream (Receiving)
          v
      +-------+
      | Ready | Send RST_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Send STREAM /             |
          |      STREAM_BLOCKED       |
          |                           |
          | Create Bidirectional      |
          |      Stream (Receiving)   |
          v                           |
      +-------+                       |
      | Send  | Send RST_STREAM       |
      |       |---------------------->|
      +-------+                       |
          |                           |
          | Send STREAM + FIN         |
          v                           v
      +-------+                   +-------+
      | Data  | Send RST_STREAM   | Reset |
      | Sent  |------------------>| Sent  |
      +-------+                   +-------+
          |                           |
          | Recv All ACKs             | Recv ACK
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Recvd |                   | Recvd |
      +-------+                   +-------+

                    Figure 16: States for Send Streams
```

エンドポイントが開始する(クライアントの場合はタイプ0と2、サーバの場合は1と3)ストリームの送信側は、アプリケーションまたはアプリケーションプロトコルによってオープンされます。"Ready"状態は、アプリケーションからデータを受け入れることができる新しく作成されたストリームを表します。 ストリームのデータは、送信の準備としてこの状態でバッファリングできます。

最初のSTREAMまたはTREAM_BLOCKEDフレームを送信すると、送信ストリームが"Send"状態になります。 実装は、最初のフレームを送信してこの状態に入るまで、ストリームIDを送信ストリームに割り当てるのを遅らせることができます。これにより、ストリームの優先順位付けが改善されます。

ピアによって開始された双方向ストリーム(サーバの場合はタイプ0、クライアントの場合はタイプ1)の送信側は"Ready"状態になり、受信側が"Recv"状態に入ると直ちに"Send"」状態に遷移します。

"Send"状態では、エンドポイントはSTREAMフレームのデータを送信し、必要に応じて再送します。 エンドポイントはMAX_STREAM_DATAフレームを受け入れ、ピアのフロー制御上限を尊重し。 "Send"状態のエンドポイントは、フロー制御上限に達すると、STREAM_BLOCKEDフレームを生成します。

アプリケーションがストリームデータを完了し、FINビットを含むSTREAMフレームが送信されると、送信ストリームは"Data Sent"状態になります。この状態から、エンドポイントは必要に応じてストリームデータのみを再送します。 この状態では、エンドポイントはフロー制御上限をトラッキングする必要がなくなります。また、送信ストリームにSTREAM_BLOCKEDフレームを送信する必要もありません。エンドポイントは、この状態でピアから受信したMAX_STREAM_DATAフレームを無視できます。 ピアが最終ストリームオフセットを受信するまで、MAX_STREAM_DATAフレームを受信する可能性があります。

すべてのストリームデータが正常にAck応答されると、送信ストリームは"Data Recvd"状態になります。これは終端状態です。

"Ready"、 "Send"、"Data Sent"のいずれかの状態から、アプリケーションはストリームデータの送信を中止することを通知できます。 同様に、エンドポイントはそのピアからSTOP_SENDINGフレームを受信する可能性があります。 どちらの場合も、エンドポイントはRST_STREAMフレームを送信します。これにより、ストリームは"Reset Sent"状態に入ります。

エンドポイントは、送信ストリーム上の最初のフレームとしてRST_STREAMを送信できます(MAY)。 これにより、送信ストリームがオープンしすぐに"Reset Sent"状態に移行します。

RST_STREAMを含むパケットがAckされると、送信ストリームは終端状態である"Reset Recvd"状態に入ります。

### 9.2.2.  Receive Stream States
Figure 17は、ピアからデータを受信する側のストリーム状態を示しています。 受信ストリームの状態は、ピアの送信ストリームの状態が部分的に反映されます。 受信ストリームは、送信ストリームの"Ready"状態などの観測できないステートをトラックしません。 その代わりに、ストリームを受信すると、送信者がその一部を見ることができないアプリケーションまたはアプリケーションプロトコルへのデータの受け渡しがトラックされます。

```
          o
          | Recv STREAM / STREAM_BLOCKED / RST_STREAM
          | Create Bidirectional Stream (Sending)
          | Recv MAX_STREAM_DATA
          | Create Higher-Numbered Stream
          v
      +-------+
      | Recv  | Recv RST_STREAM
      |       |-----------------------.
      +-------+                       |
          |                           |
          | Recv STREAM + FIN         |
          v                           |
      +-------+                       |
      | Size  | Recv RST_STREAM       |
      | Known |---------------------->|
      +-------+                       |
          |                           |
          | Recv All Data             |
          v                           v
      +-------+  Recv RST_STREAM  +-------+
      | Data  |--- (optional) --->| Reset |
      | Recvd |  Recv All Data    | Recvd |
      +-------+<-- (optional) ----+-------+
          |                           |
          | App Read All Data         | App Read RST
          v                           v
      +-------+                   +-------+
      | Data  |                   | Reset |
      | Read  |                   | Read  |
      +-------+                   +-------+

                   Figure 17: States for Receive Streams
```
そのストリームに対する最初のSTREAM、STREAM_BLOCKED、RST_STREAM、またはMAX_STREAM_DATA(双方向のみ、以下を参照)が受信されると、ピアによって開始されたストリーム(クライアントの場合は1と3、サーバの場合は0と2)の受信側が作成されます。

受信ストリームの初期状態は"Recv"です。 RST_STREAMフレームを受信すると、受信ストリームはすぐに "Reset Recvd"に移行します。

エンドポイントによって開始された双方向ストリーム(クライアントの場合はタイプ0、サーバの場合はタイプ1)の送信側が"Ready"状態になると、受信ストリームは"Recv"状態になります。

MAX_STREAM_DATAフレームが受信されると、双方向ストリームはオープンします。 MAX_STREAM_DATAフレームを受信すると、リモートピアがストリームをオープンしてフロー制御のクレジットを提供していることを意味します。 パケットが失われたり順番が入れわかった場合、STREAMまたはSTREAM_BLOCKEDフレームの前にMAX_STREAM_DATAフレームが到着する可能性があります。

ストリームを作成する前に、同じタイプの中でより番号の小さいストリームが作成されていなければなりません(MUST)。 つまり、ストリームをオープンするフレームを受け取ると、同じタイプのすべてのストリームが小さい方から番号順にオープンされます。 これにより、両方のエンドポイントでストリームの作成順序が一致することが保証されます。

"Recv"状態では、エンドポイントはSTREAMフレームとSTREAM_BLOCKEDフレームを受信します。 受信データはバッファリングされ、正しい順序に並び替えられアプリケーションに渡されます。アプリケーションによってデータが使用されバッファ領域が使用可能になると、エンドポイントはMAX_STREAM_DATAフレームを送信してピアがより多くのデータを送信できるようにします。

FINビットを持つSTREAMフレームが受信されると、最終オフセット(Section 10.3を参照)がわかります。 受信ストリームは"Size Known"状態になります。 この状態では、エンドポイントはMAX_STREAM_DATAフレームを送信する必要がなくなり、ストリームデータの再送のみを受信します。

"Data Recvd"状態は、ストリームデータがアプリケーションプロトコルまたはアプリケーションプロトコルに渡されるまでつづきます。 ストリームデータが渡されると、ストリームは"Data Read"状態になります。これは終端状態です。

"Recv"または"Size Known"の状態でRST_STREAMフレームを受信すると、ストリームは"Reset Recvd"状態になります。 これにより、アプリケーションへのストリームデータの受け渡しが中断される可能性があります。

RST_STREAMを受信(つまり、"Data Recvd"状態から)したとき、すべてのストリームデータが受信される可能性があります。 同様に、RST_STREAMフレームを受信した後に残りのストリームデータが到着することもあります("Reset Recvd"状態)。 実装は、選択したとおりにこの状況を管理することができます。 RST_STREAMの送信は、エンドポイントがストリームデータの受け渡しを保証できないことを意味します。しかし、RST_STREAMが受信された場合ストリームデータが受け渡されないという要件はありません。  実装はストリームデータの受け渡しを中断し、使用されなかったデータを破棄し、直ちにRST_STREAMがあることを知らせることができます(MAY)。 別の方法として、ストリームデータが完全に受信された場合、RST_STREAMシグナルは抑止されてもよいし、保留されもよい。 後者の場合、受信ストリームは、"Data Recvd"から"Reset Recvd"に効率的に遷移します。

受信ストリームがリセットされたことを示す信号がアプリケーションに渡されると、受信ストリームは終端状態である"Reset Read"状態に移行します。

### 9.2.3.  Permitted Frame Types
ストリームの送信者は、送信者または受信者のいずれかでストリームの状態に影響を与える3つのフレームタイプのみを送信します。つまり、STREAM(Section 7.20)、STREAM_BLOCKED(Section 7.11)、およびRST_STREAM(Section 7.3)です。

送信者はこれらのフレームのいずれかを終端状態("Data Recvd"または"Reset Recvd")で送信してはいけません(MUST NOT)。 送信者は、RST_STREAMを送信した後、STREAMまたはSTREAM_BLOCKEDを送信してはいけません(MUST NOT)。 すなわち、終端状態に加えて"Reset Sent"状態でです。受信者は任意の状態でこれらのフレームのいずれかを受信することができますが、そのフレームを持つパケットが遅延する可能性があるだけです。

ストリームの受信者は、MAX_STREAM_DATA(Section 7.7)とSTOP_SENDINGフレーム(Section 7.15)を送信します。

受信者はMAX_STREAM_DATAを "Recv"状態でのみ送信します。 受信者はRST_STREAMフレームを受信していない状態でSTOP_SENDINGを送信できます。その状態は"Reset Recvd"もしくは"Reset Read"です。しかし、すべてのストリームデータを受信した"Data Recvd"状態の後で、STOP_SENDINGフレームを送信する価値はほとんどありません。 送信者はパケットの遅延の結果として、これらのフレームを任意の状態で受信することがあります。

### 9.2.4.  Bidirectional Stream States
双方向ストリームは、送信ストリームと受信ストリームで構成されます。 実装は、双方向ストリームの状態を送信および受信ストリーム状態の複合体として表すことができる。最も簡単なモデルは、ストリームの送信または受信が非終端状態にあるときにストリームを"open"とし、送信ストリームおよび受信ストリームの両方が終端状態にあるときに"closed"とします。

Table 6は、HTTP/2[HTTP2]におけるストリーム状態に大雑把に対応する双方向ストリーム状態の複雑なマッピングを示します。 これは、送信ストリームまたは受信ストリームの複数の状態が同じ合成状態にマップされていることを示しています。 これは、マッピングの1つの可能性にすぎないことに注意してください。 このマッピングはデータが"closed"状態または"half-closed"状態に遷移する前にAckされていることが必要です。

```
   +-----------------------+---------------------+---------------------+
   | Send Stream           | Receive Stream      | Composite State     |
   +-----------------------+---------------------+---------------------+
   | No Stream/Ready       | No Stream/Recv *1   | idle                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Recv/Size Known     | open                |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Data Recvd/Data     | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Ready/Send/Data Sent  | Reset Recvd/Reset   | half-closed         |
   |                       | Read                | (remote)            |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Recv/Size Known     | half-closed (local) |
   | Recvd                 |                     |                     |
   |                       |                     |                     |
   | Data Recvd            | Recv/Size Known     | half-closed (local) |
   |                       |                     |                     |
   | Reset Sent/Reset      | Data Recvd/Data     | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Reset Sent/Reset      | Reset Recvd/Reset   | closed              |
   | Recvd                 | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Data Recvd/Data     | closed              |
   |                       | Read                |                     |
   |                       |                     |                     |
   | Data Recvd            | Reset Recvd/Reset   | closed              |
   |                       | Read                |                     |
   +-----------------------+---------------------+---------------------+

           Table 6: Possible Mapping of Stream States to HTTP/2
```

注(* 1)：ストリームがまだ作成されていない場合、または受信ストリームがまだフレームを受信せずに"Recv"状態である場合、ストリームは"idle"と見なされます。


## 9.3.  Solicited State Transitions
エンドポイントがストリーム上で受信しているデータにもはや関心がない場合、そのストリームのSTOP_SENDINGフレームを送信して、反対方向のストリームのクローズを促すことができます(MAY)。 これは通常、受信側アプリケーションがストリームから受信したデータを読み取っていないことを示しますが、受信データが無視されることを保証するものではありません。

STOP_SENDINGを送信した後に受信されたSTREAMフレームは破棄されますが、コネクションおよびストリームフロー制御ウィンドウにカウントされます。 これにより、どのSTREAMフレームがフロー制御にカウントされるかについてのあいまいさが回避されます。

STOP_SENDINGフレームは、受信エンドポイントがRST_STREAMフレームを送信することを要求します。 STOP_SENDINGフレームを受信したエンドポイントは、そのストリームのRST_STREAMフレームを送信する必要があります(MUST)。STOPPINGエラーコードを使用することができます。  STOP_SENDINGフレームが既に "Data Sent"状態にある送信ストリーム上で受信された場合、以前に送信されたSTREAMフレームの再送を取り消すために、RST_STREAMフレームを引き続き送信できます(MAY)。

STOP_SENDINGは、リセットされていない受信ストリームに対してのみ送信されるべきです(SHOULD)。 STOP_SENDINGは "Recv"または "Size Known"状態のストリームで最も有用です。

直前のSTOP_SENDINGを含むパケットがロスした場合、エンドポイントは別のSTOP_SENDINGフレームを送信することが期待されます。 ただし、ストリームのすべてのストリームデータが受信されるか、またはRST_STREAMフレームが受信されると、つまりストリームがSize Known"や"Size Known"以外の状態にある場合は、STOP_SENDINGフレームの送信は不要です。

## 9.4.  Stream Concurrency
エンドポイントは最大ストリームIDを調整して、同時にアクティブとなる受信ストリームの数を制限します。 初期値はトランスポートパラメータ(Section 6.6.1を参照)に設定され、MAX_STREAM_IDフレーム分だけ増加します(Section 7.8を参照)。

最大ストリームIDは各エンドポイントに固有であり、設定を受信するピアにのみ適用されます。 つまり、クライアントはサーバが開始できる最大ストリームIDを指定し、サーバはクライアントが開始できる最大ストリームIDを指定します。各エンドポイントは、新しいストリームを開始することが許可されているかどうかにかかわらず、他のピアによって開始されたストリームにレスポンスできます。

エンドポイントは、ピアによって設定された上限を超えてはいけません(MUST NOT)。上限を超えるIDを持つSTREAMフレームを受信したエンドポイントは、初期リミットの変更によって引き起こされた場合を除いて、STREAM_ID_ERRORタイプのストリームエラー(Section 11)としてこれを処理しなければならない(MUST)。

受診者はアドバタイズした内容を取り消せません。つまり、受信者がMAX_STREAM_IDフレームでストリームIDを宣言すると、より小さい最大IDのアドバタイズは効果がありません。 送信者は、最大ストリームIDを増加させないMAX_STREAM_IDフレームを無視しなければならない(MUST)。

## 9.5.  Sending and Receiving Data
ストリームが作成されると、エンドポイントはストリームを使用してデータを送受信できます。 各エンドポイントは、ストリームがその向きで終了するまで、データストリームをカプセル化する一連のSTREAMフレームを送信することができます。 ストリームは順序付けされた抽象化されたバイトストリームであり、他の構造はもちません。 STREAMフレームの境界は、送信側からの再送時、または受信側のアプリケーションへ渡されるときに保持されることは期待されません。

QUICでは、部分的な信頼性や順番通りでないストリームデータの通信を容認しません。 エンドポイントは、ストリームデータを順序付けられたバイトストリームとしてアプリケーションに配信できなければならなりません(MUST)。 順序付けられたバイトストリームを渡すために、アドバタイズされたフロー制御限界まで、順序ではなく受信されたデータをエンドポイントでバッファリングする必要があります。

エンドポイントは同じオクテット列を複数回受信する可能性があります。 すでに受信されたオクテット列は破棄できます。 複数回送信されても与えられたオクテット列の値は変更してはいけません(MUST NOT)。 エンドポイントは変更されたオクテット列の受信をタイプPROTOCOL_VIOLATIONのコネクションエラーとして扱ってよい(MAY)。

エンドポイントは、ピアによって設定されたデータ上限内にあることを確認せずに、ストリーム上のデータを受け渡してはいけません(MUST NOT)。

フロー制御についてはSection 10で詳細に説明し、輻輳制御については関連文書[QUIC-RECOVERY]で説明します。

## 9.6.  Stream Prioritization
ストリームに割り当てられるリソースの優先度が正しく設定されている場合、ストリームの多重化はアプリケーションのパフォーマンスに大きな影響を与えます。 HTTP/2[HTTP2]などの他の多重化プロトコルでの知見は、効果的な優先度付け戦略がパフォーマンスに大きく良い影響を与えることを示しています。

QUICは優先度付けの情報を交換するためのフレームを提供しません。 代わりにQUICを使用するアプリケーションから優先度情報を受け取ることに依存します。 QUICを使用するプロトコルは、アプリケーションのセマンティクスに適した優先順位付けスキームを定義できます。 プロトコルはHTTP/2で定義されたように、優先度をシグナリングする明示的なメッセージを定義することができます。 エンドポイントがコンテキストに基づいて優先度を決定できるようにする規則を定義できます。もしくはアプリケーションに委ねることもできます。

QUICの実装は、アプリケーションがストリームの相対的な優先度を指示する方法を提供すべきです(SHOULD)。 リソースをストリームに割り当てる際、アプリケーションが提供する情報を使用してください。 ストリームの優先度を考慮しないと、パフォーマンスが最適化されない可能性があります。

ストリームの優先度はどのストリームデータが送信されるかを決定する際に最も重要です。 多くの場合、コネクションフロー制御または現在の輻輳制御状態によっては送信できるものには限界があります。

自身の制御フレームの送信を優先させることで、プロトコルが効率的に機能することが保証されます。 つまりSTREAMフレーム以外のフレームに優先順位を付けることで、ロスリカバリ、輻輳制御、およびフロー制御が効果的に動作することが保証されます。

CRYPTOフレームは、暗号ハンドシェイクが完了する前は他のストリームよりも優先されるべきです(SHOULD)。 これにはクライアントハンドシェイクメッセージの2番目の送信データであるTLS Finishedと任意であるクライアント認証メッセージの再送が含まれます

アプリケーションの優先度に別途指示がない限り、ロスしたと判断されたフレームのストリームデータは新しいデータを送信する前に再送されるべきである(SHOULD)。 ロスしたストリームデータを再送することで穴を埋めることができます。これにより、ピアがすでに受信したデータを使用できるようにし、フロー制御ウィンドウの解放を可能にします

# 10.  Flow Control
高速な送信者が遅い受信者を圧迫しないように、または悪意のある送信者が受信者に重要なリソースを消費させないように、送信者の大量のデータ量送信を制限する必要があります。 このセクションでは、QUICのフロー制御メカニズムについて説明します。

QUICは、HTTP/2のフロー制御[HTTP2]と同様のクレジットベースのフロー制御方式を採用しています。 受信者は、指定したストリーム上とコネクション全体で受信する用意ができているオクテットの数についてアドバタイズします。 これにより、QUICでは2つのレベルのフロー制御が行われます。(i)送信者が接続の受信者のバッファ容量を超えないようにするコネクションフロー制御、そして(ii)1つのストリームがコネクションの受信バッファ全体を消費しないようにするストリームフロー制御。

データ受信者はMAX_STREAM_DATAまたはMAX_DATAフレームを送信者に送信して、追加のクレジットをアドバタイズします。 MAX_STREAM_DATAフレームはストリームの最大バイトオフセットを送り、MAX_DATAはすべてのストリームのバイトオフセットの合計の最大値を送ります。

受信者は、MAX_DATAまたはMAX_STREAM_DATAフレームを任意の時に送信することで、より大きなオフセットをアドバタイズしてよい(MAY)。 受信者はアドバタイズを取り下げることはできません。 つまり、受信者がオフセットをアドバタイズすると、小さなオフセットをアドバタイズしても効果がありません。 したがって送信側は、フロー制御の制限を増加させないMAX_DATAまたはMAX_STREAM_DATAフレームを無視しなければならない(MUST)。

ピアが通知されたコネクションまたはストリームデータの上限に違反する場合、受信者はFLOW_CONTROL_ERRORエラー(Section 11)でコネクションをクローズしなければならない(MUST)。

送信するデータがあるがフロー制御の上限によってブロックされていることを示すために、送信者はBLOCKEDまたはSTREAM_BLOCKEDフレームを送信すべきです(SHOULD)。これらのフレームは、一般的なケースではあまり送信されないでしょう。デバッグやモニタリングの目的では有用です。

受信者はストリームIDが適切に設定されたMAX_STREAM_DATAフレームを送信することによって、ストリームのクレジットをアドバタイズします。 受信者は消費されたデータの現在のオフセットを使用して、アドバタイズするフロー制御オフセットを決定できます。 1つのパケットがロスしたとしても、フロー制御クレジットを使い果たす前に送信者がアップデートを受け取るように、受信者は複数のパケットでMAX_STREAM_DATAフレームを送信してもよい(MAY)。

コネクションフロー制御は、すべてのストリーム上においてSTREAMフレームで送信されるストリームデータの総バイト数の上限です。 受信者は、MAX_DATAフレームを送信することによってコネクションのクレジットをアドバタイズします。受信者はすべてのストリームで受信したバイトの累積和を計算します。この値はフロー制御違反をチェックするために使用されます。 受信側はすべてのストリームで利用したバイト数の合計を使用して、アドバタイズする最大データ上限を決定することができます。

## 10.1.  Edge Cases and Other Considerations
ストリームとコネクションレベルのフロー制御を扱う際に考慮する必要があるいくつかのエッジケースがあります。 十分な時間のあと、両エンドポイントはフロー制御の状態に認識を合わせなければなりません。 一方のエンドポイントが、受信側が想定している以上に送信した場合、あまりにも多くのデータが届いた際はコネクションが切断されます。

反対に、送信者がブロックされていると考えている場合、エンドポイントBはより多くのデータを受信できると期待している間はコネクションがデッドロック状態になり、送信者は決して来ないMAX_DATAまたはMAX_STREAM_DATAフレームを待ちます。

RST_STREAMフレームを受信すると、エンドポイントはそのストリームの状態を破棄し、そのストリームで受信するさらなるデータを無視します。RST_STREAMフレームが順番通り受信されなかった可能性があり、続くバイト列が送信中の場合は、同期状態がずれる可能性があります。データ送信者はコネクションレベルのフロー制御のバジェットに対してデータをカウントしますが、これらのバイトを受信していない受信者はカウントに含んでいるかわかりません。受信側は、コネクションフロー制御で同じ調整を行うためにストリーム上で送信されたバイト数を知る必要があります。

この非同期状態を避けるためにRST_STREAMの送信側は、RST_STREAMフレームにストリームで送信された最終バイトオフセットを含まなければいけません(MUST)。 RST_STREAMフレームを受信すると、受信側はRST_STREAMフレームの前にそのストリームで送信されたバイト数を確認し、受信側はそのストリーム上で送信されたすべてのバイト数を考慮して最終オフセット値をそのコネクションフロー制御で使用しなければならない(MUST)。

### 10.1.1.  Response to a RST_STREAM
RST_STREAMはストリームの片方向を直ちに終了させます。 既に受信したデータに対して何らかのアクションまたはレスポンスを行うことができるかどうかはアプリケーション固有の問題ですが、RST_STREAMを受け取ると、多くの場合エンドポイントはデータの送信を停止します。 RST_STREAMの送信者がそれ以上データが処理されないよう明示的に伝えたい場合、そのエンドポイントは同時にSTOP_SENDINGフレームを送信してもよい(MAY)。

### 10.1.2.  Data Limit Increments
このドキュメントでは、いつどれくらいのバイト量をMAX_DATAやMAX_STREAM_DATAでアドバタイズするかは実装に委ねられていますが、いくつかの考慮事項があります。 これらのフレームはコネクションのオーバーヘッドとなります。

したがって、変化の小さいフレームを頻繁に送信することは望ましくありません。 同時に、頻度の低いアップデートはでは、ブロックを回避しようとすると上限を大きく増やす必要があります。 したがって、アップデートが大きくなると、受信者はより大きなリソースを確保する必要があります。そのため、上限値をアドバタイズする際のリソース確保とオーバーヘッドにはトレードオフがあります。

一般的なTCP実装と同様に、受信者はRTT推定と受信アプリケーションがデータを使用する早さに基づいて、データ上限を増加させる周期と量を調整するためにオートチューニングの仕組みを使用してもよい(MAY)。

## 10.2.  Stream Limit Increment
フロー制御の場合と同様に、いつどのくらいMAX_STREAM_IDでピアに利用可能とするかは実装に委ねられますが、いくつかの考慮事項があります。 MAX_STREAM_IDフレームは最小限のオーバーヘッドではありますが、MAX_STREAM_IDフレームを保留すると、ピアができる並列処理を妨げる可能性があります。

実装はピアによって開始されたストリームがクローズすると、最大ストリームIDを増やしたいと考えるでしょう。 受信者は、現在の状況、システム条件、および他の環境要因に基づいて最大ストリームIDを増やすことができます(MAY)。

### 10.2.1.  Blocking on Flow Control
送信者がフロー制御のクレジットを使い果たしたときに、MAX_DATAまたはMAX_STREAM_DATAフレームを受信していない場合は、送信者はブロックされます。送信者はBLOCKEDまたはSTREAM_BLOCKEDフレームを送信すべきです(SHOULD)。これらのフレームは、受信側でのデバッグに役立つことが期待されています。 他の行動は必要ありません。 受信者はMAX_DATAまたはMAX_STREAM_DATAを送信する前にBLOCKEDまたはSTREAM_BLOCKEDフレームを待つべきではありません(SHOULD NOT)。これは送信者がラウンドトリップの間は送信できないことを意味するからです。

輻輳制御を円滑に動作させるためには、一般的には、避けられるのであれば送信者がブロック状態にならないようにすることが最善と考えられます。 送信者をブロックするのを避け、ロスの可能性を合理的に考慮し、受信者は、送信者がブロックされる少なくとも2RTT前にMAX_DATAまたはMAX_STREAM_DATAフレームを送信する必要があります。

送信者は、データ上限に達するとBLOCKEDまたはSTREAM_BLOCKEDフレームを1つ1回だけ送信します。 送信者は元のフレームがロスしない限り、同じデータ上限に対して複数のBLOCKEDまたはSTREAM_BLOCKEDフレームを送信してはならない(SHOULD NOT)。 データ上限を増やした後、別のBLOCKEDまたはSTREAM_BLOCKEDフレームを送信できます。

## 10.3.  Stream Final Offset
最終オフセットは、ストリーム上で送信されたオクテット数のカウントです。 リセットされたストリームの場合、最終オフセットはRST_STREAMフレームで明示的に伝達されます。 それ以外の場合、最終オフセットは、FINフラグを持つSTREAMフレームで転送されたデータの終わりのオフセット値です。受信のみの単方向ストリームの場合は0です。

エンドポイントは、受信ストリームが"Size Known"または"Reset Recvd"状態になると、ストリームの最終的なオフセットがわかります。

エンドポイントは最終オフセット値を超えてストリーム上でデータを送信してはならない(MUST NOT)。

ストリームの最終オフセットが決まれば、変更することはできません。 RST_STREAMまたはSTREAMフレームがストリームの最終オフセットを変更する場合、エンドポイントはFINAL_OFFSET_ERRORエラーを返す必要があります(Section 11を参照)。受信者はストリームがクローズされた後でも、最終オフセット以上のデータの受信をFINAL_OFFSET_ERRORエラーとして処理すべきです(SHOULD)。 これらのエラーを生成することは必須ではありませんが、エンドポイントがこれらのエラーを生成するにはエンドポイントがクローズされたドストリームの最終的なオフセット状態を覚えてく必要があることも意味します。

## 10.4.  Flow Control for Cryptographic Handshake
CRYPTOフレームで送信されるデータはSTREAMフレームと同じ方法ではフロー制御されません。 QUICはデータの過度のバッファリングを避けるために、暗号プロトコルの実装に依存しています。[QUIC-TLS]を参照してください。実装はQUICにインタフェースを提供して、複数のレイヤで過度のバッファリングがないように、そのバッファリング限度について通知しなければならない(SHOULD)。

## 11.  Error Handling
エラーを検出したエンドポイントは、そのエラーの存在をピアに知らせるべきです(SHOULD)。 トランスポートレベルとアプリケーションレベルのエラーは、コネクション全体(Section 11.1を参照)に影響する可能性がありますが、アプリケーションレベルのエラーは1つのストリームのみに影響します(Section 11.2を参照)。

ステートレスリセット(Section 6.13.4)は、CONNECTION_CLOSE、APPLICATION_CLOSE、またはRST_STREAMフレームで通知できるエラーには適していません。 コネクション上でフレームを送信するのに必要な状態を持つエンドポイントは、ステートレスリセットを使用してはいけません(MUST NOT)。

## 11.1.  Connection Errors
プロトコルセマンティクスの明らかな違反やコネクション全体に影響を与える状態異常など、コネクションが使用できなくなるエラーが発生した場合は、CONNECTION_CLOSEまたはAPPLICATION_CLOSEフレーム(Section 7.4、Section 7.5)を使用してその旨を通知する必要しなければなりません(MUST)。エンドポイントは、たとえエラーが1つのストリームにしか影響しなくても、このようにコネクションを閉じることができます(MAY)。

アプリケーションプロトコルは、APPLICATION_CLOSEフレームを使用してアプリケーション固有のプロトコルエラーを通知できます。 このドキュメントに記載されているものを含め、トランスポートに固有のエラーは、CONNECTION_CLOSEフレームで伝達されます。 それらがもつエラーコードのタイプ以外、フレームの意味と形式は同じです。

CONNECTION_CLOSEまたはAPPLICATION_CLOSEフレームのパケットがロスする可能性があります。 エンドポイントは終了したコネクション上でさらなるパケットを受信した場合に、これらのフレームタイプを含むパケットが再送できるように準備すべきです(SHOULD)。 再送の回数とこの最終パケットが送信される時間を制限することで、終了したコネクションに費やされるリソースが制限できます。

CONNECTION_CLOSEまたはAPPLICATION_CLOSEを含むパケットを再送しないことを選んだエンドポイントは、そのようなパケットをロスしたピアを危険にさらします。 唯一の方法は終了したコネクションのデータを引き続き受信するエンドポイントが使用できる唯一のメカニズムであるステートレスリセット(Section 6.13.4)を使用することです。

無効なCONNECTION_CLOSEまたはAPPLICATION_CLOSEフレームを受信したエンドポイントは、そのピアのエラーの存在を通知してはいけません(MUST NOT)。

## 11.2.  Stream Errors
アプリケーションレベルのエラーが1つのストリームに影響する場合は、コネクションを回復可能な状態にしておくと、エンドポイントは適切なエラーコードを含むRST_STREAMフレーム(Section 7.3)を送信して影響を受けるストリームのみを終了させることができます。

STOPPING(Section 9.3)を除いて、RST_STREAMはアプリケーションによって発行され、アプリケーションエラーコードを持っていけません(MUST)。 アプリケーションプロトコルを関知せずにストリームをリセットすると、プロトコルが回復不可能な状態になる可能性があります。

アプリケーションプロトコルでは、エンドポイント間の一貫性のある状態を保証するために、特定のストリームを確実に転送する必要があります。

## 11.3.  Transport Error Codes
QUICエラーコードは16ビットの符号なし整数です。

このセクションでは、CONNECTION_CLOSEフレームで使用されるQUICトランスポートエラーコードを示します。 これらのエラーは、コネクション全体に適用されます。

- NO_ERROR (0x0): エンドポイントはこれをCONNECTION_CLOSEで使用して、エラーがなければコネクションを直ちにクローズすることを通知します。
- INTERNAL_ERROR (0x1): エンドポイントで内部エラーが発生し、コネクションを続行できません。
- SERVER_BUSY (0x2): サーバは現在ビジー状態であり、新しいコネクションを受け付けていません。
- FLOW_CONTROL_ERROR (0x3): エンドポイントはアドバタイズされたデータ上限で許可された以上のデータを受信しました(see Section 10)。
- STREAM_ID_ERROR (0x4): エンドポイントがアドバタイズした最大ストリームIDを超えたストリームIDのフレームを受信しました。
- STREAM_STATE_ERROR (0x5): エンドポイントはそのストリーム状態では許可されていないフレームを受信しました(Section 9.2を参照)。
- FINAL_OFFSET_ERROR (0x6): エンドポイントは、以前に確定された最終オフセットを超えたデータを含むSTREAMフレームを受信しました。 または、エンドポイントがすでに受信したデータの最大オフセットよりも小さい最終オフセットを含むRST_STREAMフレームを受信しました。 またはすでに確定されているものとは異なる最終的なオフセットを含むRST_STREAMフレームをエンドポイントが受信しました。
- FRAME_ENCODING_ERROR (0x7): エンドポイントが不正な形式のフレームを受信しました。 例えば、未知のタイプのフレーム、または残りのパケットより多いAckを有するACKフレーム。
- TRANSPORT_PARAMETER_ERROR (0x8): エンドポイントが無効な値や不正な形式のトランスポートパラメータ、もしくは必須であるが存在しない場合、もしくは禁止されたものが存在している場合、もしくはエラーなものを受信しました。
- VERSION_NEGOTIATION_ERROR (0x9): エンドポイントが実行したバージョンネゴシエーションと一致しないバージョンネゴシエーションパラメータやトランスポートパラメータを受信した。 このエラーコードは潜在的なバージョンのダウングレード攻撃を示します。
- PROTOCOL_VIOLATION (0xA): エンドポイントがより具体的なエラーコードにないプロトコル標準に対するエラーを検出しました。
- INVALID_MIGRATION (0xC): エンドポイントがマイグレーションを無効にしたときに、ピアが別のネットワークにマイグレーションした。
- CRYPTO_ERROR (0x1XX): 暗号ハンドシェイクが失敗しました。 256の値の範囲は、使用される暗号ハンドシェイクに固有のエラーコードを持つために予約されています。 暗号ハンドシェイクにTLSを使用したときに発生するエラーのコードについては、[QUIC-TLS]のSection 4.8で説明しています。

新しいエラーコードの登録の詳細については、Section 13.3を参照してください。

## 11.4.  Application Protocol Error Codes
アプリケーションプロトコルエラーコードは16ビットの符号なし整数ですが、アプリケーションエラーコードの管理はアプリケーションプロトコルに委ねられています。 アプリケーションプロトコルエラーコードは、RST_STREAM(Section 7.3)およびAPPLICATION_CLOSE(Section 7.5)フレームで使用されます。

アプリケーションプロトコルのための16ビットエラーコード空間の使用に制限はありません。 ただし、QUICは値0のエラーコードをSTOPPINGの意味として予約します。 アプリケーションエラーコードSTOPPING(0)は、STOP_SENDINGフレームの受信に応答してストリームを取り消すためにトランスポートによって使用されます。

# 12.  Security Considerations
# 13.  IANA Considerations
# 14.  References
# Appendix A.  Sample Packet Number Decoding Algorithm
# Appendix B.  Change Log

# Acknowledgments
# Contributors
