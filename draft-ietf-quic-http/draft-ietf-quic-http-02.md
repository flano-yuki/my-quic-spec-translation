- [Abstract](#abstract)
- [1.  Introduction](#1--introduction)
- [2.  QUIC Advertisement](#2--quic-advertisement)
  - [2.1.  QUIC Version Hints](#21--quic-version-hints)
- [3.  Connection Establishment](#3--connection-establishment)
  - [3.1.  Draft Version Identification](#31--draft-version-identification)
- [4.  Stream Mapping and Usage](#4--stream-mapping-and-usage)
  - [4.1.  Stream 3: Connection Control Stream](#41--stream-3-connection-control-stream)
  - [4.2.  HTTP Message Exchanges](#42--http-message-exchanges)
    - [4.2.1.  Header Compression](#421--header-compression)
    - [4.2.2.  The CONNECT Method](#422--the-connect-method)
  - [4.3.  Stream Priorities](#43--stream-priorities)
  - [4.4.  Server Push](#44--server-push)
- [5.  HTTP Framing Layer](#5--http-framing-layer)
  - [5.1.  Frame Layout](#51--frame-layout)
  - [5.2.  Frame Definitions](#52--frame-definitions)
    - [5.2.1.  HEADERS](#521--headers)
    - [5.2.2.  PRIORITY](#522--priority)
    - [5.2.3.  SETTINGS](#523--settings)
      - [5.2.3.1.  Integer encoding](#5231--integer-encoding)
      - [5.2.3.2.  Defined SETTINGS Parameters](#5232--defined-settings-parameters)
    - [5.2.3.3.  Usage in 0-RTT](#5233--usage-in-0-rtt)
    - [5.2.4.  PUSH_PROMISE](#524--push_promise)
- [6.  Error Handling](#6--error-handling)
- [7.  Considerations for Transitioning from HTTP/2](#7--considerations-for-transitioning-from-http2)
  - [7.1.  HTTP Frame Types](#71--http-frame-types)
  - [7.2.  HTTP/2 SETTINGS Parameters](#72--http2-settings-parameters)
  - [7.3.  HTTP/2 Error Codes](#73--http2-error-codes)
- [8.  Security Considerations](#8--security-considerations)
- [9.  IANA Considerations](#9--iana-considerations)
- [10. References](#10-references)

# Abstract

QUICトランスポートプロトコルには、ストリームの多重化、ストリーム単位のフロー制御、低遅延コネクション確立など、HTTPのトランスポートに望ましいいくつかの機能があります。 この文書では、QUICを介したHTTPセマンティクスのマッピングについて説明します。また、この文書では、QUICに含まれるHTTP/2の特徴を確認し、HTTP/2拡張をQUICに移植する方法について説明します。

# 1.  Introduction
QUICトランスポートプロトコルには、ストリームの多重化、ストリーム単位のフロー制御、低遅延コネクション確立など、HTTPのトランスポートに望ましいいくつかの機能があります。この文書では、既存のTCPマッピング、HTTP2を利用し、QUIC上のHTTPセマンティクスのマッピングについて説明します。 具体的には、このドキュメントでは、QUICに含まれるHTTP/2の機能を確認し、他の機能をQUIC上でどのように実装できるかについて説明します。

QUICは[QUIC-TRANSPORT]に記載されています。 HTTP/2の詳細については、[RFC7540]を参照してください。

# 2.  QUIC Advertisement
HTTPの送信元は、Alt-Svc HTTPヘッダやHTTP/2のALTSVCフレーム([RFC7838])を介して同等にHTTP/QUICエンドポイントが利用できる事を広告します。Section 3.で定義荒れるALPNトークンを使用します。

たとえば、送信元は、HTTP/1.1またはHTTP/2のレスポンスで、HTTP / QUICが同じホスト名のUDPポート443で使用可能であることを、任意の応答に次のヘッダーを含めることによって示すことができます。

```
   Alt-Svc: hq=":443"
```

HTTP / QUICのサポートを示すAlt-Svcヘッダを受け取ると、クライアントは指定されたホストとポートへのQUICコネクションを確立しようとします。成功すると、この文書で説明するマッピングを使用してHTTPリクエストを送信します。

接続の問題（ファイアウォールによるUDPのブロックなど）によってQUICコネクションの確立に失敗する可能性があります。その場合、クライアントは既存のコネクションを使用し続けるべきです、もしくは送信元が要求するその他のエンドポイントへの接続を試みるべきです(SHOULD)。

## 2.1.  QUIC Version Hints
このドキュメントは、Alt-Svcのパラメータとして "quic"を定義します。HTTP / QUICクライアントにバージョンネゴシエーションのヒントを提供するために使用してもよい(MAY)。 QUICバージョンは、フォーマットに追加の制約がない4オクテットシーケンスです。 シンタックスは：

```
   quic = version-number
   version-number = 1*8HEXDIG; hex-encoded QUIC version
```

先行ゼロは簡潔にするために省略すべきである（SHOULD）。 複数のバージョンがサポートされている場合、 "quic"パラメータは1つのAlt-Svcエントリで複数回繰り返されることがあります(MAY)。 たとえば、サーバーがバージョン0x00000001とバージョンをASCIIで「Q034」として表記した場合、以下のヘッダーを指定になります

```
   Alt-Svc: hq=":443";quic=1;quic=51303334
```

複数のバージョンがリストされている場合、値の順序はサーバーの優先順位を表します（最初の値が最も優先されます）。 送信元はサポートされているバージョンのみをリストしなければならないが、何らかの理由でサポートされているバージョンを省略してもよい（MAY）。


# 3.  Connection Establishment
HTTP / QUIC接続は[QUIC-TRANSPORT]の記述に従って確立されます。 コネクション確立時に、暗号ハンドシェイクでALPNトークン "hq"を選択することにより、HTTP / QUICをサポートしているが示されます。

コアQUICプロトコルに関連するコネクションレベルのオプションは、初期の暗号ハンドシェイクで設定されますが、HTTP固有の設定はSETTINGSフレームで伝達されます。 QUICコネクションが確立された後、HTTPコントロールストリーム（StreamID 3、セクション4参照）の最初のフレームとしてSETTINGSフレーム（セクション5.2.3）を送信されなければなりません(MUST)。    サーバーは、クライアントのSETTINGSフレームが受信されるまで、他のストリームでデータを送信してはならない（MUST NOT）。


## 3.1.  Draft Version Identification
* RFC編集者注：*この文書の最終版を発行する前に、このセクションを削除してください。

公開された最終的なRFCの実装だけが "hq"として識別されます。 そのようなRFCが存在するまで、実装はこの文字列を使って識別してはならない（MUST NOT）。

プロトコルのドラフトバージョンの実装は、文字列 " - "とそれに対応するドラフト番号を識別子に追加しなければならない（MUST）。 たとえば、draft-ietf-quic-http-01は、文字列 "hq-01" です。

これらのドラフトバージョンに基づく互換性のない実験では、文字列「 - 」と実験名を識別子に追加する必要があります（MUST）。たとえば、1980年代のポップミュージックの迷惑な送信のためにストリームを予約するdraft-ietf-quic-http-09に基づく実験的な実装では、そらが「hq-09-rickroll」と識別される可能性があります。どんなラベルも[RFC7230]のセクション3.2.6で定義された "トークン"構文に従わなければならないことに注意してください(MUST)。実験者は、実験をquic@ietf.orgメーリングリストで調整することをお勧めします。

# 4.  Stream Mapping and Usage
QUICストリームは信頼性のある順序どおりのバイトの配信を提供しますが、他のストリームのバイトに関する配信の順序は保証しません。 ワイヤ上では、データはQUIC STREAMフレームにフレーム化されますが、このフレーミングはHTTPフレーミングレイヤーには見えません。 QUICの受信者は、受信したSTREAMフレームをバッファリングして並び替え、信頼できるバイトストリームとして含まれているデータをアプリケーションに渡します。

QUICは暗号操作のためにストリーム1を予約します（ハンドシェイク、暗号設定の更新）。 ストリーム3は、HTTP制御フレームを送受信するために予約されており、HTTP/2のストリーム0に類似しています。この接続コントロールストリームは、HTTP接続にとって重要とみなされます。 なんらかの理由で接続コントロールストリームがクローズされている場合、これはQUIC_CLOSED_CRITICAL_STREAMタイプの接続エラーとして扱われなければならない（MUST）。

HTTPヘッダーとデータがQUIC上で送信される際、QUICレイヤーがストリーム管理のほとんどを処理します。 HTTPリクエスト/レスポンスはストリームのペアを消費します。これは、クライアントの最初のリクエストがQUICストリーム5と7で発生し、2番目のリクエストがストリーム9と11で発生することを意味します。 サーバーの最初のプッシュは、ストリーム2と4を消費します。これは、リクエスト内の2つのストリームを区別するのに再開2bitを要します。

低い番号のほうのストリームは、メッセージコントロールストリームと呼ばれ、HEADERSを含むリクエスト/レスポンスに関連するフレームを転送する。高い番号のほうのストリームはデータストリームであり、追加のフレーミングなしでリクエスト/レスポンスのボディを転送します。 ボディのないリクエストまたはレスポンスは、データを転送することなく、このストリームを対応する方向においてハーフクローズさせることに注意してください。

メッセージコントロールストリームには接続レベルの状態を操作するHPACKのデータが含まれているため、メッセージコントロールストリームをストリームレベルのエラーで閉じてはならない（MUST NOT）。   実装がQUICエラーコードでリクエストを拒否することを選択した場合、データストリーム上でのみQUIC RST_STREAMをトリガする必要があります(MUST)。 実装は、データストリームが突然クローズされた場合に完全なHTTPメッセージを完了することなく、メッセージコントロールストリームをクローズ（FIN）してもよい（MAY）。メッセージコントロールストリームのデータはすべて初入りされなければならない（MUST）、それでなければコネクションが切断されます。

すべてのメッセージコントロールストリームは、HTTP接続にとって重要とみなされます。 何らかの理由でメッセージコントロールストリームが突然終了した場合は、これをHTTP_RST_CONTROL_STREAMタイプの接続エラーとして扱わなければならない（MUST）。  メッセージコントロールストリームがきれいに終了したとき、そのストリーム上で最後のフレームが不完全な場合、これは接続エラーとして扱われなければならない（セクション6.1のHTTP_MALFORMED_ *を参照）。

ストリームのペアは、間を置かずに順番に使用される必要があります。 データストリームはメッセージコントロールストリームがオープンすると同時にオープンされ、ボディを転送した後にクローズされます。 ボディがない場合は、リクエストヘッダーを送信した直後にデータストリームがクローズされます。

QUICストリーム上で送信されるQUICデータを使用する場合、HTTPは個別の多重化を行う必要はなく、常に特定のHTTPトランザクションにマッピングされます。 リクエストとレスポンスは、対応するQUICストリームが適切な方向にクローズされると完了したとみなされます。


## 4.1.  Stream 3: Connection Control Stream
ほとんどの接続レベルの問題はQUICによって管理されるため、ストリーム3の主な用途は、接続がオープンしたときのSETTINGSフレームとその後のPRIORITYフレームになります。

## 4.2.  HTTP Message Exchanges
クライアントは新しいQUICストリームのペアでHTTPリクエストを送信します。 サーバーはリクエストと同じストリームでHTTPレスポンスを送信します。

HTTPメッセージ（リクエストまたはレスポンス）は、以下のもので構成されます：
1. メッセージヘッダ（[RFC7230]、セクション3.2を参照）を含むコントロールストリーム上の1つのヘッダブロック（セクション5.2.1を参照）

2. データストリーム上で送信されるペイロード本体（[RFC7230]のセクション3.3を参照）

3. 必要に応じて、トレーラ部分を含むコントロールストリーム上の1つのヘッダブロック（存在する場合は[RFC7230]、セクション4.1.2参照）。

さらに、上記のメッセージヘッダーブロックを送信する前に、レスポンスには、informational（1xx）HTTPレスポンスのメッセージヘッダーを含むコントロールストリームにゼロ以上のヘッダーブロックが含まれることがあります（[RFC7230]、セクション3.2、[RFC7231] セクション6.2）。

データストリームはボディの転送の直後にハーフクローズしなければなりません(MUST)。メッセージに本文が含まれていない場合、データを転送せずに対応するデータストリームをハーフクローズしなければならなりません（MUST）。    [RFC7230]のセクション4.1で定義された "chunked" トランスファーエンコーディングは使用してはけません(MUST NOT)。

トレーラであるヘッダーフィールドは、メッセージコントロールストリーム上の追加のヘッダーブロックに格納されます。 このようなヘッダブロックは、最後のフレームにEnd Header Blockが設定された一連のHEADERSフレームになります。   送信者は、トレーラセクションに1つのヘッダブロックのみを送信しなければならない（MUST）。 受信者は、HPACKデコーダの状態を維持するために後続のヘッダブロックをデコードしなければならない（MUST）が、出力結果を破棄しなければならない（MUST）。

HTTPリクエスト/レスポンスのやりとりは、ストリームのペアを消費します。リクエストを送信した後、クライアントは送信のためのストリームをクローズします。 レスポンスを送信した後、サーバは送信用のストリームをクローズし、QUICストリームは完全にクローズされます。

もしレスポンスが送受信の途中のリクエストに依存しない場合は、サーバはクライアントがリクエスト全体を送信し切る前にレスポンスを送信できます。  このとき、サーバは完全なレスポンスを送信し、そのストリームをクローズした後に、エラーコードNO_ERRORのRST_STREAMを送ることによって、クライアントがエラーなしにリクエストの送信を中止するよう要求できます(MAY)。そのようなRST_STREAMを受け取った結果として、クライアントはレスポンスを破棄してはならない（MUST NOT）。ただし、クライアントは他の理由により自らの裁量で常にレスポンスを破棄できる。

### 4.2.1.  Header Compression
HTTP/QUICは[RFC7541]で記述されているようにHPACKヘッダ圧縮を使用します。    HPACKは、TCPによって提供されるような順序どおりの配信を前提として、HTTP/2用に設計されています。 符号化されたヘッダブロックのシーケンスは、符号化された順序と同じ順序でエンドポイントに到着（復号化）されなければなりません。 これにより、2つのエンドポイントの動的状態が同期した状態に保たれます。

QUICのストリームは、それらのストリーム上で送信されるデータの順序どおりの配送を提供するが、ストリーム間の配送の順序に関する保証はありません。    QUICでHEADERSフレームの順序どおりの配送を実現するために、HPACKを含むフレームには、順序どおりの処理を保証するためのカウンタが含まれています。順序どおりでなく到着したデータ（リクエスト/レスポンスボディ）は、対応するヘッダが到着するまでバッファリングされる。

これはヘッドオブラインブロッキングを引き起こします。ストリームNのHEADERSを含むパケットが失われたり順序が入れ替わった場合、ストリームN + 4のHEADERSは、ストリームN + 4のHEADERSが到着しても、正常に再送されるまで処理できません。

ディスカッション：HPACKとHOLBを維持する？ HPACKを順序不変で再設計しますか？ HTTP/2のHPACKとの互換性を維持する必要がどれだけありますか? 

### 4.2.2.  The CONNECT Method
擬似メソッドであるCONNECT（[RFC7231]、セクション4.3.6）は、主にHTTPプロキシで使用され、 "https"リソースと通信する目的でオリジンサーバとのTLSセッションを確立します。 HTTP/1.xでは、HTTP接続全体をリモート・ホストへのトンネルに変換するためにCONNECTが使用されます。 HTTP/2では、CONNECTメソッドを使用して、同様の目的で単一のHTTP/2ストリームを介してリモートホストにトンネルを確立します。

HTTP / QUICのCONNECTリクエストは、HTTP/2の場合と同じように機能します。 リクエストは[RFC7540]、セクション8.3で記述されるようにフォーマットされなければなりません。 これらの制限に準拠しないCONNECTリクエストは不正です。 メッセージデータストリームは、リクエストの終わりにクローズしてはいけません（MUST NOT）。

CONNECTをサポートするプロキシは ":authority" 擬似ヘッダーフィールドで識別されるサーバーへTCPコネクション（[RFC0793]）を確立します。 この接続が正常に確立されると、プロキシは、メッセージコントロールストリームの[RFC7231]セクション4.3.6 で定義されているように、クライアントに2xx番台のステータスコードを含むHEADERSフレームを送信します。

メッセージデータストリーム上のすべてのQUIC STREAMフレームは、TCPコネクションで送信されたデータに対応します。 クライアントによって送信されたQUIC STREAMフレームは、プロキシによってTCPサーバーに送信されます。 TCPサーバから受信したデータは、プロキシによってデータストリームに書き込まれます。 TCPセグメントのサイズと数は、QUIC STREAMフレームのサイズと数に予想通り変換されることが保証されていないことに注意してください。

TCPコネクションは、どちらのピアでも閉じることができます。 クライアントがデータストリームをハーフクローズすると、プロキシはTCPサーバーへの接続でFINビットを設定します。 プロキシは、FINビットがセットされたパケットを受信すると、対応するデータストリームをハーフクローズします。一方向にハーフクローズされたままのTCPコネクションは無効ではありませんが、サーバーによって処理されないことが多いため、クライアントはまだデータを期待している接続をハーフクローズしないようにすべきです（SHOULD）。

TCPコネクションエラーは、RST_STREAMで通知されます。 プロキシは、RSTビットがセットされたTCPセグメントを含む、TCPコネクションでのいかなるエラーも HTTP_CONNECT_ERROR（セクション6.1）のストリームエラーとして処理します。同様に、プロキシは、ストリームまたはQUIC接続でエラーを検出した場合に、RSTビットが設定されたTCPセグメントを送信しなければならない（MUST）。

## 4.3.  Stream Priorities
HTTP / QUICは[RFC7540]セクション5.3で説明されているプライオリティ方式を使用します。 このプライオリティ方式では、与えられたストリームは別のストリームに依存すると指定できます。それは、後者のストリーム(親ストリーム)は前者のストリーム(依存する側のストリーム)よりも前にリソースが割り当てられること表します。一つにあわせると、コネクションの全てのストリームの依存関係が依存関係ツリーを形成します。依存関係ツリーの構造は、PRIORITYフレームがストリーム間の依存関係を追加、削除、または変更するときに変更されます。

一貫性のために、すべてのPRIORITYフレームは、データストリームではなく、リクエストのメッセージコントロールストリームで行わなければならなりません（MUST）。

## 4.4.  Server Push
HTTP / QUICは、[RFC7540]で記述されているサーバープッシュをサポートします。 コネクション確立時に、クライアントはSETTINGSフレーム（セクション3を参照）のSETTINGS_DISABLE_PUSHを介してサーバープッシュを受信するかどうかを示します。デフォルトは1（true）です。

HTTP/2のサーバープッシュと同様に、サーバーはプッシュされるストリームのStreamIDを含むPUSH_PROMISEフレームを送信することによってサーバープッシュを開始します、リクエストに紐づくリクエストヘッダも同様に送信されます。  PUSH_PROMISEフレームは、関連する（クライアントが開始した）リクエストのコントロールストリームで送信され、予約されたストリームIDフィールドは、サーバから送信するためのコントロールストリームのストリームIDを指定します。

サーバプッシュのレスポンスはプッシュじゃないのと同じように転送されます。コントロールストリーム上で、レスポンスヘッダともしあればトレーラがHEADSフレームで送信されます。そして、もしあればレスポンスボディが対応するデータストリーム上で送信されます。

# 5.  HTTP Framing Layer
フレームはコネクション（ストリーム3）およびメッセージ（ストリーム5,9など）でのみ使用され、ストリームを制御します。 他のストリームはデータペイロードを転送し、HTTPレイヤーでフレーム化されません。

このセクションでは、QUICのHTTPフレーミングについて説明し、HTTP/2フレーミングとの相違点を強調します。 HTTP/2との違いの詳細については、セクション7.1を参照してください。

## 5.1.  Frame Layout
すべてのフレームの形式は次のとおりです：
```

       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |           Length (16)         |     Type (8)  |   Flags (8)   |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                       Frame Payload (*)                     ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                     Figure 1: HTTP/QUIC frame format
```

## 5.2.  Frame Definitions
### 5.2.1.  HEADERS
HEADERSフレーム（type = 0x1）は、HPACK [RFC7541]を使用して圧縮されたヘッダーセットを運ぶために使用されます。

1つのフラグが定義されています：
    エンドヘッダーブロック（0x4）：このフレームはヘッダーブロックを終了します。

 他のフラグが設定されたHEADERSフレームは、HTTP_MALFORMED_HEADERSの接続エラーとして扱われなければならない（MUST）。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       Sequence? (16)          |    Header Block Fragment (*)...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 2: HEADERS frame payload
```

HEADERSフレームのペイロードには、次のフィールドがあります。

シーケンス番号：ヘッダブロックシーケンスの最初のフレームにのみ存在します。 これは、最初のヘッダーブロックシーケンスでゼロに設定しなければならず、各ヘッダーブロックで増加しなければなりません。

同じストリーム上で、EHBフラグがセットされていなHEADERSフレームの次のフレームは、別のHEADERSフレームである必要があります(MUST)。  受信者は、他のタイプのフレームの受信をHTTP_INTERRUPTED_HEADERSのストリームエラーとして扱わなければならない（MUST）。 （QUICは他のストリームからのデータをフレーム間に散在させることができ、フレームの送信中でも、この要件によって多重化がブロックされないことに注意してください）。

ヘッダーブロックは、EHBが設定されていない0以上のHEADERSフレームのシーケンスに含まれ、その後にEHBが設定されたHEADERSフレームが続きます。

受信時に、ヘッダーブロック（HEADERS、PUSH_PROMISE）をHPACKデコーダが順に処理しなければなりません(MUST)。 ブロックが見つからない場合、それ以降のすべてのHPACKフレームは到着するか、接続が終了するまで保持されなければなりません（MUST）。

シーケンスカウンタがその最大値（0xFFFF）に達すると、次の増加は0に戻ります。 前の値0のヘッダブロックが受信されたことが確認されるまで、エンドポイントはシーケンスカウンタを0に戻してはいけません（MUST NOT）。

### 5.2.2.  PRIORITY
PRIORITY（type = 0x02）フレームは、ストリームの送信者が望む優先度を指定し、実質的に[RFC7540]とは異なる。 順序付けをサポートするためには、接続コントロールストリームでのみ送信する必要があります（MUST）。 このフォーマットは、オンストリームで送信されず、QUICのより大きなストリームIDスペースに対応するように変更されました。

Stream Dependency、Weight、EフラグのセマンティクスはHTTP/2と同じです。

定義されているフラグは次のとおりです：
E（0x01）：ストリーム依存性が排他的であることを示す（[RFC7540]セクション5.3を参照）。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                   Prioritized Stream (32)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                    Dependent Stream (32)                      |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |   Weight (8)  |
      +-+-+-+-+-+-+-+-+

                     Figure 3: PRIORITY frame payload
```

PRIORITYフレームのペイロードには、次のフィールドがあります：

Prioritized Stream：優先度が更新されるメッセージコントロールストリームの32ビットストリーム識別子。
Stream Dependency：このストリームが依存するストリームの32ビットのストリーム識別子（セクション4.3および{！RFC7540}}セクション5.3を参照）。
Weight：ストリームの優先度重みを表す符号なし8ビット整数。[RFC7540] セクション5.3参照。 値を1に加算して、1〜256の重みとなります。

PRIORITYフレームは9オクテットのペイロード長を持たなければなりません。 他の長さのPRIORITYフレームは、HTTP_MALFORMED_PRIORITYタイプの接続エラーとして扱われなければならなりません（MUST）。

### 5.2.3.  SETTINGS
SETTINGSフレーム（タイプ= 0x4）は、エンドポイントがどのように通信するかに影響を与える設定パラメータ（ピア動作のプリファレンスや制約など）を伝え、[RFC7540]とは大きく異なります。

 個別に、SETTINGSパラメータを "setting" と呼ぶこともできます。


SETTINGSパラメータはネゴシエーションされません。 それらは、受信ピアによって使用される送信ピアの特性を記述します。ただし、ネゴシエーションはSETTINGSを使用することによって暗黙的に行うことができます。ピアはSETTINGSを使用してサポートされている値のセットを宣言します。 受信者は、このリストから受入れることができるエントリを選択し、選択した値で動作することができます。 （この選択は、拡張フレームのフィールドで、またはSETTINGSの独自の値で通知できます）。

各ピアは異なる値の同じパラメータを広告できます。例えば、クライアントがとても大きなHPACKのテーブルを許可し、一方でサーバはメモリを節約するために小さい値を選択します。 パラメータは複数回現れてはいけません（MUST NOT）。 受信者は、同一のパラメータの存在をHTTP_MALFORMED_SETTINGSの接続エラーとして2回以上扱うかもしれません（MAY）。

SETTINGSフレームはフラグを定義しません。

SETTINGSフレームのペイロードは0以上のパラメータで構成され、各パラメータは符号なし16ビットのsetting識別子と長さの付いたバイナリで構成されます。


```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |        Identifier (16)        |         Length (16)           |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                          Contents (?)                       ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                      Figure 4: SETTINGS value format
```

長さゼロのContents は、設定値がブール値であり、true であることを示します。 falseは、settingがないことによって示されます。

ゼロでない長さの値は、SETTINGSフレームの残りの長さと比較されなければなりません（MUST）。 フレームの終わりを越える値は設定フレームが不正なものとみなされ、HTTP_MALFORMED_SETTINGSタイプの接続エラーを引き起こさなければなりません（MUST）。

実装は理解できないSETTINGS識別子の内容を無視しなければならない（MUST）。

SETTINGSフレームは常に接続に適用され、決して単一のストリームには適用されません。
SETTINGSフレームは、各ピアによって接続コントロールストリームの最初のフレーム（セクション4参照）として送信されなければならず（MUST NOT）、最初に送られなかったり、他のストリームで送信してはいけません（MUST NOT）。 エンドポイントが異なるストリーム上のSETTINGSフレームを受信した場合、エンドポイントはHTTP_SETTINGS_ON_WRONG_STREAMの接続エラーで応答しなければならない(MUST)。

SETTINGSフレームはコネクションの状態に影響します。 正しくないフォーマットや不完全なSETTINGSフレームは、タイプHTTP_MALFORMED_SETTINGSの接続エラー（セクション5.4.1）として扱われなくてはなりません（MUST）。

#### 5.2.3.1.  Integer encoding
整数である設定は、ネットワークバイトオーダーで送信されます。先行するゼロオクテットは供されますが、実装は値を表現するのに必要なだけ量のバイトを使うべきです（SHOULD）。 整数は、転送するのに許可された値よりも大きい値をバイトで表現してはならない（MUST NOT）。


#### 5.2.3.2.  Defined SETTINGS Parameters
次の設定は、HTTP / QUICで定義されています。

SETTINGS_HEADER_TABLE_SIZE（0x1）：最大値が2 ^ 32-1の整数。
SETTINGS_DISABLE_PUSH（0x2）：ブール値として送信されます。 SETTINGS_ENABLE_PUSHを置き換えます
SETTINGS_MAX_HEADER_LIST_SIZE（0x6）：最大値が2 ^ 32-1の整数。

### 5.2.3.3.  Usage in 0-RTT
0-RTT QUIC接続が使用されている場合、クライアントの最初のリクエストは、サーバーのSETTINGSフレームが到着する前に送信されます。 クライアントは少なくともサーバに関する以下の設定をキャッシュするべきです（SHOULD）。

  o  SETTINGS_HEADER_TABLE_SIZE
  o  SETTINGS_MAX_HEADER_LIST_SIZE

クライアントは、サーバの現在の設定が受信されるまで、キャッシュされた設定に従わなければならない（MUST）。 クライアントがキャッシュされた値を持たない場合は、次の値を仮定すべきです（SHOULD）。

   o  SETTINGS_HEADER_TABLE_SIZE: 0 octets
   o  SETTINGS_MAX_HEADER_LIST_SIZE: 16,384 octets

サーバはクライアントからの転送中のデータを受信中に現在の設定を上回るデータを処理しても良いです(MAY)。この場合、クライアントは受信時にすぐに新しい設定を適用する必要があります(MUST)。

0-RTTの転送中に（例えばHTTP_HPACK_DECOMPRESSION_FAILEDで）これらの制約または他の制約に違反して接続がクローズされた場合、クライアントは新しい接続を確立し、クローズされた接続でサーバによって送信された設定を使用して0-RTT要求を再試行することができます(MAY)。 （これは、再試行が安全な要求のみが0-RTTで送信されることを前提としています）。

  SETTINGSフレームが受信される前に接続がクローズされた場合、クライアントはキャッシュされた値を破棄し、次の接続で上記のデフォルト値を使用するべきである（SHOULD）。

### 5.2.4.  PUSH_PROMISE
PUSH_PROMISEフレーム（type = 0x05）は、HTTP/2のように、サーバーからクライアントへのリクエストヘッダーセットを転送するために使用されます。 フラグを定義されません。

```
       0                   1                   2                   3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |                   Promised Stream ID (32)                     |
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      |       Sequence? (16)          |         Header Block (*)    ...
      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

                   Figure 5: PUSH_PROMISE frame payload
```
ペイロードは、

Promised Stream ID：レスポンスヘッダーが送信されるQUICストリームを示す32ビットのストリームID。 （レスポンスボディは、ストリームはセクション4で定義されているようにヘッダストリームによって暗示される）

HPACK Sequence：HEADERSのSequenceフィールドに相当する16ビットカウンタ。

Header Block：プッシュされるレスポンスに対応するHPACK圧縮されたリクエストヘッダ。


# 6.  Error Handling
QUICでは、エラーが発生したときにアプリケーションが個々のストリームや接続全体を突然終了させることができます。 これらは「ストリームエラー」または「コネクションエラー」と呼ばれ、[QUIC-TRANSPORT]で詳しく説明されています。

HTTP / QUICでは、突然終了するのはデータストリームのみである必要があります。 メッセージコントロールストリームを終了すると、タイプHTTP_RST_CONTROL_STREAMのエラーが発生します。

このセクションでは、接続またはストリームエラーの原因を表すために使用できるHTTP固有のエラーコードについて説明します。

6.1.  HTTP-Defined QUIC Error Codes
QUICはエラーコード0x0000-0x3FFFをアプリケーションプロトコル定義に割り当てます。HTTPでは、 QUIC RST_STREAM、GOAWAY、およびCONNECTION_CLOSEフレームで使用するエラ－コードが以下のように定義されます。

HTTP_PUSH_REFUSED（0x01）：サーバーは、このコネクションでクライアントが受け入れないコンテンツをプッシュしようとしました。

HTTP_INTERNAL_ERROR（0x02）：HTTPスタックで内部エラーが発生しました。

HTTP_PUSH_ALREADY_IN_CACHE（0x03）：サーバーは、クライアントがキャッシュしているコンテンツをプッシュしようとしました。

HTTP_REQUEST_CANCELLED（0x04）：クライアントは要求されたデータを必要としなくなりました。

HTTP_HPACK_DECOMPRESSION_FAILED（0x05）：HPACKがフレームの復号に失敗し、続行できません。

HTTP_CONNECT_ERROR（0x06）：CONNECTリクエストににレスポンスして確立された接続がリセットされたか、異常終了しました。

HTTP_EXCESSIVE_LOAD（0x07）：エンドポイントが、ピアが負荷を発生している可能性のある動作を示していることを検出しました。

HTTP_VERSION_FALLBACK（0x08）：要求された操作はHTTP / QUICで処理できません。ピアはHTTP/2で再試行する必要があります。

HTTP_MALFORMED_HEADERS（0x09）：HEADERSフレームが無効な形式で受信されました。

HTTP_MALFORMED_PRIORITY（0x0A）：PRIORITYフレームが無効な形式で受信されました。

HTTP_MALFORMED_SETTINGS（0x0B）：SETTINGSフレームが無効な形式で受信されました。

HTTP_MALFORMED_PUSH_PROMISE（0x0C）：PUSH_PROMISEフレームが無効な形式で受信されました。

HTTP_INTERRUPTED_HEADERS（0x0E）：End Header BlockフラグのないHEADERSフレームの後に、HEADERS以外のフレームが続きました。

HTTP_SETTINGS_ON_WRONG_STREAM（0x0F）：リクエストコントロールストリームでSETTINGSフレームが受信されました。

HTTP_MULTIPLE_SETTINGS (0x10):  一つより多くSETTINGSフレームを受信しました。

HTTP_RST_CONTROL_STREAM (0x11): メッセージコントロールストリームが突然クローズしました。

# 7.  Considerations for Transitioning from HTTP/2
HTTP/QUICはHTTP/2の情報を利用しています、多くの類似点があります。 このセクションでは、HTTP/2との重要な違いを指摘し、HTTP/2拡張をHTTP / QUICにマッピングする方法について説明します。

## 7.1.  HTTP Frame Types
トランスポートがそれらを扱うので、HTTP/2からの多くのフレーミングの概念をQUICで省略することができます。 フレームはすでにストリーム上にあるので、ストリーム番号を省略することができます。フレームは多重化をブロックしないので（QUICの多重化はこのレイヤーの下で行われます）、可変長最長パケットのサポートは削除できます。 ストリームの終了はQUICによって処理されるため、END_STREAMフラグは必要ありません。

フレームのペイロードは主に[RFC7540]から利用しています。しかし、HTTP/2に存在する多くの機能（例えば、フロー制御）がQUICに含まれています。このような場合、HTTPマッピングはそれらを再実装しません。    その結果、HTTP/QUICではいくつかのHTTP/2フレームタイプは必要ありません。 HTTP/2定義フレームが使用されなくなった場合、HTTP/2とHTTP / QUIC実装の移植性を最大にするためにフレームIDが予約されています。 しかし、2つのマッピング間の同じフレームタイプであってもまったく同じではありません。

この違いの多くは、HTTP/2がすべてのストリーム間、フレーム間で完全な順序付けを提供しており、QUICは各ストリームでのみこの保証を提供するために生じます。  結果として、異なるストリームからのフレームが送信された順序とは異なる順番で受信されることを各フレームタイプが前提とするので、HTTP/QUICはHTTP/2の前提がなりたちません。

例えば、HTTP/2優先度付け方式に暗黙的に含まれるのは、優先度の変更（すなわち、依存ツリーの変更）は順番通りの配送の概念です。  サブツリーの親の変更などの依存関係ツリーへの操作は可換ではないため、両方のピアがストリームの依存ツリーの一貫した状態を持つことを確実にするために、送信者と受信者の両方を同じ順序で適用する必要があります。HTTP/2はPRIORITYフレームと（オプションで）HEADERSフレームで優先度の割り当てを指定します。 HTTP/QUICの優先順位の変更を順序どおりにで配送するために、PRIORITYフレームが接続コントロールストリームで送信され、PRIORITY部分がHEADERSフレームから削除されます。

この問題以外に、HTTP/2のフレームタイプの拡張は、HTTP/2のストリーム0をHTTP/QUICのストリーム3に置き換えるだけで、通常はQUICに移植可能です。

以下は、各HTTP/2フレームタイプがどのようにマッピングされているかのリストです：

DATA（0x0）：DATAフレームの代わりに、HTTP / QUICは個別のデータストリームを使用します。セクション4を参照してください。

HEADERS（0x1）：上記のように、HEADERSのPRIORITY領域はサポートされていません。別個のPRIORITYフレームを使用しなければならない（MUST）。パディングはHTTP/QUICフレームで定義されていません。セクション5.2.1を参照してください。

PRIORITY（0x2）：前述のように、PRIORITYフレームは接続コントロールストリーム上で送信されます。セクション5.2.2を参照してください。

RST_STREAM（0x3）：QUICはストリームライフサイクル管理を提供するため、RST_STREAMフレームは存在しません。

SETTINGS（0x4）：SETTINGSフレームは、コネクションの開始時にのみ送信されます。 セクション5.2.3とセクション7.2を参照してください。

PUSH_PROMISE（0x5）：セクション5.2.4を参照してください。

PING（0x6）：QUICは同等の機能を提供するため、PINGフレームは存在しません。

GOAWAY（0x7）：GOAWAYは同等の機能を提供するため、GOAWAYフレームは存在しません。

WINDOW_UPDATE（0x8）：QUICはフロー制御を提供するため、WINDOW_UPDATEフレームは存在しません。

CONTINUATION（0x9）：CONTINUATIONフレームは存在しません。代わりに、HTTP/2より大きいHEADERS / PUSH_PROMISEフレームが許可され、HEADERSフレームを連続して使用することができます。

セクション9.3でフレームタイプのIANAレジストリが更新され、HTTP/2とHTTP / QUICの各フレームタイプの定義への参照が含まれています。 HTTP / QUICで利用可能であると定義されていないフレームは送信されてはならず、受信時にunknownとして無視されるべきである（SHOULD）。

## 7.2.  HTTP/2 SETTINGS Parameters
HTTP/2との重要な違いは、settingsがコネクションの初めに1回送信され、その後は変更できないことです。    これにより、変更の同期に関する多くのコーナーケースが排除されます。

HTTP/2がSETTINGSフレームで指定するいくつかのトランスポートレベルオプションは、HTTP / QUICのQUICトランスポートパラメータによって置き換えられます。 HTTP / QUICに保持されるHTTPレベルのオプションは、HTTP/2と同じ値になります。

SETTINGS_HEADER_TABLE_SIZE：5.2.3.2項を参照してください。

SETTINGS_ENABLE_PUSH：5.2.3.2項のSETTINGS_DISABLE_PUSHを参照してください。

SETTINGS_MAX_CONCURRENT_STREAMS：QUICは、最初のトランスポートハンドシェイクで指定される1接続あたりの受け付けるストリームの最大数を要求します。 SETTINGSフレームでSETTINGS_MAX_CONCURRENT_STREAMSを指定するとエラーになります。

SETTINGS_INITIAL_WINDOW_SIZE：QUICでは、ストリーム転送と接続フロー制御ウィンドウの両方のサイズを初期転送ハンドシェイクで指定する必要があります。 SETTINGSフレームでSETTINGS_INITIAL_WINDOW_SIZEを指定するとエラーになります。

SETTINGS_MAX_FRAME_SIZE：この設定には、HTTP / QUICでは対応しません。 SETTINGSフレームで指定するとエラーになります。

SETTINGS_MAX_HEADER_LIST_SIZE：5.2.3.2項を参照してください。

HTTP/2の拡張として定義されているsettingsは最大 2^32-1 の値で表現されうります(MAY)、もしHTTP/QUICに適用できる場合は、その使い方に関する仕様があるべきです(SHOULD)。 この目的のためのフィールドは、セクション9.4のIANAレジストリに追加されました。

## 7.3.  HTTP/2 Error Codes
QUICは、HTTP/2が提供する "ストリーム"と "接続"エラーと同じ概念を持っています。 ただし、エラーコードスペースは複数のコンポーネント間で共有されるため、HTTP/2エラーコードの直接の移植性はありません。

[RFC7540]のセクション で定義されたHTTP/2エラーコードは、次のようにQUICエラーコードにマッピングされます：

NO_ERROR（0x0）：QUIC_NO_ERROR

PROTOCOL_ERROR（0x1）：単一のマッピングはありません。セクション6.1で定義されている新しいHTTP_MALFORMED_ *エラーコードを参照してください。

INTERNAL_ERROR（0x2）：セクション6.1のHTTP_INTERNAL_ERROR

FLOW_CONTROL_ERROR（0x3）：QUICがフロー制御を処理するため、該当しません。 QUICレイヤーからQUIC_FLOW_CONTROL_RECEIVED_TOO_MUCH_DATAを引き起こします。

SETTINGS_TIMEOUT（0x4）：SETTINGSの承認が定義されていないため、該当しません。

STREAM_CLOSED（0x5）：QUICがストリーム管理を処理するため、該当しません。 QUICレイヤからQUIC_STREAM_DATA_AFTER_TERMINATIONを引き起こします。

FRAME_SIZE_ERROR（0x6）単一マッピングはありません。 セクション6.1で定義されている新しいエラーコードを参照してください。

REFUSED_STREAM（0x7）：QUICがストリーム管理を処理するため、該当しません。 QUICレイヤからQUIC_TOO_MANY_OPEN_STREAMSを呼び起こすでしょう。

CANCEL（0x8）：セクション6.1でHTTP_REQUEST_CANCELLED。

COMPRESSION_ERROR（0x9）：セクション6.1のHTTP_HPACK_DECOMPRESSION_FAILED

CONNECT_ERROR（0xa）：セクション6.1のHTTP_CONNECT_ERROR

ENHANCE_YOUR_CALM（0xb）：セクション6.1のHTTP_EXCESSIVE_LOAD

INADEQUATE_SECURITY（0xc）：QUICはすべてのコネクションに十分なセキュリティを提供すると想定されるため、該当しません。

HTTP_1_1_REQUIRED（0xd）：セクション6.1のHTTP_VERSION_FALLBACK。

HTTP/2拡張で定義されているエラーコードは、引き続き適用可能な場合はHTTP / QUIC用に再登録する必要があります。 セクション9.5を参照してください。

# 8.  Security Considerations
QUICを介したHTTPのセキュリティに関する考慮事項は、HTTP/2のものと同等でなければなりません。

変更されたSETTINGS形式にはネストされた長さ要素が含まれているため、慎重でない実装者にとってセキュリティ上のリスクが発生する可能性があります。 SETTINGSフレームパーサーは、フレームの長さが含まれている設定の長さと正確に一致することを保証しなければならない（MUST）。

# 9.  IANA Considerations
略

# 10. References
略