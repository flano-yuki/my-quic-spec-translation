QUIC                                                      M. Thomson, Ed.

インターネットドラフト                                    Mozilla
Intended status: Standards Track                          S. Turner, Ed.
期限: 2017年12月15日
                                                           2017年6月13日

                    セキュアなQUICのためのTLSの使用
                         draft-ietf-quic-tls-04

# Abstract

 この文書はどのようにセキュアなQUICにTLSが使われるかを説明します

# 読者への注釈

 このドラフトの議論は https://mailarchive.ietf.org/arch/search/?email_list=quic.
 にアーカイブされる QUICワーキンググループメーリングリスト (quic@ietf.org) で行われています

 ワーキンググループの情報は https://github.com/quicwg で見ることが出来ます。
 このドラフトのためのソースコードと提案の一覧は https://github.com/quicwg/base-drafts/labels/tls.
 で見ることが出来ます。

# この文書の状況

  このインターネットドラフトはBCP78とBCP79の規定に完全に準拠し提出されます。

  インターネットドラフトは Internet Engineering Task Force (IETF)の書類の作業です。
  他の団体への通達もまたインターネットドラフトとして書類の作業が配布します。
  現行のインターネットドラフトのリストは http://datatracker.ietf.org/drafts/current/ です。

  インターネットドラフトは最大六ヶ月草稿文書の有効性をもち、
  いつでも他の文書により更新、置換、廃止されるかもしれません。
  インターネットドラフトを参照文献や"作業中"としてではなく参照することは不適切です。
  このインターネットドラフトは2017/12/15に廃止される予定です。


# 著作権表示

   Copyright (c) 2017 IETF Trust and the persons identified as the
   document authors.  All rights reserved.





Thomson & Turner        Expires December 15, 2017               [Page 1]

Internet-Draft                QUIC over TLS                    June 2017


   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

# 目次

   1.  導入  . . . . . . . . . . . . . . . . . . . . . . . .   3  
   2.  表記と用語  . . . . . . . . . . . . . . . . . . .   4  
   3.  プロトコル概略 . . . . . . . . . . . . . . . . . . . . . .   4  
     3.1.  TLS 概略  . . . . . . . . . . . . . . . . . . . . . .   5  
     3.2.  TLS ハンドシェイク . . . . . . . . . . . . . . . . . . . . . .   6  
   4.  TLS 使用法 . . . . . . . . . . . . . . . . . . . . . . . . . .   7  
     4.1.  ハンドシェイク と 設定手順  . . . . . . . . . . . . . .   7  
     4.2.  TLSへのインターフェース  . . . . . . . . . . . . . . . . . . . .   9  
       4.2.1.  ハンドシェイク インターフェース . . . . . . . . . . . . . . . . .   9  
       4.2.2. ソースアドレス検証   . . . . . . . . . . . . . .  10  
       4.2.3.  鍵準備イベント   . . . . . . . . . . . . . . . . . .  11  
       4.2.4.  暗号鍵エクスポート  . . . . . . . . . . . . . . . . . . . .  12  
       4.2.5.  TLS インターフェース まとめ . . . . . . . . . . . . . . . .  12  
     4.3.  TLS バージョン . . . . . . . . . . . . . . . . . . . . . . .  13  
     4.4.  ClientHello サイズ  . . . . . . . . . . . . . . . . . . . .  13  
     4.5.  ピアー 認証 . . . . . . . . . . . . . . . . . . .  13  
     4.6.  TLS エラー  . . . . . . . . . . . . . . . . . . . . . . .  14  
   5.  QUIC パケット保護  . . . . . . . . . . . . . . . . . . .  14  
     5.1.  新しい鍵の入手 . . . . . . . . . . . . . . . . . . .  14  
     5.2.  QUIC 鍵 拡張  . . . . . . . . . . . . . . . . . . .  15  
       5.2.1.  0-RTT 秘密鍵  . . . . . . . . . . . . . . . . . . . .  15  
       5.2.2.  1-RTT 秘密鍵 . . . . . . . . . . . . . . . . . . . .  15  
       5.2.3.  パケット保護 鍵 と IV  . . . . . . . . . . . .  17  
     5.3.  QUIC AEAD 使用法 . . . . . . . . . . . . . . . . . . . . .  17  
     5.4.  Packet Numbers  . . . . . . . . . . . . . . . . . . . . .  18  
     5.5.  保護されたパケットの受信 . . . . . . . . . . . . . . .  19  
     5.6.  Packet Number 差分  . . . . . . . . . . . . . . . . . . .  19  
   6.  暗号化されないパケット . . . . . . . . . . . . . . . . . . . . .  19  
     6.1.  完全性確認手順  . . . . . . . . . . . . . . .  19  
     6.2.  64-ビット FNV-1a アルゴリズム . . . . . . . . . . . . . . .  20  
   7.  キーフェーズ  . . . . . . . . . . . . . . . . . . . . . . . . .  20  
     7.1.  TLSハンドシェイクのためのパケット保護 . . . . . . . . .  21  
       7.1.1.  初期鍵遷移 . . . . . . . . . . . . . . .  21  
       7.1.2.  再送と保護されないパケットの承認 Packets . . . . . . . . . . . . . . . . . . . . . . .  22  
     7.2.  鍵の更新  . . . . . . . . . . . . . . . . . . . . . . .  23  
   8.  クライアントアドレス検証  . . . . . . . . . . . . . . . . . .  24  
     8.1.  HelloRetryRequest アドレス検証   . . . . . . . . . .  24  
       8.1.1.  Stateless アドレス検証  . . . . . . . . . . . .  25  
       8.1.2.  HelloRetryRequestの送信 . . . . . . . . . . . . . .  26  
     8.2.  NewSessionTicket アドレス検証 . . . . . . . . . . .  26  
     8.3.  アドレス検証トークンの完全性  . . . . . . . . . . .  27  
   9.  ハンドシェイク前 QUIC メッセージ . . . . . . . . . . . . . . . . .  27  
     9.1.  ハンドシェイクの完了以前の保護されないパケット . . . .  28  
       9.1.1.  STREAM フレーム . . . . . . . . . . . . . . . . . . . .  28  
       9.1.2.  ACK フレーム  . . . . . . . . . . . . . . . . . . . . .  28  
       9.1.3.  データの更新とストリーム制限 . . . . . . . . . .  29  
       9.1.4.  保護されないパケットに伴うサービスの拒否  . . . . .  29  
     9.2.  0-RTT 鍵の使用 . . . . . . . . . . . . . . . . . . . .  30  
     9.3.  順不同の保護されたフレームの受信 . . . . . . . . .  30  
   10. TLSハンドシェイクへのQUIC拡張  . . . . . . . .  31  
     10.1.  プロトコルとヴァージョンのネゴシエーション . . . . . . . . . . . .  31  
     10.2.  QUIC トランスポートパラメータ拡張 . . . . . . . . . .  31  
     10.3.  0-RTTの誘導 . . . . . . . . . . . . . . . . . . . . .  32  
   11. セキュリティへの考察 . . . . . . . . . . . . . . . . . . .  32  
     11.1.  パケット反射攻撃の緩和  . . . . . . . . . .  33  
     11.2.  ピアーのサービス拒否 . . . . . . . . . . . . . . . . .  33  
   12. エラーコード . . . . . . . . . . . . . . . . . . . . . . . . .  33  
   13. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  34  
   14. 参照  . . . . . . . . . . . . . . . . . . . . . . . . .  34  
     14.1.  基本的な参照 . . . . . . . . . . . . . . . . . .  34  
     14.2.  有益な参照 . . . . . . . . . . . . . . . . .  35  
   Appendix A.  Contributors . . . . . . . . . . . . . . . . . . . .  36  
   Appendix B.  Acknowledgments  . . . . . . . . . . . . . . . . . .  36  
   Appendix C.  Change Log . . . . . . . . . . . . . . . . . . . . .  36  
     C.1.  Since draft-ietf-quic-tls-02  . . . . . . . . . . . . . .  36  
     C.2.  Since draft-ietf-quic-tls-01  . . . . . . . . . . . . . .  36  
     C.3.  Since draft-ietf-quic-tls-00  . . . . . . . . . . . . . .  37  
     C.4.  Since draft-thomson-quic-tls-01 . . . . . . . . . . . . .  37  
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  37  

1.  導入

この文書はどのようにQUICがトランスポートレイヤーセキュリティ(TLS)　ヴァージョン1.3 [T-D.ietf-tls-tls13]
を用いて保護されているかを説明します。
TLS1.3は以前のバージョンに対して、コネクション確立においての決定的なレイテンシーの向上
を提供します。パケット損失がなければ、ほとんどの新たなコネクションは
単一のラウンドトリップでの確立と保護を行うことが出来ます。
同一のサーバとクライアントの間で、続くコネクションにおいて、
クライアントはしばしば直ちにデータを送ることができます。
すなわち、ゼロラウンドトリップ設立を使っていることを意味します。

この文書は標準化されたTLS1.3がQUICのセキュリティ部分としてどのように振る舞うかを説明します。
TLS1.2に対しても同様の設計を行うことが出来ます。
ですが、QUICの提供する利点のいくらかは、TLS1.3を用いたハンドシェイクレイテンシー
を扱うさいにより感じることが出来ます。

2.  表記と用語

   The words "MUST", "MUST NOT", "SHOULD", and "MAY" are used in this
   document.  It's not shouting; when they are capitalized, they have
   the special meaning defined in [RFC2119].

この文書は[QUIC-TRANSPORT]において確率した用語を用います。

端的に述べるため、TLSの略語がTLS1.3への参照として用いられます。

TLSへの一部へ参照するとき、TLSの用語が用いられます。
TLSがオクテットの連続するストリームを仮定するにもかかわらず、
それはストリームをレコードに分割します。もっともQUICに関係するのは
TLS ハンドシェイクメッセージを含むレコードです。
それは鍵合意、認証、パラメータネゴシエーションのための離散的なメッセージです。
一般的に、TLSレコードはアプリケーションデータを含むことが出来ます。
にもかかわらず、QUICの仕様においてはTLSアプリケーションデータを用いることはありません。

3.  プロトコル概略

QUIC [QUIC-TRANSPORT] は機密性への責任とパケットの保護生後性を仮定します。
これはTLS1.3コネクションより導入された鍵を使用します。
また、QUICはTLS1.3の認証とセキュリティと性能に重大なパラメータのネゴシエーション
に依存します。

厳密に分割されると言うよりは、これら２つのプロトコルは相互に依存します。
QUICはTLSハンドシェイクを用い、TLSはQUICストリームから提供される信頼性と
順序付けられた配送を用います。

この文書はどのようにQUICがTLSとやり取りをするかを定義します。
これはどのようにTLSが使われ、どのようにキーマテリアルがTLSから提供され、
またQUICのパケットの保護のためにキーマテリアルの申請が使われるかの説明を含みます。
図1は呼び出されるQUICパケット保護と共に基本的なTLSとQUICの間のやりとりを説明します。










   +------------+                        +------------+
   |            |------ Handshake ------>|            |
   |            |<-- Validate Address ---|            |
   |            |-- OK/Error/Validate -->|            |
   |            |<----- Handshake -------|            |
   |   QUIC     |------ Validate ------->|    TLS     |
   |            |                        |            |
   |            |<------ 0-RTT OK -------|            |
   |            |<------ 1-RTT OK -------|            |
   |            |<--- Handshake Done ----|            |
   +------------+                        +------------+
    |         ^                               ^ |
    | Protect | Protected                     | |
    v         | Packet                        | |
   +------------+                             / /
   |   QUIC     |                            / /
   |  Packet    |-------- Get Secret -------' /
   | Protection |<-------- Secret -----------'
   +------------+

                    図 1: QUIC と TLS のやり取り

QUICコネクションの初期状態はなんらかの保護の形式なくパケットを交換します。
この状態においてQUICはstream 0と関連したパケットの使用に制限されます。
Stream 0はTLSコネクションのために予約されます。
これはover TCPとして階層づけられたときに現れる完全なTLSコネクションとされるものです。
ただ一つの違いは、QUICは信頼性とTCPによって提供されるときと違った順序付けを提供することです。

TLSハンドシェイクの間に対しかな点はキーマテリアルはQUICが用いるためにTLSコネクションから提供されることです。
このキーマテリアルはパケット保護鍵の提供のために使われます。
どのようにまた、いつ鍵が導かれるかの詳細はセクション5に含まれます。

# 3.1.  TLS 概略

TLSは２つのエンドポイントが信用できない媒体（インターネット）を越えて
観察、修正、偽造されない交換されるメッセージを確保する方法を確立することを
提供します。

TLSの機能は２つの基本機能に分割することができます。
認証された鍵交換とレコードの保護です。
QUICは主にTLSに寄って提供される認証された鍵交換を主に用い、
自らでパケット保護を提供します。

TLSの認証された鍵交換は２つの実体、クライアントとサーバの間で起こります。
クライアントは交換をはじめ、サーバが応答します。




もし鍵交換が完全に成功すると、クライアントとサーバとの両方は
秘密鍵を了承します。TLSは事前共有鍵（PSK)とDiffie-Hellman（DH)鍵交換の
両方を保証します。PSKは0-RTTの基礎です。
DH鍵が消滅したとき、後者は完全な前方安全性(PFS)を提供します。

TLSハンドシェイクの完了のあと、
クライアントはサーバーへの一意性を認証し備え、また
サーバは必要に応じてクライアントへの一意性を認証し備えることができます。
TLSはX.509[RFC5280] 証明書ベース認証をサーバとクライアントの両方にサポートします。

TLS鍵交換は攻撃者による改ざんに抵抗しまたいかなる特定のピアーに操作されることのない
秘密鍵の処理です。

# 3.2.  TLS ハンドシェイク

TLS 1.3はQUICにとって興味深い２つの基本的なハンドシェイクの様式を提供します。

- クライアントが1ラウンドトリップののちアプリケーションデータを送ることの出来、
サーバーがクライアントからの最初のハンドシェイクメッセージ受け取った後即座に行える
完全な1RTTハンドシェイク

-  クライアントが前回知った即座にアプリケーションデータを送るためのサーバの情報を用いる0-RTTハンドシェイク。
このアプリケーションデータは攻撃者によって再現されうるため、これはべき等性のない自己完結した原因によって
引き起こされてはいけません（MUST NOT)

0-RTT アプリケーションデータを共に、単純化されたTLS1.3ハンドシェイクは図1に示されます。
より詳細は [I-D.ietf-tls-tls13]を見てください。

       Client                                             Server

       ClientHello
      (0-RTT Application Data)  -------->
                                                     ServerHello
                                            {EncryptedExtensions}
                                                       {Finished}
                                <--------      [Application Data]
      (EndOfEarlyData)
      {Finished}                -------->

      [Application Data]        <------->      [Application Data]

                    図 2: TLS Handshake with 0-RTT





この0-RTTハンドシェイクはクライアントとサーバが以前通信したときのみ可能です。
1-RTTハンドシェイクにおいて、クライアントは保護されたアプリケーションデータを
それがサーバによって送られるハンドシェイクメッセージをすべて受け取るまで送ることが出来ません。

基本的なハンドシェイク交換の２つの追加されたバリエーションはこの文書に関係します。

- サーバはHelloRetryRequestをもつ ClientHelloに応答することが出来ます。
これは基本的な交換より余分なラウンドトリップを加えます。
これはもしサーバがクライアントから異なる鍵交換鍵を要求することを望むなら必要です。
HelloRetryRequestはクライアントがたしかにそれの主張するアドレスのパケットを受け取ることが
出来る証明のためにも用いられます。 ([QUIC-TRANSPORT] を参照)

- 事前共有鍵方式は後に続くハンドシェイクのために公開鍵操作の数々を短縮するために使われます。
これは残りのコネクションが新たなDiffie-Hellman鍵で保護されるとしても、 0-RTTの基本です。

# 4.  TLS 使用法

QUICはTLS接続のためにストリーム番号0を予約します。
ストリーム0はTLSレコード層を含む完全なTLS接続を含みます。
QUICのための拡張(Section 10.2を参照)の定義以外は、この使用のためにTLSは修正されません。
これはTLSが機密性とそのレコードへの完全性のある保護を適用することを意味します。
特にTLSレコード保護はサーバによって送られるTLSハンドシェイクメッセージのための機密性保護のためにあります。

QUICはクライアントがストリームが始まる最初のパケットからフレームを送ることを許可します。
クライアントからの初期化パケットは、クライアントからの最初のTLSハンドシェイクメッセージを含む
stream 0のストリームフレームを含みます。
これはTLSハンドシェイクが最初のパケットからクライアントが送信することを許可します。

QUICパケットはQUICの機能の方式を用いて保護されます。Section 5を参照。
鍵はTLS Exporterを用いて可能になるTLSコネクションから提供されます。
( [I-D.ietf-tls-tls13] の Section 7.5とSection 5.2を参照)
TLSから鍵が提供された後、QUICは自らの鍵の詳細を管理します。


# 4.1.  ハンドシェイクと設定手順

TLSハンドシェイクとのQUICの統合は図3で詳細に示されています。
ストリーム0のQUIC "STREAM" フレームはTLSハンドシェイクを配送します。
QUICはこのストリームへの損失回復を行いまた、TLSハンドシェイクメッセージが
正しい順序で配送されることを保証します。




       Client                                             Server

   @C QUIC STREAM Frame(s) <0>:
        ClientHello
          + QUIC Extension
                               -------->
                           0-RTT Key => @0

   @0 QUIC STREAM Frame(s) <any stream>:
      Replayable QUIC Frames
                               -------->

                                         QUIC STREAM Frame <0>: @C
                                                  ServerHello
                                     {TLS Handshake Messages}
                               <--------
                           1-RTT Key => @1

                                              QUIC Frames <any> @1
                               <--------
   @C QUIC STREAM Frame(s) <0>:
        (EndOfEarlyData)
        {Finished}
                               -------->

   @1 QUIC Frames <any>        <------->      QUIC Frames <any> @1

                     図3: TLSハンドシェイクにおけるQUIC

   図3において, 記号は以下のように意味します :

   -  "<" と ">" は ストリーム番号を囲います.

   -  "@" はQUICパケットを保護するために使われる鍵を示します。
   (C = 平文、完全性のために表記します。; 0 = 0-RTT 鍵; 1 = 1-RTT 鍵).

   -  "(" と ")" は TLS 0-RTT ハンドシェイクかアプリケーション鍵で保護されたメッセージを囲います

   -  "{" と "}" は TLSハンドシェイク鍵で保護されたメッセージを囲います

もし0-RTTが未遂なら、クライアントは0-RTT鍵のよって保護されません。
その場合、クライアントにおける鍵の変化は平文のパケットから1-RTTへ遷移します。
保護に、TLSハンドシェイクメッセージの最後のパケットが送られる後に起こります。



Note: クライアントはハンドシェイクの間に２つの異なった種類の平文パケットを用います。
Client Initial パケットはTLS ClientHelloメッセージを運送します。TLSハンドシェイクの残りは
Client Cleartext パケットに運ばれます。

サーバは保護されないTLSハンドシェイクメッセージ(@C)を送ります。
ハンドシェイクメッセージの最後が送られた後、
サーバの遷移は無保護(@C)から完全な 1-RTT 保護(@1) になります。

いくつかのTLSハンドシェイクメッセージはTLSレコード保護によって保護されます。
これらの鍵はQUICでの使用のためのTLSコネクションから提供されません。

0-RTTデータを送るとき、平文(@C)から0-RTT 鍵(@0)へのクライアント遷移、
そしてTLSハンドシェイクメッセージの２つめの送信の後に続く1-RTT 鍵(@1)。
これは1-RTTに保護されたパケットを受信するための保護されないパケットの見込みを
作ります。

鍵遷移の詳細はSection7.1に含まれます。


# 4.2. TLSへのインターフェース

図1に示されるように、QUICからTLSへの接続は４つの主要な機能です。
ハンドシェイク、ソースアドレス検証、鍵準備イベント、秘密鍵提供

追加の機能はTLSの変更を必要とするでしょう。

# 4.2.1.  ハンドシェイク インターフェース

ハンドシェイクを運用するため、TLSはstream 0でハンドシェイクメッセージを送受信できることを要請します。
このインターフェースのためにふたつの基本的な機能があります、
一つはQUICがハンドシェイクメッセージを要求すること、
もうひとつはQUICがハンドシェイクパケットをどこで提供するか
です。

QUICが配送されるべきトランスポートパラメータ(Section 10.2を参照)付きのTLSを提供するハンドシェイクを
始める前に、

QUICクライアントはTLSからTLSハンドシェイクオクテットを始めます。
クライアントは最初のパケットを送る前にハンドシェイクオクテットを得ます。





QUICサーバはstream 0オクテットの提供のための処理を始めます。

毎回、stream 0のデータをエンドポイント受け取る時、
それは可能ならTLSにオクテットを配送します。

stream 0においてデータをうけとるときは毎回、
可能ならTLSにオクテットを配送します。
新しいデータと共に提供されるTLSは毎回、新たしいハンドシェイクオクテットがTLSから
提供されます。
もし受け取ったハンドシェイクメッセージが不完全かそれが送るためのデータがないなら
TLSはいかなるオクテットを提供しないかもしれません。

一度、TLSハンドシェイクが完了した場合、
これはTLSが送る必要なるいかなる最終ハンドシェイクオクテットに合わせてQUICへ示されます。

一度ハンドシェイクが完了したなら、TLSは受動的になります。
TLSはまだそのピアーからデータを受け取り、同じように応答することが出来ます。
しかし、それは特定の要求なしにより多くのデータを送る必要はありません、
アプリケーションにもQUICにもです。
データを送る一つの理由はサーバがクライアントへセッションチケットの
追加もしくは更新を提供することを望むかもしれないからです。

ハンドシェイクが完了するとき、ただQUICはTLSにstream 0へ来るいかなるデータを提供
するです。
同じ理由で、ハンドシェイクの間、新しいデータはTLSから受信されたデータを提供することを要求されます。


Important:
ハンドシェイクが完了と通知されるまで、コネクションと鍵交換は主に
サーバで適切に認証されません。
クライアントからサーバへ最初のハンドシェイクメッセージを受け取った後
1-RTT鍵が使用可能であっても、サーバはクライアントの終了メッセージを
受取り検証するまで認証されたものと考えることは出来ません。

クライアント終了メッセージを待つサーバへの要件は配達されたメッセージへの
依存を作ります。
クライアントは複数のパケットに終了メッセージが運ばれたSTREAMフレームの複製が送られること
が暗示するhead-of-line blockingの可能性を避けることが出来ます。
これはサーバがこれらのパケットへのただちに行うことをできるようにします。

# 4.2.2.  ソースアドレス検証

TLS ClientHelloの処理の間、TLSは転送がクライアントからソースアドレス検証を要求するかどうか
決めることを要求します。

セッションを再開する初期TLS ClientHello はセッションチケットに
アドレス検証トークンを含みます。
これを0-RTT におけるすべての試行を含みます。

もしクライアントがセッション再開を試みないなら、
トークンは存在しません。初期ClientHelloの処理の間、
TLSはQUICに存在するなんらかのトークンを提供します。
レスポンスにおいて、QUICはみっつのレスポンスから一つを返します。

- コネクションの処理
- クライアントアドレス検証への応答
- コネクションの中断


もしQUICがソースアドレス検証を要求するなら、
それもまた新たなソースアドレス検証トークンを提供します。
TLSはTLS HelloRetryRequest メッセージのクッキー拡張の要求されたなんらかの情報を含みます。
その他の場合、コネクションは処理するかもしくはハンドシェイクエラーとともに中断します。


クライアントは２つめのClientHelloの中のクッキー拡張に応答します。
有効なクッキー拡張を含むClientHello は常にHelloRetryRequestへのレスポンスが存在します。
もしアドレス検証がQUICから要求されたなら、これはアドレス検証トークンを含むでしょう。
TLSはQUICの二回目のアドレス検証リクエスト - クッキー拡張から展開された値を含みます -を作ります。
このリクエストに対するレスポンスにおいて、QUICはクライアントアドレス検証に応答できません。
それは中断かコネクション試行の進行を許可することのみができます。

QUICはハンドシェイクが完了したあといつでもセッション再送のために使われる新たな
アドレス検証トークンを提供できます。
新たなトークンが提供されたときはいつでも、
TLSがNewSessionTicketメッセージが生成した、チケットの中に含まれたトークンが提供されます。

クライアントアドレス検証の詳細はSection 8を見てください。

# 4.2.3.  Key Ready イベント

0-RTT 鍵や1-RT鍵が使用のために準備されているとき、
TLSはQUICへの通知を提供します。
これらのイベントは非同期ではなく、
彼らは常にTLSにが新たなハンドシェイクオクテットを提供されたあと、
もしくはTLSがハンドシェイクオクテットを処理するあと、
ただちにに起こります。

TLSがハンドシェイクを完了したとき、1-RTT 鍵はQUICへ提供されることができます。
クライアントとサーバの両方に置いて、これはTLS Finished メッセージを送信したあと
起こります。

この順序はフレームに運ばれたTLSハンドシェイクメッセージがアプリケーションデータ利用できるの
と同時に送る準備ができることを意味します。
実装はTLSハンドシェイクメッセージが暗号文パケットの中で送られることを保証しなければいけません(MUST)。



パケットの分割はデータに1-RTT 鍵に保護される必要を要求します。

もし、0-RTT が可能なら、クライアントがTLS ClientHello メッセージを送信するか
サーバがそのメッセージを受け取った後にそれは準備されます。
最初のハンドシェイクオクテットをQUICクライアントに提供した後、
TLSスタックは0-RTT 鍵が準備できたことを通知するかもしれません。
サーバにおいて、ClientHello メッセージを含むハンドシェイクオクテットを受け取った後、
TLSサーバは0-RTT 鍵が使用できることを通知するかもしれません。

1-RTT鍵が双方向に置いてパケットのために使われます。
0-RT 鍵はただクライアントから送られるパケットを保護するためにのみ使われます。

# 4.2.4.  暗号鍵エクスポート

どのようにして暗号鍵がTLSから提供されるかの詳細は5.2章に
含まれます。


# 4.2.5.  TLS インタフェース概略

図4はクライアントとサーバの両方に対して
QUICとTLSの間の交換を要約します。

   Client                                                    Server

   Get Handshake
   0-RTT Key Ready
                         --- send/receive --->
                                                 Handshake Received
                                                    0-RTT Key Ready
                                                      Get Handshake
                                                   1-RTT Keys Ready
                        <--- send/receive ---
   Handshake Received
   Get Handshake
   Handshake Complete
   1-RTT Keys Ready
                         --- send/receive --->
                                                 Handshake Received
                                                      Get Handshake
                                                 Handshake Complete
                        <--- send/receive ---
   Handshake Received
   Get Handshake

            図4: QUICとTLSの間の相互関係の概要






# 4.3.  TLS バージョン

この文書はどのようにTLS 1.3 [I-D.ietf-tls-tls13] がQUICとともに使われるか
を説明します。

実践に置いて、TLSハンドシェイクは仕様のためにTLSのバージョンを交渉するでしょう。
これはもし両方のエンドポイントがバージョンをサポートしているのなら、
交渉された1.3より新しいTLSのバージョンが得ることができます。
これは新しいバージョンによりサポートされたQUICにより使われるTLS1.3の機能が
提供されることを受け入れられます。

不適切に設定されたTLS実装はTLS1.3かそれより古いTLSのバージョンと交渉することができます。
エンドポイントはもしTLS1.3より古いバージョンが交渉されたなら、
コネクションを終了しなくてはいけません(MUST)

# 4.4.  ClientHello サイズ

  QUICはクライアントからの初期化ハンドシェイクパケットがひとつのパケットのペイロードとして
  調整されていることを要求します。
  QUICパケットにおけるサイズ制限はClientHelloを保持するレコードを
  1197オクテットに焼成することを意味します。

  TLS ClientHelloは十分なスペースの残りを備えることが出来ます。
  しかしながら、制限の超過を起こすのに十分な変数が存在します。
  実装は巨大なセッションチケットやHelloRetryRequestクッキー、
  複数もしくは大きなカギ共有、サポートされた暗号、
  シグネチャーアルゴリズム、バージョンの長いリスト、
  QUICトランスポートパラメタまたほかのネゴシエーションパラメタ
  と拡張はメッセージの増量を引き起こすことがあります。


  サーバに対して、セッションチケットと HelloRetryRequest クッキー拡張のサイズは
  接続するクライアントの能力において影響を与えることができます。
  小さな数の増加率を選ぶことはそれらの数値がクライアントにより正しく使われることが出来ます。
  
  TLS実装はClientHelloが十分に大きいことを必要としません。
  QUIC PADDING フレームは必要に応じてパケットのサイズを増加するために追加されます。

# 4.5.  ピアー認証

  認証への要件は使われるアプリケーションプロトコルに依存します。
  TLSはサーバ認証を提供しサーバがクライアント認証を要求することを許可します。

  クライアントはサーバに一意性を認証しなくてはいけません(MUST)
  これは特にサーバの一意性が証明書に含まれまた証明書は信用された
  実体に提案されることの検証を含みます。 (example [RFC2818]を参照)






  サーバはクライアント認証をハンドシェイクの間に要求しても良いです(MAY)
  サーバはもし要求されたときクライアントの認証ができないときコネクションを
  拒否しても良いです(MAY)
  クライアント認証への要件はアプリケーションプロトコルと実装に
  よって変化します。

  サーバは ポストハンドシェイククライアント認証をつかってはいけません(MUST NOT)
  ([I-D.ietf-tls-tls13] の 4.6.2章を参照)


# 4.6.  TLS エラー

  TLSコネクション時のエラーはstream 0のTLSアラートを用いて通知されるべきです(SHOULD)
  ハンドシェイクにおける失敗はTLS_HANDSHAKE_FAILED失敗の
  QUIC コネクションエラー として扱われるべきです(SHOULD)
  一度ハンドシェイクが完了したら、
  TLSアラートの送受信が起こったTLSコネクションにおけるエラーは
  TLS_FATAL_ALERT_GENERATEDもしくはTLS_FATAL_ALERT_RECEIVEDタイプの
  QUIC コネクションエラーとして扱われるべきです(MUST)
   respectively.

# 5.  QUIC パケット保護

   QUICパケットの保護はパケットの認証された暗号化を提供します。
   これはパケットのコンテクストに対して機密性と完全な保護を提供します。
   パケット保護はTLS コネクションから提供された鍵を用います。(5.2章を参照)

  QUICパケット保護とTLS レコード保護には異なる鍵が用いられます。
  TLS ハンドシェイクメッセージはもっぱらTLSレコード保護と共に保護されます。
  しかしポストハンドシェイクメッセージはQUICパケット保護とTLSレコード
  の両方と共に残念ながら保護されます。
  このメッセージは制限されるため、追加のオーバヘッドは小さいです。

# 5.1.  新しい鍵の入手

TLSがキーマテリアルの可用性の通知によって、
パケット保護鍵と初期化ベクター(IV)は更新されます。(5.2章を参照)
AEAD関数の選択もまたTLSにより交渉された適切なAEADのために更新されます。

任意の保護されないハンドシェイクパケット以外のパケット(7.1章を参照)のために
一度鍵の交換が行われたなら、
より大きなパケットナンバーを伴うパケットでは新たなキーマテリアルによって
送信されなくてはいけません(MUST)。

新しい鍵が導入されるたびにそれらのパケットのKEY_PHASEビットは、
新たな鍵の複製の使用を通知するために反転されます。



新たなパケットにおいて、エンドポイントはストリームデータを再送します。
新たなパケットは新たしいパケットナンバーをもち、また最新の
パケット保護鍵を用います。
この単純化された鍵管理は鍵が更新されたときのものです。(7.2章を参照)

# 5.2.  QUIC 鍵拡張

QUICはそのシステムが使うTLSにおいて構造化されたパケット保護秘密鍵、鍵そしてIVの
システムを用います。
QUICがその鍵管理にの基本として用いる秘密鍵はTLSエクスポーターによって
得られます。

QUICは鍵導出のためにTLSが交渉したのと同様のハッシュ関数とともにHKDFを用います。
たとえば、もしTLSがTLS_AES_128_GCM_SHA256を用いるならば、
SHA-256ハッシュ関数が用いられます。

# 5.2.1.  0-RTT 秘密鍵

0-RTT 鍵はTLSハンドシェイクの完了というよりコネクションの再開に使われる鍵です。
0-RTT鍵を用いて送られるデータは再生されるかもしれません、
またその仕様に置いていくつかの制約があります、9.2章を参照。
0-RTT鍵はClientHelloの送受信ののちに使われます。

暗号鍵はエクスポーターラベル "EXPORTER-QUIC 0-RTT Secret"と空のコンテクスト
を使うTLSから提供されます。
暗号鍵のサイズはTLSに交渉されたPRFハッシュ関数のためのハッシュの出力サイズ
でなくてはいけません（MUST)
これはTLS early_exporter_secretを用います。
QUIC 0-RTT 暗号鍵はクライアントから送られるパケットの保護のためだけに使われます。

      client_0rtt_secret
          = TLS-Exporter("EXPORTER-QUIC 0-RTT Secret"
                         "", Hash.length)

# 5.2.2.  1-RTT 暗号鍵

1-RTT鍵はTLSハンドシェイクが完了したあとクライアントとサーバの両方で使われます。
これらの２つの鍵はいつでも使われます。
ひとつはクライアントから送られうパケットのパケット保護鍵の導出のために使われ、
もうひとつはサーバが送られるパケットにおいてパケット保護鍵のためです。

初期化クライアントパケット保護鍵は
エクスポーターラベル "EXPORTER-QUIC client 1-RTT Secret"を用いた
TLSから提供されます。
初期化サーバパケット保護鍵はエクスポーターラベル "EXPORTER-QUIC server  1-RTT Secret"
を用います。
両方のエクスポーターは空のコンテクストを用います。
暗号鍵のサイズはTLSにより交渉されたPRFハッシュ関数のためにハッシュ出力のサイズでなければいけません(MUST)




      client_pp_secret_0
          = TLS-Exporter("EXPORTER-QUIC client 1-RTT Secret"
                         "", Hash.length)
      server_pp_secret_0
          = TLS-Exporter("EXPORTER-QUIC server 1-RTT Secret"
                         "", Hash.length)

これらの秘密鍵は初期化クライアントとサーバパケット保護鍵の導出に用いられます。
鍵更新ののち、これらの秘密鍵は[I-D.ietf-tls-tls13] の7.1章によって定義されるHKDF-Exp-Label 関数
を用いて更新されます。
HKDF-Expand-LabelはTLSにより交渉されたPRFハッシュ関数を用います。
秘密鍵の置換は クライアントには"QUIC Client 1-RTT Secret"のラベルの
サーバには"QUIC Server 1-RTT Secret"のラベル、
空のHashValue、そしてそのPRFのためにTLSが選択したハッシュ関数と
同じ出力の長さの現在の秘密鍵
を用いて導かれます。


      client_pp_secret_<N+1>
          = HKDF-Expand-Label(client_pp_secret_<N>,
                              "QUIC client 1-RTT Secret",
                              "", Hash.length)
      server_pp_secret_<N+1>
          = HKDF-Expand-Label(server_pp_secret_<N>,
                              "QUIC server 1-RTT Secret",
                              "", Hash.length)

これは必要に応じて作られた新しい秘密鍵の継承を許可します。

HKDF-Expand-Labelは以下のように特別にフォーマットされたパラメータとともに
HKDF-Expand [RFC5869] を用います。

       HKDF-Expand-Label(Secret, Label, HashValue, Length) =
            HKDF-Expand(Secret, HkdfLabel, Length)

       Where HkdfLabel is specified as:

       struct {
           uint16 length = Length;
           opaque label<10..255> = "TLS 1.3, " + Label;
           uint8 hashLength;     // Always 0
       } HkdfLabel;

例として、クライアントパケット保護秘密鍵がパラメータを使用するには





Thomson & Turner        Expires December 15, 2017              [Page 16]

Internet-Draft                QUIC over TLS                    June 2017


      info = (HashLen / 256) || (HashLen % 256) || 0x21 ||
             "TLS 1.3, QUIC client 1-RTT secret" || 0x00

# 5.2.3.  パケット保護鍵とIV

完全な鍵拡張は[I-D.ietf-tls-tls13]の7.3章に定義されるような鍵拡張のために
同様の処理を用い、入力された秘密鍵に対して異なる値を用います。
QUICはTLSに交渉されたAEAD関数を用います。

クライアントから送られる0-RTTパケット保護のために用いられたパケット保護鍵とIVは
QUIC 0-RTT秘密鍵から導出されます。
クライアントとサーバから送られた1-RTTパケットはパケット保護鍵とIVは
QUIC 0-RTT 秘密鍵は各々client_pp_secretとserver_pp_secretの現在の生成
から導出されます。
出力の長さはTLSに選ばれたAEAD関数の要件によって決定されます。
鍵の長さはAEAD鍵長です。
任意のsecret Sに対して、以下のように導出された鍵とIVは対応します。


      key = HKDF-Expand-Label(S, "key", "", key_length)
      iv  = HKDF-Expand-Label(S, "iv", "", iv_length)

QUICレコード保護は最初キーマテリアルなしで開始します。
TLSステートマシーンはClientHelloが送られることを報告したとき、
0-RTT鍵は書き込みのために生成し入手されます。
TLSステートマシーンはハンドシェイクの完了を報告したとき、
1-RTT鍵は書き込みのために生成され入手されます。

# 5.3.  QUIC AEAD 仕様

   The Authentication Encryption with Associated Data (AEAD) [RFC5116]
   関数はTLSコネクションにおける使用のために交渉されたAEADがQUICパケット保護の
   ために用いられます。
   たとえば、もしTLSがTLS_AES_128_GCM_SHA256を用いているのなら、
   AEAD_AES_128_GCM関数が用いられます。

正規のQUICパケットはAEADアルゴリズム[RFC5116]によって保護されます。
Version negotiationとpublic resetは保護されません。

一度TLSが鍵を提供したなら、
正規のQUICパケットのコンテンツは任意のTLSメッセージが送られた後直ちに
TLSによって選ばれたAEADによって保護されます。

鍵Kはクライアントパケット保護鍵(client_pp_key_n)また
サーバパケット保護鍵(server_pp_key_n)のどちらかです。
5.2章の定義に由来します。




ナンスNはパケット保護IV(client_pp_iv_nかserver_pp_iv_nのどちらか)と
パケットナンバーの結合によって構成されます。
ネットワークバイトオーダーに再構築されたQUICパケットナンバーの64ビットは
IVのサイズの左をゼロで埋められています。
埋められたパケットナンバーとIVの排他的論理和が
AEADナンスを構築します。


関連するデータAは、AEADにおけるQUICヘッダーのコンテンツ,は
汎用ヘッダーのフラグオクテットから始まります。

入力の平文PはAEADにおけるパケットナンバーから始まる
QUICフレームです。[QUIC-TRANSPORT]において説明されるように。

出力の暗号文Cは、AEADのPに代わって転送されるものです。

TLSが鍵を提供する前はレコード保護なしで振る舞い平文Pが修正なく転送されます。

# 5.4.  パケットナンバー

QUICは単一の累積的なパケットナンバー空間を持ちます。
比較して、TLSはレコード保護鍵が変わるたびにそのシークエンスナンバーを
やり直します。
TLSのシークエンスナンバー再開は現在の転送鍵の妥当性が
攻撃者に鍵更新ののち古い鍵のもとで追加のパケットナンバーを送ることによってデータを
切り捨てることを保証します。(新しいパケットが廃棄されることを起こす)

QUICは信頼性のある転送を仮定しません。
また、攻撃者がなんらかの手段でパケットを損失することを管理します。
QUICはそれゆえにこの切り捨て攻撃の影響をうけません。

QUICパケットナンバーはリセットされませんまた
それは2^64-1 の最大値より大きくなることを許可しません。
これは送ることのできるパケットの数において強い制限を確立します。

いくつかのAEAD関数は同じ鍵とIVの元でどれくらいのパケットが暗号化できるかの
制限をもちます。エンドポイントは鍵更新を使用されるAEADに対してなんらかの
制限を越えるよりまえに、初期化しなくてはいけません(MUST)。

TLSはstream 0において保持されたコネクションにレコード保護のために
分割されたシークエンスナンバーを保持します。
このシークエンスナンバーはQUICから透過的ではありません。






5.5.  保護されたパケットの受理

いちど与えれたパケットナンバーとともにパケットの受信にエンドポイントが
成功したなら、
それはもしそれらが同じ鍵か(もし鍵更新がなされていたなら)
次のパケット保護鍵による十分な保護がされていないなら
類似して、
鍵更新の発生を表すパケットが十分に保護されていないものは
廃棄しなくてはならない(MUST)

パケットが保護されてないことへの失敗は攻撃かもしれないピアーに
プロトコルエラーの存在を示す必要は必ずしもありません。
QUICで用いられる切り詰められたパケットがナンバーエンコーディングは
もしはっきりと遅延されたなら、パケットナンバーが不適切に復号されることがあります。

# 5.6.  パケットナンバーギャップ

[QUIC-TRANSPORT] 7.5.1.1章もまたConnection ID転送において
パケットナンバーギャップを計算するために秘密鍵を要求します。
秘密鍵はこのように計算されます。

         packet_number_secret
             = TLS-Exporter("EXPORTER-QUIC Packet Number Secret"
                            "", Hash.length)

# 6.  保護されないパケット

QUICはすべての保護されないパケットに対して完全性検証を加えます。
交渉されたAEADによって保護されない任意のパケットは、
完全性検証を含みます。
この確認は通告からパケットを妨げません。

   This check does not prevent the packet
   from being altered, it exists for added resilience against data
   corruption and to provided added assurance that the sender intends to
   use QUIC.

保護されないパケットはすべてバージョンナンバーなどを含む
QUIC ヘッダの長い形式を用います。
QUICのこのバージョンに対して、
完全性検証は64bit FNV-1a ハッシュ(6.2章参照)を用います。
このハッシュの出力はパケットのペイロードに対して拡張されます。

完全性検証アルゴリズムはプロトコルの他のバージョンで変更しても良いです(MAY)。

# 6.1.  完全性検証手続き

エンドポイントはロングヘッダーを持つパケットと
保護されないであろうことを示すタイプ（0-RTT Encrypted (0x05),
1-RTT Encrypted (key phase 0) (0x06), もしくは 1-RTT Encrypted (key phase 1) (0x07))
が最初の完全性検証なしで送られるパケットを構築します。



送信者はそれからタイプフィールドから始まる与えられたパケットの
完全性検査を計算します。
そのハッシュの出力はパケットに追加されます。

最初の保護されないパケットを受け取る受信者はバージョンが正しいことを確認します。
それから、末尾8オクテットを削除します。
それはパケットの残りに他対して完全性検査を計算します。
有効な完全性検査を含まない保護されないパケットは廃棄されなければなりません(MUST)

# 6.2.  The 64-bit FNV-1a アルゴリズム

QUICは変種のFowler/Noll/Vo ハッシュ(FNV-1a) [FNV]の64bit版を用います。

   FNV-1a can be expressed in pseudocode as:

   "hash := offset basis for each input octet: hash := hash XOR input
   octet hash := hash * prime "

これは、offset basisに寄って64bit符号なし整数が初期化されます。
また入力のそれぞれのオクテットは排他的二進数論理和が取られ、
素数によって乗算されます。
操作のオーバーフローは廃棄されます。

64bit FNV-1aに対するoffset basisが14695981039346656037 (十二進数 0xcbf29ce484222325) とし、
素数は1099511628211 (十二進数 0x100000001b3 または 2^40 + 2^8 + 0xb3)

一度すべてのオクテットがこのやり方で処理されたなら、
ネットワークバイトオーダにおいて最後の整数値は8オクテットとして
符号化されます。

# 7.  キーフェーズ

TLSが0-RTTと1-RTT鍵の可用性を報告したなら、
新しいキーマテリアルがTLSから提供され、
QUICパケット保護に用いられます。
ハンドシェイクの間の転送のそれぞれで、
新しい鍵はTLSより提供され、
パケット保護鍵は秘密鍵に由来します。

鍵の新しい集合はそれぞれ出力パケットの保護に用いられます。
パブリックフラグのKEY_PASEビットは切り替えられます。
0-RTT 保護されたパケットはQUICロングヘッダーを用い、
それらは適切な鍵の選択のためにKEY_PHASEビットを用いません。

一度コネクションが完全に有効になったなら、
KEY_PHASEビットは変更を引き起こした最初のパケットを受信する必要なく
キーマテリアルの変更を検出するための複製を許可します。




KEY_PHASEはQUICショートヘッダの0x20ビットとしても含まれ、また
ロングヘッダからのパケットタイプによって決定される。
TLSハンドシェイクメッセージを有効にするのに必要な複雑なハンドシェイクの間は
鍵間の転送は正しいパケット保護に寄って送られる。(0x06はキーフェーズ0を示し0x07はキーフェーズ1を示す)



# 7.1.  TLSハンドシェイクのためのパケット保護

初期のパケット交換は保護なしで送られます。
これらのパケットはcleartext パケットタイプを用います。

TLSハンドシェイクメッセージはQUICパケット保護を用いて保護されては
いけません(MUST NOT)
両方のエンドポイントで送られるTLS Finished メッセージ以下すべてのTLSハンドシェイクメッセージは
cleartextパケットを用います。

TLSハンドシェイクの完了の後に送られる任意のTLS ハンドシェイクメッセージ
は特別なパケット保護ルールを必要としません。
これらのメッセージを含むパケットは送信する時点のパケット保護鍵を用います。

クライアントのように、サーバはその保護されないハンドシェイクメッセージを送るか
cleartextパケットにおいてクライアントから送られた保護されないハンドシェイクメッセージへ
応答しなくてはいけません(MUST)。

# 7.1.1.  初期鍵転送

いちどTLSハンドシェイクが完了したなら、
キーマテリアルはTLSから提供され、QUICパケット保護は開始します。

1-RTT鍵によって保護されたパケットは始めに0に設定されたKEY_PHASEをもちます。
このビットはそれぞれの続く鍵更新(7.2章参照)ごとに反転します。

もしクライアントが0-RTTデータを送るなら、
0-RTTパケットタイプをそれは使います。
TLS EndOfEarlyDataと Finished メッセージを含むパケットは暗号文パケットとして送られます。

ハンドシェイクの間は明確なパケットタイプを0-RTT データと1-RTT データに対して
使用することはサーバがパケット保護を除くために使われる鍵を識別することができると保証します。
これらのパケットのすべてはサーバにおいて非同期に到達します。



サーバはTLS ClientHelloの前に到達した0-RTTパケットを保持することを
選んでも良いです。
サーバはそれから一度ClientHelloが届いたこれらのパケットを使うことができます。
バッファする0-RTTパケットからサービスの拒否の可能性は重要です。
これらのパケットは認証できず、攻撃者によってサーバ資源を廃棄するため用いられているかもしれません。
保持されたパケットの数の制限は必要です。

TLS ハンドシェイクメッセージの最初の送信の後の1-RTT鍵の使用への
サーバ転送は、この段階から、サーバは1-RTT鍵によってすべてのパケットは保護します。
将来のパケットはそれゆえに1-RTT鍵によって保護されます。
はじめは、0のKEY_PHASEをつけられます。


# 7.1.2.  再送と保護されないパケットへの確認応

クライアントとサーバの両方からTLSハンドシェイクメッセージは
鍵交換において重大です。
鍵を決定するこれらのメッセージのコンテンツはそれよりあとのメッセージを
保護することに使います。
もしこれれのハンドシェイクメッセージが
これらの鍵によって保護されたパケットに含まれるなら、
これらは複製にたいして判読できないでしょう。

たとえ再送のとき嵐胃かぎが使用可能だったとしても、
これらのハンドシェイクメッセージの再送は暗号文パケットで
送られなくてはいけません(MUST)。
エンドポイントはこれらのメッセージに対するACKフレームを
生成しなければいけません(MUST)。



HelloRetryRequest ハンドシェイクメッセージは初期のClientHelloを拒否するために
使われるかもしれません。
HelloRetryRequest ハンドシェイクメッセージはServer Stateless Retry パケットにおいて
送られます。
任意の二番目のレスポンスにおいて送られるClientHelloはClient Initial パケットタイプを
用います。
どちらのパケットも保護されます。
当然ですが、なぜならこれらのメッセージが送られる必要のある時、
使用可能な新たなキーマテリアルはないからです。
HelloRetryRequestの受領において、
クライアントは0-RTT データの任意の転送を起こすべきです(SHOULD)。
0-RTTデータはHelloRetryRequestを送る任意のサーバによってのみ廃棄されるでしょう。

このパケットタイプは、
保護されたパケットが保護されないパケットから明確に識別されることを保証します。
損失と並べ替えは一度1-RTT鍵が使用できるようになっても、
保護されないパケットパケットを引き起こします。
保護されなパケットはそのパケットタイプを使う1-RTTパケットと簡単に
見分けられます。

一度エンドポイントに対して1-RTT鍵が使用可能になったら、
保護されないパケットによってTLSハンドシェイクメッセージが運ばれる
必要はありません。
サーバはレスポンスにおいてACKフレームを含む保護されないパケットを
受け取るためにTLSハンドシェイクメッセージを再送する必要があるかもしれません。
サーバははTLSハンドシェイクが完了を通知されるまで保護されないパケットの
ACKフレームを処理する必要があります(MUST)また、
そのハンドシェイクメッセージのすべての応答の、
保護されたパケットにおけるACKフレームを受けとります。





使うことの出来るキーフェーズの数を制限するために、
エンドポイントは任意の応答されていないハンドシェイクメッセージがある間は
鍵更新を始めてはいけません(MUST NOT)、7.2章を参照

# 7.2.  鍵の更新

一度TLSハンドシェイクが完了すると、KEY_PHASEビットは
両方のピアーによるキーマテリアルの作新を許可されます。
エンドポイントは追加の通知をすることなく直ちに更新された鍵を用い始めます。
KEY_PHASEビットにおける変化は使われる新しい鍵が使われることを示します。

エンドポイントは同時に一つより多くの鍵更新を始めてはいけません(MUST NOT)
新しい鍵は、エンドポイントが受け取りまた適切にKEY_PHASEが合う
パケットの解読が行われるまで使われることが出来ません。
0-RTTが仮定するときの注意は、
両方のピアーによって送られるパケットにおいてKEY_PHASEの値は異なります。

エンドポイントがKEY_PHASEビットを照合しないときの更新の検出を受け取ることが
予期されます。
それは新た無い秘密鍵を作成し、また対応は鍵とIVを読み取ります。
もしパケットがこれらの値を用いて解読され認証されることができるなら、
エンドポイントによって送られる次のパケットは、
新しい鍵を使うでしょう。

エンドポイントはそのピアーが鍵を更新したこと検出したとき、
直ちにパケットを送る必要はありません。
送る次のパケットは単純に新しい鍵を用います。
もしエンドポイントが更新された鍵を伴う任意のパケットを送り終わる前に、
二番目の更新を検知したなら、
それはそのピアーがが相互の更新を待つことなく再び鍵を更新したことを示します。
エンドポイントは致命的なエラーとして連続する鍵更新を赤いコネクションを中断
しなくてはいけません(MUST)

エンドポイントは鍵更新を引き起こしたパケットより小さなパケットナンバーを持つ
パケットの解読を許容するために短期的に古い鍵を保つべきです(SHOULD)
これはエンドポイントに鍵らの転送の間に再順列されたパケットを消費することを
許容します。
より大きなパケットナンバーを持つパケットは常に更新された鍵を用い、
また古い鍵によって解読されてはいけません(MUST NOT)

鍵とそれに対応する秘密鍵はエンドポイントが新しい鍵に用いられた最も低い
シークエンスナンバーより低いシークエンスナンバーを伴う全てパケットを
受信したとき、破棄されるべきです(SHOULD)
エンドポイントはもしその遅延の長さに影響をうけた鍵が過大なら
鍵を廃棄するかもしれません。




一度ハンドシェイクが完了したなら、同じKEY_PHASEを持つパケットは
短期間でのフレームの連続において複数の鍵更新がなく、 明瞭なパケット再整列されている限り、
同じパケット保護鍵を持つことを保証します。

      Initiating Peer                    Responding Peer

   @M QUIC Frames
                  New Keys -> @N
   @N QUIC Frames
                         -------->
                                             QUIC Frames @M
                             New Keys -> @N
                                             QUIC Frames @N
                         <--------

                           図5: 鍵更新

図3と図5に示されるように、
どこでピアーから受け取るかもしれない２つ以上のキーマテリアルがどこにあるかの
は起こりえません。
一度、鍵の送受信の両方が更新されたなら、

サーバはクライアントのFinishedメッセージを受け取るまで
鍵更新を始めることができません。
その点の他に、
更新された鍵によって保護されたパケットはハンドシェイクメッセージの再送に対して
混乱させることがあります。
クライアントはサーバによってすべてのハンドシェイクメッセージが
応答されるまで鍵更新を始めることが出来ません。

鍵更新を引き起こすパケットはより大きなパケットナンバーの成功する処理の後に
到達することがあります。
これはもし鍵漏洩、攻撃またはもし古い鍵の仕様を不適切にピアーが拒否するなら
可能です。
なぜなら後者は攻撃と異なることができず、
エンドポイントはもしその状況をけんしゅつしたなら直ちにコネクションを
中断しなくてはいけません(MUST)


# 8.  クライアントアドレス検証

TLSによって提供されたサーバにおけるクライアントソースアドレスの検証を
有効にする２つの道具は、HelloRetryRequestメッセージにおけるクッキー
とNewSessionTicketにおけるチケットです。

# 8.1.  HelloRetryRequest アドレス検証

TLS HelloRetryRequestメッセージにおけるクッキー拡張は
ハンドシェイクの間のソースアドレス検証として振る舞うことをサーバに許可します。





QUICは最初のClientHelloの処理の間にアドレス検証を要求するとき、
それが提供したトークンはHelloRetryRequestのクッキー拡張に含まれます。
出来る限りクッキーはクライアントによって推測されることはできません。
サーバはもし二番目のClientHelloに値を含むならクライアントはHelloRetryRequestを
受け取ることを保証されることが出来ます。

初期のClientHelloはクッキーは拡張を含みません。
それはもしサーバが再構築状態に必要なすべての情報を含むクッキーを構築したなら、
それはHelloRetryRequestの送信の後、ローカルの状態を廃棄できます。
ClientHelloにおける有効なクッキーの存在はClientHelloのクライアントからの
二度目の要求の試行を示します。

アドレス検証トークンは２つめのClientHelloから展開され、
また将来の検証のために転送に渡されることがあります。
もし有効が失敗したなら、サーバはTLSハンドシェイクに失敗し、illegal_parameterアラートを
送らなければなりません(MUST)

HelloRetryRequestの他の使用とアドレス検証の結合は
追加のラウンドトリップがハンドシェイクに加えられるいくつかの方法を
確保します。
特に、これは異なるクライアント鍵共有への要求とアドレス検証の要求の結合を
可能にします。

もしTLSが他の理由でHelloRetryRequestを送信する必要があるなら、
それはHelloRetryRequestが生成された理由を確かに識別することを保証します。
二番目のClientHelloの処理の間、もしアドレス検証がもともと要求されていないなら、
TLSはアドレス検証に対するトランスポートプロトコルの調査を必要としません。
そのような場合、不在かアドレス検証トークンを使用できるクッキー拡張は現れません。

# 8.1.1.  Stateless アドレス検証

コネクションを継続するためのすべての状態必要性の備えのために
サーバはクッキー拡張を用いることが出来ます。
これはサーバに有効ではないソースアドレスを持つクライアントに対して
状態を委託することを避けることを可能にします。

たとえば、サーバは要求された情報を暗号化するために静的に設定された鍵を
使用することが出来、またクッキーに情報を含むことが出来ます。
アドレス検証情報に加えて、暗号化を用いるサーバはClientHelloとその長さのハッシュを
復元できる必要もまたあります。加えて、任意の情報はHelloRetryRequestの
再構築のために必要です。




# 8.1.2.   HelloRetryRequestの送信

HelloRetryRequestメッセージの送信をするとき
サーバはコネクションに対して状態を保持する必要はありません。
これはサーバに対してサービスの露出を拒否することをさけるために
必要かもしれません。
しかしながら、これはサーバに置いて転送が損失することに対する情報を
意味します。
これはstream 0のストリームオフセット、サーバが選んだパケットナンバー
ラウンドトリップタイムを計測する任意の機会を含みます。

サーバはServer Stateless RetryパケットにおけるTLS HelloRetryRequestを
送らなければいけません(MUST)
Server Stateless Retryパケットの使用はクライアントにおけるストリームオフセットのリセットを起こします。

   A server MUST send a TLS HelloRetryRequest in a Server Stateless
   Retry packet.  Using a Server Stateless Retry packet causes the
   client to reset stream offsets.  It also avoids the need for the
   server select an initial packet number, which would need to be
   remembered so that subsequent packets could be correctly numbered.

   A HelloRetryRequest message MUST NOT be split between multiple Server
   Stateless Retry packets.  This means that HelloRetryRequest is
   subject to the same size constraints as a ClientHello (see
   Section 4.4).

# 8.2.  NewSessionTicket アドレス検証

TLS NewSessionTicketメッセージにおけるチケットは
サーバがクライアントに対しチケットに近い集合を提供する事を許可します。
0-RTTが試みられているかに関わらず、クライアントがコネクションを消費する時、
それはハンドシェイクメッセージにチケットを含みます。
HelloRetryRequest クッキーを伴うなら、
サーバはチケットにアドレス検証トークンを含みます。
それがソースアドレストークンを必要とされるかを問う時、
TLSはセッションチケットから展開したトークンを転送に提供します。

もしHelloRetryRequestクッキーとするセッションチケットの両方がClientHelloに存在するなら、
クッキーから渡されたトークンはただ転送に渡されるのみです。
二つ目ClientHelloを示すクッキーの存在、セッションチケットからのトークンは、それが最初のClientHello に現れる時転送に提供されるでしょう。

さーbはいかなる時でもNewSessionTicket を送ることができます。
これは状態、そしてアドレス検証トークンの更新を許可します。
これはチケットやトークンの刷新が行われるかもしれなかったり、
コネクションの状態の変更がレスポンスにおいて生成されるかもしれません。
QUICは新しいアドレス検証トークンが提供されたことにより送られたNewSessionTicket を要求することができます。

0-RTTをサポートするつもりのサーバはTLSハンドシェイクが完了したのち直ちに
アドレス検証トークンを提供するべきです(SHOULD)




# 8.3.  Address トークン完全性

TLSは転送が何らかのやり方で完全性保護に資さないかぐり、
アドレス検証トークンを提供しなくてはいけません(MUST )
  再開用秘密鍵のような機密情報を含むNewSessionTicket のために、トークンが保護のオーバーヘッドの重複なく機密性と完全性保護の両方を与える認証付き暗号化の元においてトークンを含みます。

# 9.  プリハンドシェイク QUIC メッセージ

実装はパケット保護なくstream 0以外の任意のストリームでデータを交換してはいけません(MUST NOT)。
QUICはこの時期において、損失検知と回復の管理に対するフレームのいくつかのタイプの使用を必要とします。
加えて、輻輳制御のための認証されないメッセージの効果の間、獲得されたデータの使用に有益かもしれません。


この章はもっぱら、両方のピアーからのハンドシェイクメッセージに対しこれらのメッセージが送ったパケットの応答を適用するのみです。多くの場合、応答を提供するサーバに対する要件は小さいです。クライアントが送ったメッセージ以降は小さく、サーバのレスポンスによって暗黙的に応答します。

ピアーあ認証されないパケットの受診結果をあつかう振る舞いは制限されることが必要です。特に、これらのパケットによって接続された状態は、一度もレコードパケット保護のために使われることは出来ません。

これらにはハンドシェイクの完了以前の認証されないパケットを扱うことにいくつか可能なアプローチがあります。

- 廃棄しこれら無視する
- これらを使用する。しかし、ハンドシェイクが一度完了したなら確立したいかなる状態ですはリセットする。
- これらの使い、のちにこれらを認証する。認証されなかったならハンドシェイクを失敗する
- これらを保持し、これら正しく認証されることができた時、これらを用いる
- 致命的な失敗として扱う

戦略の違いはデータの違いである。
この文書はメッセージの種類によってすべての戦略が可能であることを提案する。

- トランスポートパラメータはTLSハンドシェイクの一部として使用に適し認証され作られる。
- ハンドシェイクに完了を許す小さい番号の必要性の期待を受け取ったとき、ほとんどの保護されないメッセージは失敗として扱われる。
- 保護されたパケットは廃棄とのちの使用のために保護されることのどちらもできます。


# 9.1.  ハンドシェイク完了の前の保護されないパケット

この章はTLS ハンドシェイクが完了するより前のメッセージの操作を説明する。

保護されないパケット送受信は危険である。明確に許可されない限りは任意の種類の保護されないパケットの受信は致命的な失敗として扱われる。

# 9.1.1.  STREAM Frames


stream 0のための"STREAM" フレームはは許可されます。
これらはTLSハンドシェイクメッセージを運送します。
一度、0-RTT鍵が使用可能になったら、stresm 0に対する保護されないパケットは無視されます。

他のストリームに対する保護されない "STREAM" フレームは致命的な失敗として扱われなければなりません(MUST)

# 9.1.2.  ACK Frames

"ACK"フレームはハンドシェイクが完了する前に許可されます。
"ACK"フレームから得た情報は攻撃者がこれらのパケットを注入出来る間は
まったく依りません。
"ACK"フレームからの時間通知とパケットの再送情報プロトコルの信頼性とって重大です。
しかし、これらのフレームはなりすまされなり変わられるかもしれまｓねｎ。

エンドポイントは0-RTTもしくは1-RTT鍵によって保護された応答情報に対して
保護されない"ACK"フレームを用いることがあってはいけません(MUST NOT)
エンドポイントはもし保護されたパケットにおいて、送られた応答情報を主張するなら
"ACK"フレームは保護されないフレームを無視しなくてはいけません(MUST)
応答がサービスの拒否のとして提供することしか出来ないようなとき、
保護されたデータを読み取ることの出来るエンドポイントは常に保護されたデータを
送信することができます。


   ISSUE:  What about 0-RTT data?  Should we allow acknowledgment of
      0-RTT with unprotected frames?  If we don't, then 0-RTT data will
      be unacknowledged until the handshake completes.  This isn't a
      problem if the handshake completes without loss, but it could mean
      that 0-RTT stalls when a handshake packet disappears for any
      reason.

エンドポイントは初期のハンドシェイクの間と1-RTT保護された"ACK"フレームからの不十分な
情報を持つときのみ、
保護されないもしくは0-RTT保護された"ACK"フレームからのデータを用いるべきです(SHOULD)
一度十分な情報が保護されたメッセージ得られたなら、
信頼に足らない情報元から得た情報は廃棄されることが出来ます。

# 9.1.3.  データの更新とストリーム制限

   "MAX_DATA", "MAX_STREAM_DATA", "BLOCKED", "STREAM_BLOCKED", and
   "MAX_STREAM_ID" フレームは　保護されずに送られてはいけません(MUST NOT)

   stream 0においてデータは交換されるにもかかわらず、
   そのストリームにおける初期フローコントロールウィンドウは
   TLSハンドシェイクを完了させるためには十分に大きいです。
これはTLSハンドシェイクの最大サイズを制限し、
サーバとクライアントが異常に大きな証明書チェインを使用することを
阻止します。

ストリーム0はコネクションレベルフローコントロールウィンドウから覗かれます。

この結果フローコントロールにおいて妨げられることを知らされることの必要はありません。

同様に、ハンドシェイクが完了するまで許されたストリームの数を増やすことの必要はありません。

# 9.1.4. 保護されないパケットを伴うサービスの拒否

保護されないものを受け入れること、特に認証されないものは
パケットがエンドポイントに対してサービス拒否を起こすリスクがあります。
認証されないパケットを注入できる攻撃者は受信者が
照合されたシークエンスナンバーを伴う保護されたパケットさえ欠損させることができます。
偽装のパケットは純正のパケットを覆い隠し、純正のパケットが冗長として無視されることを引き起こします。

一度TLSハンドシェイクが完了したなら、両方のピアーは
保護されないパケットを無視しなくてはいけません(MUST)
これ以降、保護されないメッセージは安全に損失されることが出来ます。
平文で送られるTLSハンドシェイクパケットと応答
攻撃者は 実装に 損失または隠蔽されたパケットに対する再送を中継させることが出来る。
ゆえに、エンドポイントに対してサービスを拒否するつもりの攻撃者は
彼らの犠牲者が保護されないパケットを受け取るために
保護されたパケットを損失または隠蔽する必要がある。
パケットの隠蔽の能力は攻撃者は経路にいる必要がないことを意味する。

有効なパケットの欠損を引き起こすことに加えて、
攻撃者は処理資源の拡大を故意に受信者に引き起こすパケットを生成することが出来ます。
これらの危険性に対する議論は11.2章を参照してください。

有用ではないデータを含むTLSパケットを受け取ることを避けるために、
TLSの実装はからのTLSハンドシェイクレコードとTLS状態機械に
許可されていない任意のレコードとを拒否しなくてはなりません(MUST)
ハンドシェイクの終了より前の任意のTLSアプリケーションデータとアラートは
致命的な誤りとして扱われなければなりません(MUST)


# 9.2.  Use of 0-RTT Keys

もし0-RTT鍵が使えるのであれば、リプレイ保護の欠落は
プロトコルにおいてリプレイ攻撃を避けるために使用の制約が必要であることを
意味します。

クライアントは冪等性のあるデータの保護のためにだけに0-RTT鍵を使わなければなりません(MUST)
クライアントはTLSハンドシェイクの前に送る何かしらのデータにおいて追加の制約を望んでも良いです(MAY)
クライアントはそのほかにおいて1-RTT鍵と同等に0-RTT鍵を扱います。

サーバによって受理された0-RTTデータの表示を受け取ったクライアントは
それがサーバのハンドシェイクメッセージのすべてを受け取るまで0-RTTデータを
送ることが出来ます。
クライアントはもしそれが0-RTTを拒否された0-RTTデータの表示を受け取ったなら0-RTTデータの送信を
止めるべきです(SHOULD)

サーバはパケットの保護のために0-RTT鍵を使うことがあってはいけません(MUST NOT)

# 9.3.  Receiving Out-of-Order Protected Frames

再整理と損失を扱うため、保護されたパケットは最後のTLSハンドシェイクメッセージが受け取られる前に
エンドポイントによって受け取られるかもしれません。
クライアントはサーバからの1-RTTパケットを解読することが出来ないでしょう。

一方サーバはクライアントからの1-RTTパケットを解読することが出来るでしょう。

1-RTT鍵によって保護されたパケットは保持され、後に解読され、
一度ハンドシェイクが完了したなら使われてもよいです(MAY)
サーバがクライアントFinishedメッセージかどうか検証される前に
1-RTT保護されたパケットを使うことがあってはいけません(MUST NOT)
その場合、サーバはpre-shared key- pre shared key binder([I-D.ietf-tls-tls13] の4.2.8章を参照)を使うことを選ぶでしょう。
それらの値の検証はClientHelloが変更されていないことの保証をサーバに提供します。

サーバはTLS ClientHelloを受け取る前に0-RTT鍵によって保護されたパケットを受け取ることが出来ます.
サーバはClientHelloの受信の予期において後の解読に対してこれらのパケットを保持しても良いです(MAY)

TLS Finishedメッセージの受信と検証はTLS ハンドシェイクの完全性の保証に重要です。
サーバはもしそのレスポンスがクライアント認証に依存しているのなら
クライアントFinishedメッセージの検証の前にクライアントの保護されたパケットを
用いることがあってはいけません(MUST NOT)

# 10.  QUIC-Specific Additions to the TLS Handshake

QUICはただの暗号的なパラメータの交渉以上にTLSハンドシェイクを用います。
TLSハンドシェイクはプロトコルバージョンの選択、QUICトランスポートパラメータ
の主だった値の提供そしてサーバがクライアントのルーティング可能性を返す振る舞いを
許可することを有効にします。

# 10.1.  Protocol and Version Negotiation

QUICバージョンネゴシエーションメカニズムはハンドシェイクの完了の前に
使われるQUICのバージョンの交渉に使われます。
しかいしながら、このパケットは認証されず、能動的な攻撃者が
バージョンダウングレードを強制する可能性を与えます。

攻撃者によってQUICバージョンダウングレードが強制されないことを保証するために、
バージョン情報はQUICネゴシエーションの完全性保護を提供するTLSハンドシェイクの中に複製されます。
これはハンドシェイクの完了の前のバージョンダウングレードを妨げません。
ゆえにこれはダウングレードはハンドシェイクの失敗を起こすことを意味します。

TLSはApplication Layer Protocol Negotiation (ALPN) [RFC7301]を
アプリケーションプロトコルを選択することに使います。
アプリケーションレイヤープロトコルは操作できるQUICバージョンらを制限します。
サーバはクライアントが選んだQUICバージョンに互換性のある
アプリケーションプロトコルを選ばなくてはいけません(MUST)

もしサーバが互換性のあるアプリケーションプロトコルとQUICバージョンの
結合を選べなかったら、
それはコネクションを中断しなければいけません(MUST)。
もしサーバがQUICバージョンとALPN識別子の互換性のない結合を
選択したならクライアントはコネクションを中断しても良いです(MAY)

# 10.2.  QUIC Transport Parameters Extension

QUICトランスポートパラメータはTLS拡張に持ち込まれます。
QUICの異なるバージョンはこの構造体に対して異なる形式を
定義するかもしれません


TLSハンドシェイクにおいけトランスポートパラメータが含まれることは
これらの値に完全性保護を提供します。

      enum {
         quic_transport_parameters(26), (65535)
      } ExtensionType;


quic_transport_parameters拡張の"extension_data"フィールドは
使われるQUICのバージョンによって定義された値を含みます。
[QUIC-TRANSPORT]に定義されているものが使われるとき、
quic_transport_parameters拡張はTransportParametersに持ち込まれます。


quic_transport_parameters拡張はハンドシェイクの間ClientHelloとEncryptedExtensionsメッセージ
に同封されます。
拡張はNewSessionTicketメッセージに含まれていても良いです(MAY)


# 10.3.  Priming 0-RTT

  QUICはTLSを修正なく用います、故にTCP上で確立されたTLSハンドシェイクにおける
  pre-shared鍵をQUIC上で0-RTTを有効に出来る可能性があります。
  同様に、QUICはTCPにおいて0-RTTを有効にするpre-shared鍵を提供できます。

  ALPNラベルの例外など0-RTTの使用を適応するにあたってのすべての制約は
  明確に互換性のあるラベルによってのみ変更しなければなりません(MUST)
  クライアントはどこでALPN拡張で最初のAPLNラベルの設定によってALPNラベルが
  選ばれたかを示します。

サーバが使う証明書は異なるプロトコル・スタックと異なるポート番号を使う
両方のコネクションによって有効だと考えられなければなりません(MUST)
たとえば HTTP/1.1 とHTTP/2は異なるポート番号を用います。
たとえば HTTP/1.1　と HTTP/2はTLSとTCP上で動作する一方
QUICはUDP上で動作します。


ソースアドレス検証は異なるプロトコル・スタック間で完全に
可搬ではありません。
ソースIPアドレスが定数で保持されていたとしても、
ポート番号は異なる可能性が高いです。
パケット反射攻撃はこの状況いまだ可能です。
ゆえにこの攻撃を始めるホストの集合大幅に短縮されます。
サーバはそのようなコネクションに対するソースアドレス検証を
避けるかもしれません。また、ソースアドレス検証なくクライアントに対して送られるデータ
の良を増やすことを許可するかもしれません。

# 11.  Security Considerations

いくつか現実の致命的な失敗が結局ある可能性があります。
しかし現在の問題らは本文の関連する章でしっかりと補足されています。

セキュリティに影響しないものはセキュリティの考察では仮定しません。
文章の多くで行います。

11.1.  Packet Reflection Attack Mitigation

サーバからハンドシェイクメッセージの大きな塊を返す小さなClientHelloは
攻撃者によって生成されたトラフィックを増幅するパケット反射攻撃に使われることがあります。

証明書のキャッシュ[RFC7924]は明瞭にサーバのハンドシェイクメッセージを削減することができます

QUICはClientHelloを含むパケットが最小サイズに拡張されることを要求します。
送るデータがこのサイズより少ない倍率なら
サーバは反射攻撃するパケットを生成する可能性がより少なくなります
もし送るハンドシェイクメッセージがClientHelloを含むパケットの著しく大きいサイズである花王の性が高いなら、
サーバはHelloRetryRequestを用いるべきです(SHOULD)


11.2.  Peer Denial of Service

QUIC, TLSそしてHTTP/2は複数の文脈において正しく使用されているメッセージを含みます。
しかしそれはコネクション状態において目につくほどの衝撃なく処理資源の増大を
ピアーに起こることを乱用することができます。
もし処理が状態か帯域幅において観察できる作用に対して圧縮率が著しく大きいなら、
結果によらず悪意あるピアーが処理能力を消費する可能性があります。

QUICはFINビットが設定されうることなく空の"STREAM"フレームが送られることを禁止します。
これは無意味に送られた"STREAM"フレームを妨げます。

TLSレコードとは常に少なくとも一つのハンドシェイクメッセージかアラートを含むべきです(SHOULD)
しかし不必要な処理を生成する過大な数なら、
ハンドシェイクの間はパディングを含むだけのレコードと許可されます。
一度ハンドシェイクが完了したなら、エンドポイントは
QUICレコードの長さを隠すことなくTLSアプリケーションデータレコードを
送るべきではありません(SHOULD NOT)
QUICパケット保護はパディングに対していかなる割当も含みません。
パディングされたTLSアプリケーションデータにレコードとはQUICフレームの
長さを隠すために使われることが出来ます。


いくつかの冗長なパケットの正当な使用がある間、
実装は冗長なパケットを辿り、攻撃の誘導として
生産的でないパケットの過大な塊を扱います。

12.  Error codes

暗号ハンドシェイクに割り当てられているQUICエラーコードの部分空間は
0xC0000000-0xFFFFFFFFです。
以下のエラーはTLSが暗号化ハンドシェイクに用いられるときに定義されます。




   TLS_HANDSHAKE_FAILED (0xC000001C):  The TLS handshake failed.

   TLS_FATAL_ALERT_GENERATED (0xC000001D):  A TLS fatal alert was sent,
      causing the TLS connection to end prematurely.

   TLS_FATAL_ALERT_RECEIVED (0xC000001E):  A TLS fatal alert was
      received, causing the TLS connection to end prematurely.

# 13.  IANA Considerations

   This document does not create any new IANA registries, but it does
   utilize the following registries:

   o  QUIC Transport Parameter Registry - IANA is to register the three
      values found in Section 12.

   o  TLS ExtensionsType Registry - IANA is to register the
      quic_transport_parameters extension found in Section 10.2.
      Assigning 26 to the extension would be greatly appreciated.  The
      Recommended column is to be marked Yes.

   o  TLS Exporter Label Registry - IANA is requested to register
      "EXPORTER-QUIC 0-RTT Secret" from Section 5.2.1; "EXPORTER-QUIC
      client 1-RTT Secret" and "EXPORTER-QUIC server 1-RTT Secret" from
      Section 5.2.2; "EXPORTER-QUIC Packet Number Secret" Section 5.6.
      The DTLS column is to be marked No.  The Recommended column is to
      be marked Yes.

# 14.  References

# 14.1.  Normative References

   [I-D.ietf-tls-tls13]
              Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", draft-ietf-tls-tls13-20 (work in progress),
              April 2017.

   [QUIC-TRANSPORT]
              Iyengar, J., Ed. and M. Thomson, Ed., "QUIC: A UDP-Based
              Multiplexed and Secure Transport", draft-ietf-quic-
              transport (work in progress), June 2017.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.





   [RFC5116]  McGrew, D., "An Interface and Algorithms for Authenticated
              Encryption", RFC 5116, DOI 10.17487/RFC5116, January 2008,
              <http://www.rfc-editor.org/info/rfc5116>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <http://www.rfc-editor.org/info/rfc5869>.

   [RFC7301]  Friedl, S., Popov, A., Langley, A., and E. Stephan,
              "Transport Layer Security (TLS) Application-Layer Protocol
              Negotiation Extension", RFC 7301, DOI 10.17487/RFC7301,
              July 2014, <http://www.rfc-editor.org/info/rfc7301>.

# 14.2.  Informative References

   [AEBounds]
              Luykx, A. and K. Paterson, "Limits on Authenticated
              Encryption Use in TLS", March 2016,
              <http://www.isg.rhul.ac.uk/~kp/TLS-AEbounds.pdf>.

   [FNV]      Fowler, G., Noll, L., Vo, K., Eastlake, D., and T. Hansen,
              "The FNV Non-Cryptographic Hash Algorithm", draft-
              eastlake-fnv-13 (work in progress), June 2017.

   [QUIC-HTTP]
              Bishop, M., Ed., "Hypertext Transfer Protocol (HTTP) over
              QUIC", draft-ietf-quic-http (work in progress), June 2017.

   [QUIC-RECOVERY]
              Iyengar, J., Ed. and I. Swett, Ed., "QUIC Loss Detection
              and Congestion Control", draft-ietf-quic-recovery (work in
              progress), June 2017.

   [RFC2818]  Rescorla, E., "HTTP Over TLS", RFC 2818,
              DOI 10.17487/RFC2818, May 2000,
              <http://www.rfc-editor.org/info/rfc2818>.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, DOI 10.17487/RFC5280, May 2008,
              <http://www.rfc-editor.org/info/rfc5280>.

   [RFC7924]  Santesson, S. and H. Tschofenig, "Transport Layer Security
              (TLS) Cached Information Extension", RFC 7924,
              DOI 10.17487/RFC7924, July 2016,
              <http://www.rfc-editor.org/info/rfc7924>.




Appendix A.  Contributors

   Ryan Hamilton was originally an author of this specification.

Appendix B.  Acknowledgments

   This document has benefited from input from Dragana Damjanovic,
   Christian Huitema, Jana Iyengar, Adam Langley, Roberto Peon, Eric
   Rescorla, Ian Swett, and many others.

Appendix C.  Change Log

      *RFC Editor's Note:* Please remove this section prior to
      publication of a final version of this document.

   Issue and pull request numbers are listed with a leading octothorp.

C.1.  Since draft-ietf-quic-tls-02

   o  Updates to match changes in transport draft

C.2.  Since draft-ietf-quic-tls-01

   o  Use TLS alerts to signal TLS errors (#272, #374)

   o  Require ClientHello to fit in a single packet (#338)

   o  The second client handshake flight is now sent in the clear (#262,
      #337)

   o  The QUIC header is included as AEAD Associated Data (#226, #243,
      #302)

   o  Add interface necessary for client address validation (#275)

   o  Define peer authentication (#140)

   o  Require at least TLS 1.3 (#138)

   o  Define transport parameters as a TLS extension (#122)

   o  Define handling for protected packets before the handshake
      completes (#39)

   o  Decouple QUIC version and ALPN (#12)







C.3.  Since draft-ietf-quic-tls-00

   o  Changed bit used to signal key phase

   o  Updated key phase markings during the handshake

   o  Added TLS interface requirements section

   o  Moved to use of TLS exporters for key derivation

   o  Moved TLS error code definitions into this document

C.4.  Since draft-thomson-quic-tls-01

   o  Adopted as base for draft-ietf-quic-tls

   o  Updated authors/editors list

   o  Added status note

Authors' Addresses

   Martin Thomson (editor)
   Mozilla

   Email: martin.thomson@gmail.com


   Sean Turner (editor)
   sn3rd

   Email: sean@sn3rd.com



















Thomson & Turner        Expires December 15, 2017              [Page 37]
